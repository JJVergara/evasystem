This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.log, tmp/, gradle/, .idea/, build/, .kotlin/, .gradle/, app/build/, app/src/main/assets/, app/src/androidTest/, app/src/main/res/drawable/, app/src/main/res/raw/, app/src/test/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
assets/
  image-a2075bde-30aa-424c-88ee-5ace9590fd88.png
  image-bf1faf72-113e-4747-bc54-1e1088c90406.png
  image-eac4d58f-96a2-4925-aac8-2a5cc8276b20.png
n8n-workflows/
  01-auth-user-registration.json
  02-event-management.json
  03-ambassador-management.json
public/
  favicon.ico
  placeholder.svg
  robots.txt
scripts/
  MOCK_DATA_README.md
  mock-instagram-data.ts
  test-story-insights-cron.ts
src/
  assets/
    eva-logo.png
    hero-image.jpg
  components/
    Ambassadors/
      AddAmbassadorModal.tsx
      AmbassadorActivityTimeline.tsx
      AmbassadorManagement.tsx
      AmbassadorMetricsCards.tsx
      AmbassadorPerformanceChart.tsx
      AmbassadorRequestsTab.tsx
      DeleteAmbassadorModal.tsx
      EditAmbassadorModal.tsx
      EnhancedAmbassadorDashboard.tsx
      InstagramProfileLink.tsx
    Analytics/
      AdvancedDashboard.tsx
      EnhancedAnalytics.tsx
      StoryInsightsDashboard.tsx
    Auth/
      AuthForm.tsx
      ProtectedRoute.tsx
      SimpleAuthForm.tsx
    Automation/
      AutomationRules.tsx
    Cards/
      FeedbackCards.tsx
      RealtimeCards.tsx
    Dashboard/
      AmbassadorRanking.tsx
      DashboardContent.tsx
      EnhancedDashboardContent.tsx
      EVABrandedDashboard.tsx
      EventDashboard.tsx
      FiestaMetricsCard.tsx
      FiestaSelector.tsx
      MetricCard.tsx
      SimpleDashboardContent.tsx
      SimpleEventDashboard.tsx
    ErrorBoundary/
      ErrorBoundary.tsx
      ErrorMessage.tsx
    Events/
      CreateEventModal.tsx
      EventChecklists.tsx
      EventManagement.tsx
      EventPhases.tsx
      SimpleCreateEventModal.tsx
      SimpleEventChecklists.tsx
      SimpleEventsList.tsx
    Fiestas/
      CreateFiestaModal.tsx
      FiestaDetailsModal.tsx
      FiestaSelector.tsx
      FiestasManagement.tsx
    ImportExport/
      BackupCenter.tsx
      ImportExportCenter.tsx
      ImportExportReal.tsx
    Instagram/
      InstagramBusinessDashboard.tsx
      InstagramConnect.tsx
      InstagramDashboard.tsx
      InstagramSyncStatus.tsx
    Layout/
      AppBackground.tsx
      GlassPanel.tsx
      LanguageSwitcher.tsx
      MainLayout.tsx
      NotificationDropdown.tsx
      PageHeader.tsx
      Sidebar.tsx
      UserProfileDropdown.tsx
    Logo/
      ModernLogo.tsx
    Mentions/
      MentionsManagement.tsx
    N8n/
      N8nIntegration.tsx
    Notifications/
      NotificationCenter.tsx
    Onboarding/
      OnboardingWizard.tsx
    Organizations/
      DeleteOrganizationModal.tsx
      EditOrganizationModal.tsx
      MembersManagement.tsx
      OrganizationAmbassadorsList.tsx
      OrganizationDashboard.tsx
      OrganizationEventsList.tsx
      OrganizationMetricsCards.tsx
      OrganizationPerformanceChart.tsx
      OrganizationSwitcher.tsx
    Profile/
      UserProfile.tsx
    Reports/
      ReportsCenter.tsx
    Security/
      SecurityCenter.tsx
    Settings/
      EnhancedInstagramSettings.tsx
      InstagramConfigChecklist.tsx
      InstagramConfigGuide.tsx
      InstagramDiagnosticsPanel.tsx
      InstagramSettings.tsx
      MetaAppCredentialsForm.tsx
      N8nConfigurationSection.tsx
      SettingsContent.tsx
    Stories/
      CreateTaskModal.tsx
      StoriesManagement.tsx
      TaskFilters.tsx
      TaskStatsCards.tsx
      TaskStatusBadge.tsx
    StoryMentions/
      StoryMentionDetails.tsx
      StoryMentionsList.tsx
    System/
      SystemHealthDashboard.tsx
    ui/
      accordion.tsx
      alert-dialog.tsx
      alert.tsx
      aspect-ratio.tsx
      avatar.tsx
      badge.tsx
      breadcrumb.tsx
      button.tsx
      calendar.tsx
      card.tsx
      carousel.tsx
      chart.tsx
      checkbox.tsx
      collapsible.tsx
      command.tsx
      context-menu.tsx
      dialog.tsx
      drawer.tsx
      dropdown-menu.tsx
      form.tsx
      hover-card.tsx
      input-otp.tsx
      input.tsx
      label.tsx
      menubar.tsx
      navigation-menu.tsx
      pagination.tsx
      popover.tsx
      progress.tsx
      radio-group.tsx
      resizable.tsx
      scroll-area.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      sidebar.tsx
      skeleton.tsx
      slider.tsx
      sonner.tsx
      switch.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      toast.tsx
      toaster.tsx
      toggle-group.tsx
      toggle.tsx
      tooltip.tsx
      use-toast.ts
  hooks/
    use-mobile.tsx
    use-toast.ts
    useAdvancedAnalytics.ts
    useAmbassadorInstagramStatus.ts
    useAmbassadorMetrics.ts
    useAmbassadorRequests.ts
    useAuth.ts
    useAuthCleanup.ts
    useCurrentOrganization.ts
    useDebounce.ts
    useEventLogger.ts
    useFiestaMetrics.ts
    useFiestas.ts
    useInstagramConnection.ts
    useInstagramDiagnostics.ts
    useInstagramSync.ts
    useMentionsManagement.ts
    useMentionsOptimized.ts
    useN8nWebhooks.ts
    useNotifications.ts
    useOnboardingStatus.ts
    useOrganizationMetrics.ts
    useOrganizationSettings.ts
    useRealEventLogs.ts
    useRealNotifications.ts
    useRealtimeCards.ts
    useRealtimeSocialMentions.ts
    useStoryInsightsAnalytics.ts
    useStoryMentions.ts
    useTasksManagement.ts
    useUserProfile.ts
  i18n/
    index.ts
  integrations/
    supabase/
      client.ts
      types.ts
  lib/
    utils.ts
  pages/
    Ambassadors.tsx
    Analytics.tsx
    auth-callback.tsx
    Auth.tsx
    Events.tsx
    ImportExport.tsx
    Index.tsx
    InstagramBusiness.tsx
    InstagramDiagnostics.tsx
    Mentions.tsx
    MentionsOptimized.tsx
    MetaOAuthProxy.tsx
    NotFound.tsx
    Notifications.tsx
    Onboarding.tsx
    Profile.tsx
    Settings.tsx
    Stories.tsx
    StoryMentions.tsx
    SystemConfig.tsx
  types/
    storyMentions.ts
  App.css
  App.tsx
  index.css
  main.tsx
  vite-env.d.ts
supabase/
  functions/
    backup-full-database/
      index.ts
    cleanup-oauth-states/
      index.ts
    collect-story-insights/
      index.ts
    create-ambassador/
      index.ts
    create-event/
      index.ts
    disconnect-instagram/
      index.ts
    export-organization-data/
      index.ts
    facebook-data-deletion/
      index.ts
    handle-user-registration/
      index.ts
    import-ambassadors/
      index.ts
    instagram-diagnostics/
      index.ts
    instagram-profile/
      index.ts
    instagram-send-message/
      index.ts
    instagram-sync/
      index.ts
    instagram-token-status/
      index.ts
    instagram-webhook/
      index.ts
    meta-oauth/
      index.ts
    resolve-story-mentions/
      index.ts
    restore-organization-data/
      index.ts
    secure-webhook-proxy/
      index.ts
    shared/
      auth.ts
      constants.ts
      crypto.test.ts
      crypto.ts
      error-handler.ts
      instagram-api.ts
      responses.ts
      test-crypto.sh
      types.ts
    story-mentions-state-worker/
      index.ts
    deno.json
    import_map.json
  migrations/
    20250101000000_add_story_referral_to_mention_type.sql
    20250729023524-9842c490-c174-43d9-a909-c10b66c00968.sql
    20250729141810-f50a6199-f737-4438-adcf-b709b22811b8.sql
    20250729142148-b68c29e6-6e84-4bdd-98f4-9a087c62f65e.sql
    20250730022244-040c1408-8ec0-4177-9a8d-3ef292ac3adf.sql
    20250731021231_13122cbb-6a33-404c-ae82-ff1287b53390.sql
    20250731021320_fbba82a6-30ba-49a1-b3f7-80ce436002ca.sql
    20250731021347_23254cae-680e-4da3-adab-540d93726138.sql
    20250805155412_1b2a65fd-49fd-4baf-afee-177d112872c2.sql
    20250806153145_b3fec699-78c3-4da8-85a6-f2086f2647f3.sql
    20250806153214_ef5be62d-c47e-4398-a76b-a452789108cc.sql
    20250806154620_3fd6529b-393c-42a0-9bde-a19105b7915c.sql
    20250806164708_28757176-ea58-41dc-965e-c451e29c8b8e.sql
    20250806183309_421c28cc-30a4-44db-8603-695d413ea43b.sql
    20250806183820_195c0f0d-3bce-4a2b-a12c-4556632bc536.sql
    20250806185931_90869d09-cef0-4941-a2a0-a139e2f98a3b.sql
    20250806201357_1dda40d3-8ce6-4ee6-8d57-022c56948c9d.sql
    20250806211038_0bdafee0-d226-42c4-8df0-558b061cfe40.sql
    20250806214309_4c3840a5-6346-4e17-9050-6e41b0778e83.sql
    20250806215231_15fbcf86-e644-411b-a436-c1ce909393f5.sql
    20250807151547_b253ceec-da49-4a46-a790-5e6fecbe393a.sql
    20250807151617_14907565-74b5-4ba3-b29a-c01e8383fc91.sql
    20250807152416_4fb6e41c-d38f-4f15-8721-fe33bd86c285.sql
    20250807154354_e0cdea1b-e345-415b-90b3-3c7ff566116d.sql
    20250807154439_665bd0c2-4a3e-4920-ae95-e576ddd88cff.sql
    20250807160052_65ee9f18-dfdc-4c38-8238-d7bf14919b85.sql
    20250807163200_44622a60-f761-4be2-a519-828ed531041f.sql
    20250807164711_086b8727-ab9c-4968-9130-bcf6c188430c.sql
    20250807164805_a4b04746-29cf-428a-88f7-68a37b433d15.sql
    20250807164850_01cefc6c-a71a-4827-94a7-12bc22ca2619.sql
    20250807170546_c32bf32e-0541-4dc5-87d3-524d9ccae7e7.sql
    20250811162727_be03bf7a-11bf-4701-9877-cd74b7950d45.sql
    20250811180746_1d1637d8-f391-4e30-b67d-da2206e5ac38.sql
    20250811191623_296b0a22-4886-4a0a-99bf-c6b2e5506bab.sql
    20250818195000_fcc80f72-8bb9-434f-8b1b-535ce27fdd85.sql
    20250820202107_ea5b187c-250f-40f2-a7ff-aa073788f414.sql
    20250820202942_15ecef57-50d8-49a1-b0a1-9a7437d0a3c9.sql
    20250820203059_a16ade44-7b02-431e-a5d7-c0f1f01a5773.sql
    20250820203141_d1a73e87-732a-4ba9-9c26-7b9cb9a61378.sql
    20250820203208_73fca020-156e-4f21-9a20-a067ec44c363.sql
    20250820203511_da55945b-622f-4df7-b725-c219697816d8.sql
    20250820204442_2829495c-e27e-411f-a36f-3e94b52d41e9.sql
    20250820204650_ebdc6b47-8529-485f-85e1-b32139bc343f.sql
    20250820204840_d1dda474-a8ac-47ee-95ba-45f53c5eec43.sql
    20250820213436_750847ba-049f-446b-9257-bf22594de8c5.sql
    20250820214206_ace36894-d0b7-4bc8-812b-b5e49182dda2.sql
    20250820215548_2a3bbca0-8d86-4a4d-9acd-3de24a7de323.sql
    20250820221757_54167868-ccdf-4af3-9d35-852f4f924609.sql
    20250820222419_b0aa158b-aeae-4e7a-a23f-93fbb48228fa.sql
    20250821155827_62f27a8a-a0fd-4b06-9afc-41a70479ad3d.sql
    20250821155854_df5fb83c-53a1-4458-8dbf-615ffaa26290.sql
    20250821162427_00f91255-07e4-4d4d-9f76-8e9d17b10fd3.sql
    20250821163219_4a7fe2ac-937d-4e0c-8a68-beaff97042db.sql
    20250821163803_e74a7d6e-edef-4bc4-9107-b3fae0a09f23.sql
    20250821164618_437eb3bf-e90c-49ac-9bdb-9e73bef65e62.sql
    20250821230621_1cdadd8a-a24a-47bd-afde-371a2d6d6a9a.sql
    20250821232048_8a423d55-54b5-4c0d-9144-49e6c2e969b6.sql
    20250821233305_54e25c5b-59f7-48a5-b41b-fa4898c8691a.sql
    20250822171203_e481d447-2aa6-491e-96a9-7f589ee9c90f.sql
    20250825201738_4ca79031-76eb-497e-ab51-adf47af569cb.sql
    20250825202621_76de8da2-accd-4534-a274-206358f25bb3.sql
    20250825205903_a75f4036-91aa-411b-a413-fefe3d83ed92.sql
    20250825210748_9cf401f9-abac-44f6-a425-6b1956e3cef7.sql
    20250826181228_b96cacdb-7b6a-40d5-a510-f17d409ecdb4.sql
    20250826181939_1eae008f-2a79-4850-ad67-510f3f557c07.sql
    20250901155735_3da38357-11a0-4c64-a071-dba609f9fe7d.sql
    20250901163414_eef0a8c1-167c-4db8-962c-e9448a33e4e1.sql
    20250901202326_f08dcc74-3d25-497f-8385-61050ea69456.sql
    20250901202422_9b68a344-a551-40ad-96fe-f4d1b2753c71.sql
    20250901202447_01bef7cc-02cf-44c0-8680-d2238716462e.sql
    20250901204710_654caf4b-19b5-4082-a1e1-45cbb88980b8.sql
    20250901205157_10d4a94d-e333-4ba8-a9cf-6394e2efee91.sql
    20250901205451_7d04a1b7-725e-40b0-9406-07005a8c276c.sql
    20250904202847_50693ef3-1a7d-4dcb-9e51-ba3fb4beef2b.sql
    20250913211106_e230427a-c0cd-44ec-832e-9572b31b50f1.sql
    20251030155806_create_story_insights_snapshots.sql
    20251030160000_add_story_insights_cron.sql
    20251202215835_add_story_insights_columns.sql
  config.toml
.env.example
.gitignore
complete-typescript-fixes.ts
components.json
eslint.config.js
index.html
META_APP_REVIEW_GUIDE.md
package.json
postcss.config.js
README.md
STORY_INSIGHTS_IMPLEMENTATION.md
tailwind.config.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vercel.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="n8n-workflows/01-auth-user-registration.json">
{
  "name": "EVA - Auth User Registration",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "auth-user-registration",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-node",
      "name": "Webhook User Registration",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "auth-user-registration"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "validation-check",
              "leftValue": "={{ $json.email }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "isNotEmpty"
              }
            },
            {
              "id": "password-check", 
              "leftValue": "={{ $json.password }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "isNotEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "url": "https://awpfslcepylnipaolmvv.supabase.co/functions/v1/handle-user-registration",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization", 
              "value": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF3cGZzbGNlcHlsbmlwYW9sbXZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3NTUzOTUsImV4cCI6MjA2OTMzMTM5NX0.KyXrezLFMXhsOr3zyrNm1nb1T3w6C6R3WdJZ2w21oOY"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "email",
              "value": "={{ $json.email }}"
            },
            {
              "name": "password", 
              "value": "={{ $json.password }}"
            },
            {
              "name": "name",
              "value": "={{ $json.name }}"
            },
            {
              "name": "organizationName",
              "value": "={{ $json.organizationName }}"
            }
          ]
        },
        "options": {}
      },
      "id": "call-supabase-function",
      "name": "Call Supabase Function",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 240]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": true, \"message\": \"Usuario registrado exitosamente\", \"data\": $json } }}",
        "options": {}
      },
      "id": "success-response",
      "name": "Success Response", 
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [900, 240]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": false, \"message\": \"Datos de entrada inv√°lidos\", \"errors\": [\"Email y contrase√±a son requeridos\"] } }}",
        "options": {}
      },
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook", 
      "typeVersion": 1,
      "position": [680, 360]
    }
  ],
  "connections": {
    "Webhook User Registration": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Call Supabase Function", 
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Response",
            "type": "main", 
            "index": 0
          }
        ]
      ]
    },
    "Call Supabase Function": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": ["eva", "auth", "registration"],
  "triggerCount": 0,
  "updatedAt": "2024-01-15T10:00:00.000Z",
  "versionId": "1"
}
</file>

<file path="n8n-workflows/02-event-management.json">
{
  "name": "EVA - Event Management",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "event-management",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-event",
      "name": "Webhook Event Management",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "event-management"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "action-check",
              "leftValue": "={{ $json.action }}",
              "rightValue": "create",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-action-create",
      "name": "Check Action Create",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [460, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "action-check",
              "leftValue": "={{ $json.action }}",
              "rightValue": "update",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-action-update",
      "name": "Check Action Update",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [460, 400]
    },
    {
      "parameters": {
        "url": "https://awpfslcepylnipaolmvv.supabase.co/functions/v1/create-event",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF3cGZzbGNlcHlsbmlwYW9sbXZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3NTUzOTUsImV4cCI6MjA2OTMzMTM5NX0.KyXrezLFMXhsOr3zyrNm1nb1T3w6C6R3WdJZ2w21oOY"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "eventData",
              "value": "={{ $json }}"
            }
          ]
        },
        "options": {}
      },
      "id": "create-event",
      "name": "Create Event",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 200]
    },
    {
      "parameters": {
        "url": "https://awpfslcepylnipaolmvv.supabase.co/functions/v1/update-event",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF3cGZzbGNlcHlsbmlwYW9sbXZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3NTUzOTUsImV4cCI6MjA2OTMzMTM5NX0.KyXrezLFMXhsOr3zyrNm1nb1T3w6C6R3WdJZ2w21oOY"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "eventData",
              "value": "={{ $json }}"
            }
          ]
        },
        "options": {}
      },
      "id": "update-event",
      "name": "Update Event",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": true, \"message\": \"Evento procesado exitosamente\", \"data\": $json } }}",
        "options": {}
      },
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [900, 300]
    }
  ],
  "connections": {
    "Webhook Event Management": {
      "main": [
        [
          {
            "node": "Check Action Create",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Action Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Action Create": {
      "main": [
        [
          {
            "node": "Create Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Action Update": {
      "main": [
        [
          {
            "node": "Update Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Event": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Event": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": ["eva", "events", "management"],
  "triggerCount": 0,
  "updatedAt": "2024-01-15T10:00:00.000Z",
  "versionId": "1"
}
</file>

<file path="n8n-workflows/03-ambassador-management.json">
{
  "name": "EVA - Ambassador Management",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ambassador-management",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-ambassador",
      "name": "Webhook Ambassador Management",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "ambassador-management"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "action-check",
              "leftValue": "={{ $json.action }}",
              "rightValue": "create",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-action-create",
      "name": "Check Action Create",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [460, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "action-check",
              "leftValue": "={{ $json.action }}",
              "rightValue": "import",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-action-import",
      "name": "Check Action Import",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "action-check",
              "leftValue": "={{ $json.action }}",
              "rightValue": "approve",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-action-approve",
      "name": "Check Action Approve",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [460, 400]
    },
    {
      "parameters": {
        "url": "https://awpfslcepylnipaolmvv.supabase.co/functions/v1/create-ambassador",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF3cGZzbGNlcHlsbmlwYW9sbXZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3NTUzOTUsImV4cCI6MjA2OTMzMTM5NX0.KyXrezLFMXhsOr3zyrNm1nb1T3w6C6R3WdJZ2w21oOY"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "ambassadorData",
              "value": "={{ $json }}"
            }
          ]
        },
        "options": {}
      },
      "id": "create-ambassador",
      "name": "Create Ambassador",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 200]
    },
    {
      "parameters": {
        "url": "https://awpfslcepylnipaolmvv.supabase.co/functions/v1/import-ambassadors",
        "authentication": "predefinedCredentialType", 
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF3cGZzbGNlcHlsbmlwYW9sbXZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3NTUzOTUsImV4cCI6MjA2OTMzMTM5NX0.KyXrezLFMXhsOr3zyrNm1nb1T3w6C6R3WdJZ2w21oOY"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "ambassadors",
              "value": "={{ $json.ambassadors }}"
            },
            {
              "name": "organizationId",
              "value": "={{ $json.organizationId }}"
            }
          ]
        },
        "options": {}
      },
      "id": "import-ambassadors",
      "name": "Import Ambassadors",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "url": "https://awpfslcepylnipaolmvv.supabase.co/functions/v1/approve-ambassador",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF3cGZzbGNlcHlsbmlwYW9sbXZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3NTUzOTUsImV4cCI6MjA2OTMzMTM5NX0.KyXrezLFMXhsOr3zyrNm1nb1T3w6C6R3WdJZ2w21oOY"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "ambassadorId",
              "value": "={{ $json.ambassadorId }}"
            },
            {
              "name": "status",
              "value": "={{ $json.status }}"
            }
          ]
        },
        "options": {}
      },
      "id": "approve-ambassador",
      "name": "Approve Ambassador",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": true, \"message\": \"Embajador procesado exitosamente\", \"data\": $json } }}",
        "options": {}
      },
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [900, 300]
    }
  ],
  "connections": {
    "Webhook Ambassador Management": {
      "main": [
        [
          {
            "node": "Check Action Create",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Action Import",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Action Approve",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Action Create": {
      "main": [
        [
          {
            "node": "Create Ambassador",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Action Import": {
      "main": [
        [
          {
            "node": "Import Ambassadors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Action Approve": {
      "main": [
        [
          {
            "node": "Approve Ambassador",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Ambassador": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Import Ambassadors": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Approve Ambassador": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": ["eva", "ambassadors", "management"],
  "triggerCount": 0,
  "updatedAt": "2024-01-15T10:00:00.000Z",
  "versionId": "1"
}
</file>

<file path="public/placeholder.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="1200" fill="none"><rect width="1200" height="1200" fill="#EAEAEA" rx="3"/><g opacity=".5"><g opacity=".5"><path fill="#FAFAFA" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/></g><path stroke="url(#a)" stroke-width="2.418" d="M0-1.209h553.581" transform="scale(1 -1) rotate(45 1163.11 91.165)"/><path stroke="url(#b)" stroke-width="2.418" d="M404.846 598.671h391.726"/><path stroke="url(#c)" stroke-width="2.418" d="M599.5 795.742V404.017"/><path stroke="url(#d)" stroke-width="2.418" d="m795.717 796.597-391.441-391.44"/><path fill="#fff" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/><g clip-path="url(#e)"><path fill="#666" fill-rule="evenodd" d="M616.426 586.58h-31.434v16.176l3.553-3.554.531-.531h9.068l.074-.074 8.463-8.463h2.565l7.18 7.181V586.58Zm-15.715 14.654 3.698 3.699 1.283 1.282-2.565 2.565-1.282-1.283-5.2-5.199h-6.066l-5.514 5.514-.073.073v2.876a2.418 2.418 0 0 0 2.418 2.418h26.598a2.418 2.418 0 0 0 2.418-2.418v-8.317l-8.463-8.463-7.181 7.181-.071.072Zm-19.347 5.442v4.085a6.045 6.045 0 0 0 6.046 6.045h26.598a6.044 6.044 0 0 0 6.045-6.045v-7.108l1.356-1.355-1.282-1.283-.074-.073v-17.989h-38.689v23.43l-.146.146.146.147Z" clip-rule="evenodd"/></g><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/></g><defs><linearGradient id="a" x1="554.061" x2="-.48" y1=".083" y2=".087" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="b" x1="796.912" x2="404.507" y1="599.963" y2="599.965" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="c" x1="600.792" x2="600.794" y1="403.677" y2="796.082" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="d" x1="404.85" x2="796.972" y1="403.903" y2="796.02" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><clipPath id="e"><path fill="#fff" d="M581.364 580.535h38.689v38.689h-38.689z"/></clipPath></defs></svg>
</file>

<file path="public/robots.txt">
User-agent: Googlebot
Allow: /

User-agent: Bingbot
Allow: /

User-agent: Twitterbot
Allow: /

User-agent: facebookexternalhit
Allow: /

User-agent: *
Allow: /
</file>

<file path="scripts/MOCK_DATA_README.md">
# Mock Instagram Data for Testing

Este directorio contiene scripts para crear datos mock de Instagram (usuarios/stories) para probar el sistema de Story Insights Cron.

## Scripts Disponibles

### `mock-instagram-data.ts` (Recomendado)
Script TypeScript que crea datos directamente en la base de datos usando el cliente de Supabase.

**Uso:**
```bash
# Crear organizaci√≥n, token y stories de prueba
npx tsx scripts/mock-instagram-data.ts create

# Solo crear stories para una organizaci√≥n existente
npx tsx scripts/mock-instagram-data.ts stories <org_id>

# Listar organizaciones con Instagram configurado
npx tsx scripts/mock-instagram-data.ts list

# Limpiar datos de prueba
npx tsx scripts/mock-instagram-data.ts cleanup
```

### `mock-instagram-data.sh`
Script bash que genera SQL para ejecutar manualmente. √ötil si prefieres ejecutar SQL directamente.

## Configuraci√≥n

1. **Variables de entorno requeridas:**
   ```bash
   export SUPABASE_SERVICE_ROLE_KEY="tu-service-role-key"
   export SUPABASE_URL="https://tu-proyecto.supabase.co"  # Opcional, tiene default
   ```

2. **Cargar desde .env:**
   El script autom√°ticamente carga variables desde `.env` en la ra√≠z del proyecto si existe.

## Qu√© Crea el Script

### 1. Organizaci√≥n de Prueba
- Nombre: `Test Organization <timestamp>`
- Instagram Business Account ID: `17841405309217644` (mock)
- Instagram Username: `test_org_instagram`

### 2. Token de Instagram
- Token mock (plain text): `mock_instagram_token_<timestamp>`
- Expiraci√≥n: 60 d√≠as desde la creaci√≥n
- **Nota:** Este token no funcionar√° con la API real de Instagram, pero permite probar el flujo de datos.

### 3. Stories de Prueba
Crea 7 stories con diferentes edades para probar el sistema de snapshots:

| Edad | Username | ¬øCrea Snapshot? | Nota |
|------|----------|-----------------|------|
| 1h   | test_user_1h | ‚úÖ S√≠ | Dentro de la ventana de snapshot (1h ¬±30min) |
| 2h   | test_user_2h | ‚ùå No | Fuera de las ventanas de snapshot |
| 4h   | test_user_4h | ‚úÖ S√≠ | Dentro de la ventana de snapshot (4h ¬±30min) |
| 8h   | test_user_8h | ‚úÖ S√≠ | Dentro de la ventana de snapshot (8h ¬±30min) |
| 12h  | test_user_12h | ‚úÖ S√≠ | Dentro de la ventana de snapshot (12h ¬±30min) |
| 20h  | test_user_20h | ‚úÖ S√≠ | Dentro de la ventana de snapshot (20h ¬±30min) |
| 23h  | test_user_23h | ‚úÖ S√≠ | Dentro de la ventana de snapshot (23h ¬±30min) |

**Ventanas de snapshot:** El cron toma snapshots a las 1h, 4h, 8h, 12h, 20h, y 23h con una ventana de ¬±30 minutos.

## Flujo de Testing

### Paso 1: Crear Datos Mock
```bash
npx tsx scripts/mock-instagram-data.ts create
```

Esto crea:
- ‚úÖ Organizaci√≥n con Instagram configurado
- ‚úÖ Token de Instagram (mock)
- ‚úÖ 7 Stories con diferentes edades

### Paso 2: Ejecutar el Cron Manualmente
```bash
npx tsx scripts/test-story-insights-cron.ts cron
```

**Nota importante:** Como los tokens son mock, las llamadas a la API de Instagram fallar√°n. Esto es esperado. El cron:
- ‚úÖ Encontrar√° las stories en la base de datos
- ‚úÖ Intentar√° obtener insights de Instagram (fallar√° con token mock)
- ‚úÖ Continuar√° procesando otras stories

### Paso 3: Verificar Resultados

**Opci√≥n A: Verificar en la base de datos**
```sql
-- Ver stories creadas
SELECT id, instagram_story_id, mentioned_at, state 
FROM social_mentions 
WHERE instagram_story_id LIKE 'mock_story_%'
ORDER BY mentioned_at DESC;

-- Ver snapshots creados (si hay alguno)
SELECT * FROM story_insights_snapshots 
WHERE instagram_story_id LIKE 'mock_story_%'
ORDER BY snapshot_at DESC;
```

**Opci√≥n B: Usar el script de verificaci√≥n**
```bash
npx tsx scripts/test-story-insights-cron.ts data
```

### Paso 4: Limpiar Datos
```bash
npx tsx scripts/mock-instagram-data.ts cleanup
```

Esto elimina las stories mock. Los tokens y organizaciones deben eliminarse manualmente si lo deseas.

## Limitaciones con Tokens Mock

### ‚ùå Lo que NO funcionar√°:
- Llamadas reales a la API de Instagram
- Obtenci√≥n de insights reales de stories
- Snapshots con datos reales de m√©tricas

### ‚úÖ Lo que S√ç funcionar√°:
- Detecci√≥n de stories en la base de datos
- C√°lculo de edad de stories
- L√≥gica de cu√°ndo tomar snapshots
- Procesamiento del flujo completo (aunque falle en la API)

## Testing con Datos Reales

Para testing completo con datos reales:

1. **Usa un token real de Instagram:**
   ```sql
   UPDATE organization_instagram_tokens 
   SET access_token = '<token_real_encriptado>'
   WHERE organization_id = '<org_id>';
   ```

2. **O crea stories reales:**
   - Conecta una cuenta real de Instagram
   - Crea stories reales que mencionen tu organizaci√≥n
   - El webhook de Instagram las detectar√° autom√°ticamente

## Troubleshooting

### Error: "SUPABASE_SERVICE_ROLE_KEY requerida"
```bash
export SUPABASE_SERVICE_ROLE_KEY="tu-key"
```

### Error: "violates check constraint" al crear stories
Si recibes un error sobre el constraint de `mention_type`, verifica que `'story_referral'` est√© permitido:

```sql
-- Ver constraint actual
SELECT conname, pg_get_constraintdef(oid) 
FROM pg_constraint 
WHERE conrelid = 'social_mentions'::regclass 
AND conname LIKE '%mention_type%';

-- Si falta 'story_referral', actualiza el constraint:
ALTER TABLE public.social_mentions 
DROP CONSTRAINT IF EXISTS social_mentions_mention_type_check;

ALTER TABLE public.social_mentions 
ADD CONSTRAINT social_mentions_mention_type_check 
CHECK (mention_type IN ('mention', 'tag', 'hashtag', 'story', 'comment', 'story_referral'));
```

### Error: "No se encontraron organizaciones"
Ejecuta `create` primero:
```bash
npx tsx scripts/mock-instagram-data.ts create
```

### Las stories no aparecen en el cron
Verifica que:
- El `mention_type` sea `'story_referral'`
- El `state` sea `'new'` o `'flagged_early_delete'`
- El `mentioned_at` sea menor a 24 horas

### No se crean snapshots
Recuerda que los snapshots solo se crean cuando:
- La edad de la story est√° dentro de una ventana de snapshot (1h, 4h, 8h, 12h, 20h, 23h ¬±30min)
- La API de Instagram devuelve insights (fallar√° con tokens mock)

## Pr√≥ximos Pasos

Para testing m√°s completo, considera:
1. **Mockear respuestas de la API de Instagram** - Interceptar llamadas y devolver datos mock
2. **Usar tokens reales en ambiente de desarrollo** - Para testing end-to-end
3. **Crear un ambiente de testing aislado** - Base de datos separada para tests
</file>

<file path="scripts/mock-instagram-data.ts">
/**
 * Script para crear datos mock de Instagram (usuarios/stories) para testing
 * Uso: npx tsx scripts/mock-instagram-data.ts [comando]
 * 
 * Comandos:
 *   - create: Crea organizaci√≥n, token y stories de prueba
 *   - stories: Solo crea stories de prueba (requiere org_id)
 *   - cleanup: Elimina datos de prueba
 *   - list: Lista organizaciones de prueba
 */

import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

// Cargar variables de entorno desde .env si existe
function loadEnvFile() {
  try {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const projectRoot = join(__dirname, '..');
    const envPath = join(projectRoot, '.env');
    
    const envContent = readFileSync(envPath, 'utf-8');
    const lines = envContent.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      // Ignorar comentarios y l√≠neas vac√≠as
      if (!trimmed || trimmed.startsWith('#')) continue;
      
      const match = trimmed.match(/^([^=]+)=(.*)$/);
      if (match) {
        const key = match[1].trim();
        let value = match[2].trim();
        
        // Remover comillas si est√°n presentes
        if ((value.startsWith('"') && value.endsWith('"')) || 
            (value.startsWith("'") && value.endsWith("'"))) {
          value = value.slice(1, -1);
        }
        
        // Solo establecer si no est√° ya definida (las variables de entorno tienen prioridad)
        if (!process.env[key]) {
          process.env[key] = value;
        }
      }
    }
  } catch (error) {
    // .env no existe o no se puede leer, continuar sin √©l
  }
}

// Cargar .env al inicio
loadEnvFile();

// Log si se carg√≥ .env (solo para debugging)
if (process.env.SUPABASE_SERVICE_ROLE_KEY) {
  // Variable encontrada, probablemente desde .env
}

const SUPABASE_URL = process.env.SUPABASE_URL || 'https://awpfslcepylnipaolmvv.supabase.co';

// Colores para console
const colors = {
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  blue: '\x1b[34m',
  reset: '\x1b[0m',
};

function log(message: string, color: keyof typeof colors = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

// Verificar variables de entorno
function checkEnv() {
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!serviceRoleKey) {
    log('‚ùå SUPABASE_SERVICE_ROLE_KEY requerida', 'red');
    log('', 'reset');
    log('Opciones:', 'yellow');
    log('1. Agrega SUPABASE_SERVICE_ROLE_KEY a tu archivo .env en la ra√≠z del proyecto', 'yellow');
    log('2. O ejecuta: export SUPABASE_SERVICE_ROLE_KEY="tu-key"', 'yellow');
    log('', 'reset');
    log('El script intent√≥ cargar desde .env pero no encontr√≥ la variable.', 'blue');
    process.exit(1);
  }
  return serviceRoleKey;
}

// Obtener o crear un usuario de prueba
async function getOrCreateTestUser(supabase: SupabaseClient): Promise<string | null> {
  // Intentar encontrar un usuario existente
  const { data: existingUsers } = await supabase
    .from('users')
    .select('auth_user_id')
    .limit(1)
    .single();
  
  if (existingUsers?.auth_user_id) {
    return existingUsers.auth_user_id;
  }
  
  // Si no hay usuarios, intentar obtener uno de auth.users directamente
  // Nota: Esto requiere permisos de service_role
  try {
    const { data: authUsers } = await supabase.auth.admin.listUsers();
    if (authUsers?.users && authUsers.users.length > 0) {
      return authUsers.users[0].id;
    }
  } catch (error) {
    // Si no podemos acceder a auth.users, continuamos sin usuario
    log('‚ö†Ô∏è  No se pudo acceder a auth.users. Creando organizaci√≥n sin usuario.', 'yellow');
  }
  
  return null;
}

// Crear organizaci√≥n de prueba
async function createTestOrganization(supabase: SupabaseClient) {
  log('=== Creando Organizaci√≥n de Prueba ===', 'green');
  
  const orgName = `Test Organization ${Date.now()}`;
  const instagramBusinessAccountId = '17841405309217644'; // Mock Instagram Business Account ID
  const instagramUsername = 'test_org_instagram';
  const instagramUserId = '17841405309217644';
  
  // Intentar obtener un usuario existente
  const userId = await getOrCreateTestUser(supabase);
  
  if (!userId) {
    log('‚ö†Ô∏è  No se encontr√≥ usuario. Creando organizaci√≥n sin created_by...', 'yellow');
    log('   Esto puede fallar si hay triggers que requieren user_id.', 'yellow');
  }
  
  // Primero verificar si ya existe una organizaci√≥n con este Instagram Business Account ID
  const { data: existing } = await supabase
    .from('organizations')
    .select('id, name, instagram_business_account_id')
    .eq('instagram_business_account_id', instagramBusinessAccountId)
    .maybeSingle();
  
  if (existing) {
    log(`‚úÖ Organizaci√≥n ya existe: ${existing.name} (${existing.id})`, 'green');
    return existing;
  }
  
  // Crear la organizaci√≥n
  const orgData: {
    name: string;
    instagram_business_account_id: string;
    instagram_username: string;
    instagram_user_id: string;
    created_by?: string;
  } = {
    name: orgName,
    instagram_business_account_id: instagramBusinessAccountId,
    instagram_username: instagramUsername,
    instagram_user_id: instagramUserId,
  };
  
  // Solo agregar created_by si tenemos un userId
  if (userId) {
    orgData.created_by = userId;
  }
  
  const { data: org, error } = await supabase
    .from('organizations')
    .insert(orgData)
    .select('id, name, instagram_business_account_id')
    .single();
  
  if (error) {
    // Si el error es por el trigger de organization_members, intentar crear manualmente
    if (error.message?.includes('organization_members') || error.message?.includes('user_id')) {
      log('‚ö†Ô∏è  Error por trigger de organization_members. Intentando workaround...', 'yellow');
      
      // Intentar crear la organizaci√≥n sin el trigger usando RPC o SQL directo
      // Por ahora, sugerimos usar un usuario existente
      log('üí° Soluci√≥n: Necesitas un usuario existente para crear organizaciones.', 'blue');
      log('   Opciones:', 'blue');
      log('   1. Crea un usuario manualmente en Supabase Dashboard', 'yellow');
      log('   2. O usa una organizaci√≥n existente con: npx tsx scripts/mock-instagram-data.ts list', 'yellow');
      log('   3. Luego crea solo stories: npx tsx scripts/mock-instagram-data.ts stories <org_id>', 'yellow');
      throw new Error('Se requiere un usuario para crear organizaciones. Usa una organizaci√≥n existente o crea un usuario primero.');
    }
    
    log(`‚ùå Error creando organizaci√≥n: ${error.message}`, 'red');
    throw error;
  }
  
  // Si la organizaci√≥n se cre√≥ sin created_by, necesitamos crear el organization_members manualmente
  // Pero esto requiere un user_id v√°lido, as√≠ que si no tenemos uno, no podemos hacerlo
  if (!userId && org) {
    log('‚ö†Ô∏è  Organizaci√≥n creada sin usuario. Algunas funcionalidades pueden no funcionar.', 'yellow');
  }
  
  log(`‚úÖ Organizaci√≥n creada: ${org.name} (${org.id})`, 'green');
  return org;
}

// Crear token de Instagram de prueba
async function createTestToken(
  supabase: SupabaseClient,
  orgId: string
) {
  log('=== Creando Token de Instagram de Prueba ===', 'green');
  
  // Token de prueba (plain text, ser√° manejado por safeDecryptToken)
  const mockToken = `mock_instagram_token_${Date.now()}`;
  const expiryDate = new Date();
  expiryDate.setDate(expiryDate.getDate() + 60); // 60 d√≠as desde ahora
  
  const { data: token, error } = await supabase
    .from('organization_instagram_tokens')
    .upsert({
      organization_id: orgId,
      access_token: mockToken, // Plain text para testing
      token_expiry: expiryDate.toISOString(),
    }, {
      onConflict: 'organization_id'
    })
    .select('id, organization_id, token_expiry')
    .single();
  
  if (error) {
    log(`‚ùå Error creando token: ${error.message}`, 'red');
    throw error;
  }
  
  log(`‚úÖ Token creado para organizaci√≥n ${orgId}`, 'green');
  log(`   Expira: ${token.token_expiry}`, 'blue');
  return token;
}

// Verificar si el constraint incluye 'story_referral' intentando un insert de prueba
async function checkStoryReferralConstraint(supabase: SupabaseClient, orgId: string): Promise<boolean> {
  try {
    // Intentar insertar un registro de prueba con 'story_referral'
    // Si falla, el constraint no lo permite
    const testStory = {
      organization_id: orgId,
      instagram_user_id: 'test_check',
      instagram_username: 'test_check',
      mention_type: 'story_referral',
      instagram_story_id: 'test_check_constraint',
      mentioned_at: new Date().toISOString(),
      state: 'new',
      platform: 'instagram',
    };
    
    const { error } = await supabase
      .from('social_mentions')
      .insert(testStory);
    
    if (error) {
      // Si el error es por el constraint, no est√° permitido
      if (error.message?.includes('mention_type_check') || error.message?.includes('check constraint')) {
        // Limpiar el registro de prueba si se insert√≥ (no deber√≠a)
        await supabase
          .from('social_mentions')
          .delete()
          .eq('instagram_story_id', 'test_check_constraint');
        return false;
      }
      // Otro tipo de error, asumimos que el constraint est√° bien
      return true;
    }
    
    // Si se insert√≥ correctamente, limpiar y retornar true
    await supabase
      .from('social_mentions')
      .delete()
      .eq('instagram_story_id', 'test_check_constraint');
    
    return true;
  } catch {
    // Si falla, asumimos que necesita actualizarse
    return false;
  }
}

// Crear stories de prueba con diferentes edades
async function createTestStories(
  supabase: SupabaseClient,
  orgId: string
) {
  log('=== Creando Stories de Prueba ===', 'green');
  
  // Verificar si el constraint incluye 'story_referral'
  log('Verificando constraint de mention_type...', 'blue');
  const hasStoryReferral = await checkStoryReferralConstraint(supabase, orgId);
  
  if (!hasStoryReferral) {
    log('‚ö†Ô∏è  El constraint de mention_type no incluye "story_referral".', 'yellow');
    log('', 'reset');
    log('üí° Soluci√≥n:', 'blue');
    log('   1. Ejecuta la migraci√≥n en Supabase Dashboard SQL Editor:', 'yellow');
    log('', 'reset');
    log('      ALTER TABLE public.social_mentions', 'blue');
    log('      DROP CONSTRAINT IF EXISTS social_mentions_mention_type_check;', 'blue');
    log('', 'reset');
    log('      ALTER TABLE public.social_mentions', 'blue');
    log('      ADD CONSTRAINT social_mentions_mention_type_check', 'blue');
    log("      CHECK (mention_type IN ('mention', 'tag', 'hashtag', 'story', 'comment', 'story_referral'));", 'blue');
    log('', 'reset');
    log('   2. O ejecuta la migraci√≥n con Supabase CLI:', 'yellow');
    log('      supabase migration up', 'blue');
    log('', 'reset');
    log('   3. Luego ejecuta este script nuevamente.', 'yellow');
    log('', 'reset');
    log('   Nota: Tambi√©n hay una migraci√≥n en:', 'blue');
    log('   supabase/migrations/20250101000000_add_story_referral_to_mention_type.sql', 'blue');
    throw new Error('El constraint de mention_type necesita incluir "story_referral". Ejecuta el SQL mostrado arriba.');
  }
  
  log('‚úÖ Constraint verificado (incluye story_referral)', 'green');
  
  const now = new Date();
  const instagramUserId = '17841405309217644';
  
  // Crear stories con diferentes edades para probar el sistema de snapshots
  // Snapshots se toman a: 1h, 4h, 8h, 12h, 20h, 23h (con ventana de ¬±30min)
  
  const storyAges = [
    { hours: 1, username: 'test_user_1h', shouldSnapshot: true },
    { hours: 2, username: 'test_user_2h', shouldSnapshot: false }, // No deber√≠a crear snapshot
    { hours: 4, username: 'test_user_4h', shouldSnapshot: true },
    { hours: 8, username: 'test_user_8h', shouldSnapshot: true },
    { hours: 12, username: 'test_user_12h', shouldSnapshot: true },
    { hours: 20, username: 'test_user_20h', shouldSnapshot: true },
    { hours: 23, username: 'test_user_23h', shouldSnapshot: true },
  ];
  
  const stories = storyAges.map(({ hours, username, shouldSnapshot }) => {
    const mentionedAt = new Date(now.getTime() - hours * 60 * 60 * 1000);
    const storyId = `mock_story_${hours}h_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    return {
      organization_id: orgId,
      instagram_user_id: instagramUserId,
      instagram_username: username,
      mention_type: 'story_referral',
      instagram_story_id: storyId,
      instagram_media_id: `mock_media_${hours}h_${Date.now()}`,
      mentioned_at: mentionedAt.toISOString(),
      state: 'new',
      platform: 'instagram',
      created_at: new Date().toISOString(),
    };
  });
  
  const { data: insertedStories, error } = await supabase
    .from('social_mentions')
    .insert(stories)
    .select('id, instagram_story_id, mentioned_at, state');
  
  if (error) {
    log(`‚ùå Error creando stories: ${error.message}`, 'red');
    throw error;
  }
  
  log(`‚úÖ ${insertedStories.length} stories creadas:`, 'green');
  insertedStories.forEach((story, idx) => {
    const age = storyAges[idx].hours;
    const shouldSnapshot = storyAges[idx].shouldSnapshot;
    const snapshotNote = shouldSnapshot ? '‚úì deber√≠a crear snapshot' : '‚úó no deber√≠a crear snapshot';
    log(`   ${age}h - ${story.instagram_story_id} (${snapshotNote})`, 'blue');
  });
  
  return insertedStories;
}

// Crear todo (organizaci√≥n, token, stories)
async function createAll() {
  checkEnv();
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
  const supabase = createClient(SUPABASE_URL, serviceRoleKey);
  
  try {
    // 1. Crear organizaci√≥n
    const org = await createTestOrganization(supabase);
    console.log('');
    
    // 2. Crear token
    await createTestToken(supabase, org.id);
    console.log('');
    
    // 3. Crear stories
    await createTestStories(supabase, org.id);
    console.log('');
    
    log('=== Resumen ===', 'green');
    log(`‚úÖ Organizaci√≥n: ${org.name} (${org.id})`, 'green');
    log(`‚úÖ Token de Instagram creado`, 'green');
    log(`‚úÖ 7 Stories de prueba creadas con diferentes edades`, 'green');
    log('', 'reset');
    log('Pr√≥ximos pasos:', 'blue');
    log('1. Ejecuta: npx tsx scripts/test-story-insights-cron.ts cron', 'yellow');
    log('2. Verifica los snapshots en: story_insights_snapshots', 'yellow');
    log('3. Para limpiar: npx tsx scripts/mock-instagram-data.ts cleanup', 'yellow');
    
  } catch (error) {
    log(`‚ùå Error: ${error instanceof Error ? error.message : String(error)}`, 'red');
    process.exit(1);
  }
}

// Solo crear stories (requiere org_id)
async function createStoriesOnly() {
  checkEnv();
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
  const supabase = createClient(SUPABASE_URL, serviceRoleKey);
  
  const orgId = process.argv[3];
  if (!orgId) {
    log('‚ùå Se requiere organization_id', 'red');
    log('Uso: npx tsx scripts/mock-instagram-data.ts stories <org_id>', 'yellow');
    log('Obt√©n el ID con: npx tsx scripts/mock-instagram-data.ts list', 'yellow');
    process.exit(1);
  }
  
  try {
    await createTestStories(supabase, orgId);
  } catch (error) {
    log(`‚ùå Error: ${error instanceof Error ? error.message : String(error)}`, 'red');
    process.exit(1);
  }
}

// Listar organizaciones de prueba
async function listOrganizations() {
  checkEnv();
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
  const supabase = createClient(SUPABASE_URL, serviceRoleKey);
  
  try {
    const { data: orgs, error } = await supabase
      .from('organizations')
      .select('id, name, instagram_business_account_id, instagram_username, created_at')
      .not('instagram_business_account_id', 'is', null)
      .order('created_at', { ascending: false })
      .limit(10);
    
    if (error) {
      log(`‚ùå Error: ${error.message}`, 'red');
      return;
    }
    
    if (!orgs || orgs.length === 0) {
      log('No se encontraron organizaciones con Instagram configurado', 'yellow');
      return;
    }
    
    log('=== Organizaciones con Instagram ===', 'green');
    orgs.forEach((org, idx) => {
      log(`\n${idx + 1}. ${org.name}`, 'blue');
      log(`   ID: ${org.id}`, 'yellow');
      log(`   Instagram Business Account: ${org.instagram_business_account_id}`, 'yellow');
      log(`   Username: ${org.instagram_username || 'N/A'}`, 'yellow');
    });
    
  } catch (error) {
    log(`‚ùå Error: ${error instanceof Error ? error.message : String(error)}`, 'red');
  }
}

// Verificar datos creados
async function verifyData() {
  checkEnv();
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
  const supabase = createClient(SUPABASE_URL, serviceRoleKey);
  
  log('=== Verificaci√≥n de Datos Mock ===', 'green');
  
  try {
    // Buscar stories mock
    const { data: stories, error: storiesError } = await supabase
      .from('social_mentions')
      .select('id, instagram_story_id, mentioned_at, state, mention_type')
      .like('instagram_story_id', 'mock_story_%')
      .order('mentioned_at', { ascending: false });
    
    if (storiesError) {
      log(`‚ùå Error consultando stories: ${storiesError.message}`, 'red');
      return;
    }
    
    log(`\nüìä Stories Mock Encontradas: ${stories?.length || 0}`, 'blue');
    
    if (stories && stories.length > 0) {
      stories.forEach((story, idx) => {
        const age = Math.round((Date.now() - new Date(story.mentioned_at).getTime()) / (1000 * 60 * 60));
        log(`\n${idx + 1}. ${story.instagram_story_id}`, 'yellow');
        log(`   Edad: ~${age}h`, 'blue');
        log(`   Estado: ${story.state}`, 'blue');
        log(`   Tipo: ${story.mention_type}`, 'blue');
      });
    } else {
      log('No se encontraron stories mock', 'yellow');
    }
    
    // Buscar snapshots (probablemente no habr√° ninguno porque los tokens son mock)
    const { data: snapshots, error: snapshotsError } = await supabase
      .from('story_insights_snapshots')
      .select('id, instagram_story_id, snapshot_at, story_age_hours, impressions, reach')
      .like('instagram_story_id', 'mock_story_%')
      .order('snapshot_at', { ascending: false });
    
    if (!snapshotsError && snapshots) {
      log(`\nüì∏ Snapshots Creados: ${snapshots.length}`, 'blue');
      if (snapshots.length > 0) {
        snapshots.forEach((snapshot, idx) => {
          log(`\n${idx + 1}. Story: ${snapshot.instagram_story_id}`, 'yellow');
          log(`   Edad al snapshot: ${snapshot.story_age_hours}h`, 'blue');
          log(`   Impressions: ${snapshot.impressions}, Reach: ${snapshot.reach}`, 'blue');
        });
      } else {
        log('   (No hay snapshots - esto es normal con tokens mock)', 'yellow');
        log('   Los snapshots solo se crean cuando la API de Instagram devuelve datos v√°lidos.', 'yellow');
      }
    }
    
    log('\nüí° Nota sobre los errores de token:', 'blue');
    log('   Los errores "Invalid OAuth access token" son ESPERADOS.', 'yellow');
    log('   Esto significa que:', 'yellow');
    log('   ‚úÖ Las stories fueron encontradas por el cron', 'green');
    log('   ‚úÖ El cron intent√≥ obtener insights (fall√≥ con token mock)', 'yellow');
    log('   ‚úÖ Para obtener insights reales, necesitas tokens reales de Instagram', 'blue');
    
  } catch (error) {
    log(`‚ùå Error: ${error instanceof Error ? error.message : String(error)}`, 'red');
  }
}

// Limpiar datos de prueba
async function cleanup() {
  checkEnv();
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
  const supabase = createClient(SUPABASE_URL, serviceRoleKey);
  
  log('=== Limpiando Datos de Prueba ===', 'green');
  
  try {
    // Eliminar stories de prueba (las que empiezan con "mock_story_")
    const { data: stories, error: storiesError } = await supabase
      .from('social_mentions')
      .select('id')
      .like('instagram_story_id', 'mock_story_%');
    
    if (stories && stories.length > 0) {
      const storyIds = stories.map(s => s.id);
      const { error: deleteStoriesError } = await supabase
        .from('social_mentions')
        .delete()
        .in('id', storyIds);
      
      if (deleteStoriesError) {
        log(`‚ö†Ô∏è  Error eliminando stories: ${deleteStoriesError.message}`, 'yellow');
      } else {
        log(`‚úÖ ${stories.length} stories eliminadas`, 'green');
      }
    } else {
      log('No se encontraron stories de prueba', 'yellow');
    }
    
    // Eliminar tokens de prueba (los que empiezan con "mock_instagram_token_")
    // Nota: No podemos filtrar por access_token directamente por RLS, as√≠ que eliminamos todos los tokens
    // de organizaciones de prueba. Mejor hacerlo manualmente o por organizaci√≥n espec√≠fica.
    
    log('\n‚ö†Ô∏è  Para eliminar tokens y organizaciones de prueba, hazlo manualmente:', 'yellow');
    log('   DELETE FROM organization_instagram_tokens WHERE organization_id = \'<org_id>\';', 'blue');
    log('   DELETE FROM organizations WHERE id = \'<org_id>\';', 'blue');
    
  } catch (error) {
    log(`‚ùå Error: ${error instanceof Error ? error.message : String(error)}`, 'red');
  }
}

// Men√∫ principal
async function main() {
  const command = process.argv[2] || 'help';
  
  switch (command) {
    case 'create':
      await createAll();
      break;
    
    case 'stories':
      await createStoriesOnly();
      break;
    
    case 'list':
      await listOrganizations();
      break;
    
    case 'verify':
      await verifyData();
      break;
    
    case 'cleanup':
      await cleanup();
      break;
    
    case 'help':
    default:
      log('Uso: npx tsx scripts/mock-instagram-data.ts [comando]', 'blue');
      log('\nComandos disponibles:', 'blue');
      log('  create   - Crea organizaci√≥n, token y stories de prueba', 'yellow');
      log('  stories  - Solo crea stories de prueba (requiere org_id como argumento)', 'yellow');
      log('  list     - Lista organizaciones con Instagram configurado', 'yellow');
      log('  verify   - Verifica datos mock creados (stories y snapshots)', 'yellow');
      log('  cleanup  - Elimina datos de prueba (stories mock)', 'yellow');
      log('\nVariables de entorno requeridas:', 'blue');
      log('  SUPABASE_SERVICE_ROLE_KEY - Para insertar datos', 'yellow');
      log('\nEjemplos:', 'blue');
      log('  # Crear todo desde cero', 'yellow');
      log('  npx tsx scripts/mock-instagram-data.ts create', 'yellow');
      log('', 'reset');
      log('  # Solo crear stories para una organizaci√≥n existente', 'yellow');
      log('  npx tsx scripts/mock-instagram-data.ts stories <org_id>', 'yellow');
      log('', 'reset');
      log('  # Listar organizaciones', 'yellow');
      log('  npx tsx scripts/mock-instagram-data.ts list', 'yellow');
      break;
  }
}

main().catch(console.error);
</file>

<file path="scripts/test-story-insights-cron.ts">
/**
 * Script de Testing para Story Insights Cron Service
 * Uso: npx tsx scripts/test-story-insights-cron.ts [comando]
 * 
 * Comandos:
 *   - manual: Prueba como usuario autenticado
 *   - cron: Prueba simulando cron job
 *   - verify: Verifica configuraci√≥n del cron
 *   - data: Verifica datos en la base de datos
 *   - all: Ejecuta todas las pruebas
 */

import { createClient } from '@supabase/supabase-js';
import { readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

// Cargar variables de entorno desde .env si existe
function loadEnvFile() {
  try {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const projectRoot = join(__dirname, '..');
    const envPath = join(projectRoot, '.env');
    
    const envContent = readFileSync(envPath, 'utf-8');
    const lines = envContent.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      // Ignorar comentarios y l√≠neas vac√≠as
      if (!trimmed || trimmed.startsWith('#')) continue;
      
      const match = trimmed.match(/^([^=]+)=(.*)$/);
      if (match) {
        const key = match[1].trim();
        let value = match[2].trim();
        
        // Remover comillas si est√°n presentes
        if ((value.startsWith('"') && value.endsWith('"')) || 
            (value.startsWith("'") && value.endsWith("'"))) {
          value = value.slice(1, -1);
        }
        
        // Solo establecer si no est√° ya definida (las variables de entorno tienen prioridad)
        if (!process.env[key]) {
          process.env[key] = value;
        }
      }
    }
  } catch (error) {
    // .env no existe o no se puede leer, continuar sin √©l
  }
}

// Cargar .env al inicio
loadEnvFile();

const SUPABASE_URL = process.env.SUPABASE_URL || 'https://awpfslcepylnipaolmvv.supabase.co';
const FUNCTION_NAME = 'collect-story-insights';

// Colores para console
const colors = {
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  blue: '\x1b[34m',
  reset: '\x1b[0m',
};

function log(message: string, color: keyof typeof colors = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

// Verificar variables de entorno
function checkEnv() {
  const required = {
    'SUPABASE_SERVICE_ROLE_KEY': process.env.SUPABASE_SERVICE_ROLE_KEY,
    'CRON_SECRET': process.env.CRON_SECRET,
  };

  const missing = Object.entries(required)
    .filter(([_, value]) => !value)
    .map(([key]) => key);

  if (missing.length > 0) {
    log(`‚ùå Variables de entorno faltantes: ${missing.join(', ')}`, 'red');
    log('', 'reset');
    log('Opciones:', 'yellow');
    log('1. Agrega las variables a tu archivo .env en la ra√≠z del proyecto:', 'yellow');
    log('   SUPABASE_SERVICE_ROLE_KEY=tu-key', 'blue');
    log('   CRON_SECRET=tu-secret', 'blue');
    log('', 'reset');
    log('2. O ejecuta: export VARIABLE_NAME="valor"', 'yellow');
    log('', 'reset');
    log('El script intent√≥ cargar desde .env pero no encontr√≥ las variables.', 'blue');
    process.exit(1);
  }
}

// Prueba manual como usuario
async function testManualUser() {
  log('=== Prueba Manual (Como Usuario) ===', 'green');
  
  const anonKey = process.env.SUPABASE_ANON_KEY;
  if (!anonKey) {
    log('‚ùå SUPABASE_ANON_KEY requerida para prueba de usuario', 'red');
    log('Obt√©n el token desde tu aplicaci√≥n frontend despu√©s de autenticarte', 'yellow');
    return false;
  }

  try {
    const response = await fetch(`${SUPABASE_URL}/functions/v1/${FUNCTION_NAME}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${anonKey}`,
      },
      body: JSON.stringify({}),
    });

    const data = await response.json();
    
    log(`Status: ${response.status}`, response.ok ? 'green' : 'red');
    log('Response:', 'blue');
    console.log(JSON.stringify(data, null, 2));

    if (response.ok) {
      log('‚úÖ Prueba exitosa', 'green');
      return true;
    } else {
      log('‚ùå Prueba fall√≥', 'red');
      return false;
    }
  } catch (error) {
    log(`‚ùå Error: ${error instanceof Error ? error.message : String(error)}`, 'red');
    return false;
  }
}

// Prueba manual como cron job
async function testManualCron() {
  log('=== Prueba Manual (Como Cron Job) ===', 'green');

  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  const cronSecret = process.env.CRON_SECRET;

  if (!serviceRoleKey || !cronSecret) {
    log('‚ùå SUPABASE_SERVICE_ROLE_KEY y CRON_SECRET requeridos', 'red');
    return false;
  }

  try {
    const response = await fetch(`${SUPABASE_URL}/functions/v1/${FUNCTION_NAME}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${serviceRoleKey}`,
        'x-cron-secret': cronSecret,
      },
      body: JSON.stringify({ source: 'cron' }),
    });

    const data = await response.json();
    
    log(`Status: ${response.status}`, response.ok ? 'green' : 'red');
    log('Response:', 'blue');
    console.log(JSON.stringify(data, null, 2));

    if (response.ok) {
      log('‚úÖ Prueba exitosa', 'green');
      
      // Mostrar estad√≠sticas si est√°n disponibles
      if (data.summary) {
        log('\nüìä Estad√≠sticas:', 'blue');
        console.log(`  Organizaciones procesadas: ${data.summary.organizationsProcessed || data.summary.totalOrganizationsProcessed || 'N/A'}`);
        console.log(`  Stories procesadas: ${data.summary.totalStoriesProcessed || 'N/A'}`);
        console.log(`  Snapshots creados: ${data.summary.totalSnapshotsCreated || 'N/A'}`);
        console.log(`  Errores: ${data.summary.totalErrors || 0}`);
      }

      return true;
    } else {
      log('‚ùå Prueba fall√≥', 'red');
      return false;
    }
  } catch (error) {
    log(`‚ùå Error: ${error instanceof Error ? error.message : String(error)}`, 'red');
    return false;
  }
}

// Verificar configuraci√≥n del cron job
async function verifyCronJob() {
  log('=== Verificaci√≥n del Cron Job ===', 'green');

  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!serviceRoleKey) {
    log('‚ùå SUPABASE_SERVICE_ROLE_KEY requerida', 'red');
    return false;
  }

  try {
    const supabase = createClient(SUPABASE_URL, serviceRoleKey);
    
    const { data, error } = await supabase.rpc('exec_sql', {
      query: `
        SELECT jobid, jobname, schedule, active 
        FROM cron.job 
        WHERE jobname = 'collect-story-insights-every-2h';
      `
    });

    if (error) {
      log('‚ö†Ô∏è  No se pudo verificar con RPC. Ejecuta manualmente en Supabase Dashboard:', 'yellow');
      log(`
        SELECT jobid, jobname, schedule, active 
        FROM cron.job 
        WHERE jobname = 'collect-story-insights-every-2h';
      `, 'blue');
      return false;
    }

    log('Cron Job Configurado:', 'blue');
    console.log(JSON.stringify(data, null, 2));
    return true;
  } catch (error) {
    log('‚ö†Ô∏è  Ejecuta manualmente en Supabase Dashboard SQL Editor:', 'yellow');
    log(`
      SELECT jobid, jobname, schedule, active 
      FROM cron.job 
      WHERE jobname = 'collect-story-insights-every-2h';
    `, 'blue');
    return false;
  }
}

// Verificar datos en la base de datos
async function verifyData() {
  log('=== Verificaci√≥n de Datos ===', 'green');

  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!serviceRoleKey) {
    log('‚ùå SUPABASE_SERVICE_ROLE_KEY requerida', 'red');
    return false;
  }

  try {
    const supabase = createClient(SUPABASE_URL, serviceRoleKey);

    // Total snapshots
    const { data: snapshots, error: snapshotsError } = await supabase
      .from('story_insights_snapshots')
      .select('id', { count: 'exact', head: true });

    // Active stories
    const { data: stories, error: storiesError } = await supabase
      .from('social_mentions')
      .select('id', { count: 'exact', head: true })
      .eq('mention_type', 'story')
      .gt('mentioned_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString());

    // Recent snapshots (last hour)
    const { data: recent, error: recentError } = await supabase
      .from('story_insights_snapshots')
      .select('id', { count: 'exact', head: true })
      .gt('created_at', new Date(Date.now() - 60 * 60 * 1000).toISOString());

    log('\nüìä Datos en Base de Datos:', 'blue');
    console.log(`  Total snapshots: ${snapshots?.length || 0}`);
    console.log(`  Stories activas (<24h): ${stories?.length || 0}`);
    console.log(`  Snapshots recientes (<1h): ${recent?.length || 0}`);

    if (snapshotsError || storiesError || recentError) {
      log('‚ö†Ô∏è  Algunas consultas fallaron. Verifica permisos RLS.', 'yellow');
      return false;
    }

    return true;
  } catch (error) {
    log(`‚ùå Error: ${error instanceof Error ? error.message : String(error)}`, 'red');
    return false;
  }
}

// Ver logs (requiere Supabase CLI)
async function viewLogs() {
  log('=== Ver Logs Recientes ===', 'green');
  log('‚ö†Ô∏è  Esta funci√≥n requiere Supabase CLI', 'yellow');
  log('Ejecuta: supabase functions logs collect-story-insights --limit 20', 'blue');
  log('O ve a: Supabase Dashboard ‚Üí Edge Functions ‚Üí collect-story-insights ‚Üí Logs', 'blue');
}

// Men√∫ principal
async function main() {
  const command = process.argv[2] || 'help';

  switch (command) {
    case 'manual':
    case 'user':
      await testManualUser();
      break;
    
    case 'cron':
      checkEnv();
      await testManualCron();
      break;
    
    case 'verify':
      checkEnv();
      await verifyCronJob();
      break;
    
    case 'data':
      checkEnv();
      await verifyData();
      break;
    
    case 'logs':
      await viewLogs();
      break;
    
    case 'all':
      checkEnv();
      log('\n=== Ejecutando Todas las Pruebas ===\n', 'green');
      await testManualCron();
      console.log('');
      await verifyCronJob();
      console.log('');
      await verifyData();
      break;
    
    case 'help':
    default:
      log('Uso: npx tsx scripts/test-story-insights-cron.ts [comando]', 'blue');
      log('\nComandos disponibles:', 'blue');
      log('  manual, user   - Prueba manual como usuario autenticado', 'yellow');
      log('  cron           - Prueba manual simulando cron job', 'yellow');
      log('  verify         - Verificar configuraci√≥n del cron job', 'yellow');
      log('  logs           - Ver logs recientes de la funci√≥n', 'yellow');
      log('  data           - Verificar datos en la base de datos', 'yellow');
      log('  all            - Ejecutar todas las pruebas', 'yellow');
      log('\nVariables de entorno requeridas:', 'blue');
      log('  SUPABASE_SERVICE_ROLE_KEY - Para pruebas de cron', 'yellow');
      log('  SUPABASE_ANON_KEY         - Para pruebas de usuario', 'yellow');
      log('  CRON_SECRET               - Para autenticaci√≥n de cron', 'yellow');
      log('\nEjemplo:', 'blue');
      log('  export SUPABASE_SERVICE_ROLE_KEY="tu-key"', 'yellow');
      log('  export CRON_SECRET="tu-secret"', 'yellow');
      log('  npx tsx scripts/test-story-insights-cron.ts cron', 'yellow');
      break;
  }
}

main().catch(console.error);
</file>

<file path="src/components/Ambassadors/AmbassadorActivityTimeline.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Clock, CheckCircle, XCircle, AlertCircle } from "lucide-react";

interface ActivityTimelineProps {
  activities: Array<{
    date: string;
    type: string;
    description: string;
    points?: number;
    status?: string;
  }>;
}

export function AmbassadorActivityTimeline({ activities }: ActivityTimelineProps) {
  const getStatusIcon = (status?: string) => {
    switch (status) {
      case 'completed':
        return <CheckCircle className="w-4 h-4 text-green-500" />;
      case 'invalid':
      case 'expired':
        return <XCircle className="w-4 h-4 text-red-500" />;
      case 'pending':
      case 'uploaded':
        return <Clock className="w-4 h-4 text-yellow-500" />;
      case 'in_progress':
        return <AlertCircle className="w-4 h-4 text-blue-500" />;
      default:
        return <Clock className="w-4 h-4 text-gray-500" />;
    }
  };

  const getStatusLabel = (status?: string) => {
    const labels: Record<string, string> = {
      'completed': 'Completada',
      'invalid': 'Inv√°lida',
      'expired': 'Expirada',
      'pending': 'Pendiente',
      'uploaded': 'Subida',
      'in_progress': 'En Progreso'
    };
    return labels[status || ''] || status;
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    const now = new Date();
    const diffDays = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) return 'Hoy';
    if (diffDays === 1) return 'Ayer';
    if (diffDays < 7) return `Hace ${diffDays} d√≠as`;
    return date.toLocaleDateString('es-ES', { 
      day: 'numeric', 
      month: 'short',
      year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
    });
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Timeline de Actividades</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {activities.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              No hay actividades recientes
            </div>
          ) : (
            activities.map((activity, index) => (
              <div key={index} className="flex items-start space-x-3 pb-4 border-b border-border last:border-b-0">
                <div className="flex-shrink-0 mt-0.5">
                  {getStatusIcon(activity.status)}
                </div>
                
                <div className="flex-1 min-w-0">
                  <div className="flex items-center justify-between">
                    <p className="text-sm font-medium text-foreground">
                      {activity.description}
                    </p>
                    <div className="flex items-center space-x-2">
                      {activity.points && activity.points > 0 && (
                        <Badge variant="outline" className="text-xs">
                          +{activity.points} pts
                        </Badge>
                      )}
                      {activity.status && (
                        <Badge 
                          variant={activity.status === 'completed' ? 'default' : 'secondary'}
                          className="text-xs"
                        >
                          {getStatusLabel(activity.status)}
                        </Badge>
                      )}
                    </div>
                  </div>
                  
                  <div className="flex items-center justify-between mt-1">
                    <p className="text-xs text-muted-foreground">
                      {activity.type}
                    </p>
                    <p className="text-xs text-muted-foreground">
                      {formatDate(activity.date)}
                    </p>
                  </div>
                </div>
              </div>
            ))
          )}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Ambassadors/AmbassadorManagement.tsx">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { EnhancedAmbassadorDashboard } from "./EnhancedAmbassadorDashboard";
import { PageHeader } from "@/components/Layout/PageHeader";
import { GlassPanel } from "@/components/Layout/GlassPanel";

interface Ambassador {
  id: string;
  first_name: string;
  last_name: string;
  email?: string; // Optional - only available with manage_ambassadors permission
  instagram_user: string;
  organization_id: string;
  status: string;
  global_points: number;
  global_category: string;
  performance_status: string;
  events_participated: number;
  completed_tasks: number;
  failed_tasks: number;
  follower_count: number;
  created_at: string;
  rut?: string; // Optional - only available with manage_ambassadors permission
  date_of_birth?: string | null; // Optional - only available with manage_ambassadors permission
  profile_picture_url?: string | null; // Optional - only available with manage_ambassadors permission
}

export default function AmbassadorManagement() {
  const [ambassadors, setAmbassadors] = useState<Ambassador[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchAmbassadors();
  }, []);

  const fetchAmbassadors = async () => {
    try {
      // Fetch basic ambassador data (non-sensitive)
      const { data: basicData, error: basicError } = await supabase
        .from('embassadors')
        .select('id, first_name, last_name, instagram_user, instagram_user_id, follower_count, global_points, global_category, performance_status, events_participated, completed_tasks, failed_tasks, organization_id, created_by_user_id, status, profile_public, last_instagram_sync, created_at')
        .neq('status', 'deleted')
        .order('created_at', { ascending: false });

      if (basicError) throw basicError;

       // For each ambassador, try to fetch sensitive data (will only work if user has manage_ambassadors permission)
       const ambassadorsWithSensitiveData = await Promise.all(
         (basicData || []).map(async (ambassador) => {
           try {
             const { data: sensitiveData } = await supabase
               .rpc('get_ambassador_sensitive_data', { ambassador_id: ambassador.id });
             
             // Define interface for sensitive data response
             interface SensitiveData {
               email?: string;
               date_of_birth?: string | null;
               rut?: string;
               profile_picture_url?: string | null;
             }
             
             const sensitive: SensitiveData = sensitiveData?.[0] || {};
             return {
               ...ambassador,
               email: sensitive.email || undefined,
               date_of_birth: sensitive.date_of_birth || null,
               rut: sensitive.rut || undefined,
               profile_picture_url: sensitive.profile_picture_url || null
             };
           } catch {
             // If user doesn't have permission, return without sensitive data
             return {
               ...ambassador,
               email: undefined,
               date_of_birth: null,
               rut: undefined,
               profile_picture_url: null
             };
           }
         })
       );

      setAmbassadors(ambassadorsWithSensitiveData);
    } catch (error) {
      console.error('Error fetching ambassadors:', error);
      toast.error('Error al cargar embajadores');
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="space-y-6">
        <PageHeader title="Embajadores" description="Cargando embajadores..." />
        <GlassPanel className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
            <div className="text-lg text-muted-foreground">Cargando embajadores...</div>
          </div>
        </GlassPanel>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader 
        title="Embajadores" 
        description="Gestiona y monitorea el rendimiento de tus embajadores"
      />
      <EnhancedAmbassadorDashboard 
        ambassadors={ambassadors}
        onRefresh={fetchAmbassadors}
      />
    </div>
  );
}
</file>

<file path="src/components/Ambassadors/AmbassadorPerformanceChart.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, BarChart, Bar } from "recharts";

interface AmbassadorPerformanceChartProps {
  monthlyData: Array<{
    month: string;
    points: number;
    tasks: number;
    reach: number;
  }>;
}

export function AmbassadorPerformanceChart({ monthlyData }: AmbassadorPerformanceChartProps) {
  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
      {/* Points Trend */}
      <Card>
        <CardHeader>
          <CardTitle>Evoluci√≥n de Puntos</CardTitle>
        </CardHeader>
        <CardContent>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={monthlyData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="month" />
              <YAxis />
              <Tooltip 
                formatter={(value) => [value, 'Puntos']}
                labelFormatter={(label) => `Mes: ${label}`}
              />
              <Line 
                type="monotone" 
                dataKey="points" 
                stroke="hsl(var(--primary))" 
                strokeWidth={2}
                dot={{ fill: "hsl(var(--primary))", strokeWidth: 2 }}
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      {/* Tasks & Reach */}
      <Card>
        <CardHeader>
          <CardTitle>Actividad Mensual</CardTitle>
        </CardHeader>
        <CardContent>
          <ResponsiveContainer width="100%" height={300}>
            <BarChart data={monthlyData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="month" />
              <YAxis />
              <Tooltip 
                formatter={(value, name) => [
                  value, 
                  name === 'tasks' ? 'Tareas' : 'Alcance'
                ]}
                labelFormatter={(label) => `Mes: ${label}`}
              />
              <Bar dataKey="tasks" fill="hsl(var(--primary))" name="tasks" />
              <Bar dataKey="reach" fill="hsl(var(--secondary))" name="reach" />
            </BarChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/Ambassadors/AmbassadorRequestsTab.tsx">
import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Users, Check, X, Clock, Instagram, MessageCircle } from "lucide-react";
import { useAmbassadorRequests, AmbassadorRequest } from "@/hooks/useAmbassadorRequests";
import { toast } from "sonner";

interface ApprovalFormData {
  first_name: string;
  last_name: string;
  email: string;
  date_of_birth: string;
  rut: string;
}

export function AmbassadorRequestsTab() {
  const { requests, loading, approveRequest, rejectRequest } = useAmbassadorRequests();
  const [selectedRequest, setSelectedRequest] = useState<AmbassadorRequest | null>(null);
  const [approvalForm, setApprovalForm] = useState<ApprovalFormData>({
    first_name: "",
    last_name: "",
    email: "",
    date_of_birth: "",
    rut: ""
  });
  const [rejectionReason, setRejectionReason] = useState("");
  const [actionLoading, setActionLoading] = useState(false);

  const pendingRequests = requests.filter(r => r.status === 'pending');
  const processedRequests = requests.filter(r => r.status !== 'pending');

  const handleApprove = async () => {
    if (!selectedRequest) return;
    
    if (!approvalForm.first_name.trim() || !approvalForm.last_name.trim() || !approvalForm.email.trim()) {
      toast.error("Nombre, apellido y email son requeridos");
      return;
    }

    setActionLoading(true);
    try {
      await approveRequest(selectedRequest.id, approvalForm);
      setSelectedRequest(null);
      setApprovalForm({ first_name: "", last_name: "", email: "", date_of_birth: "", rut: "" });
    } catch (error) {
      // Error already handled in hook
    } finally {
      setActionLoading(false);
    }
  };

  const handleReject = async (requestId: string) => {
    setActionLoading(true);
    try {
      await rejectRequest(requestId, rejectionReason);
      setRejectionReason("");
    } catch (error) {
      // Error already handled in hook
    } finally {
      setActionLoading(false);
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'pending': return 'bg-yellow-500/10 text-yellow-700 border-yellow-200';
      case 'approved': return 'bg-green-500/10 text-green-700 border-green-200';
      case 'rejected': return 'bg-red-500/10 text-red-700 border-red-200';
      default: return 'bg-gray-500/10 text-gray-700 border-gray-200';
    }
  };

  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'pending': return 'Pendiente';
      case 'approved': return 'Aprobado';
      case 'rejected': return 'Rechazado';
      default: return status;
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="text-center space-y-2">
          <div className="animate-spin h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="text-muted-foreground">Cargando solicitudes...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Pending Requests */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Clock className="h-5 w-5" />
            Solicitudes Pendientes ({pendingRequests.length})
          </CardTitle>
        </CardHeader>
        <CardContent>
          {pendingRequests.length === 0 ? (
            <div className="text-center py-12 text-muted-foreground">
              <Users className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p>No hay solicitudes pendientes</p>
            </div>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {pendingRequests.map((request) => (
                <Card key={request.id} className="border-dashed">
                  <CardContent className="p-4">
                    <div className="flex items-center gap-3 mb-3">
                      <Avatar className="h-12 w-12">
                        <AvatarImage src={request.profile_picture_url} />
                        <AvatarFallback>
                          <Instagram className="h-6 w-6" />
                        </AvatarFallback>
                      </Avatar>
                      <div className="flex-1 min-w-0">
                        <h3 className="font-semibold truncate">@{request.instagram_username}</h3>
                        <p className="text-sm text-muted-foreground">
                          {request.follower_count.toLocaleString()} seguidores
                        </p>
                      </div>
                    </div>
                    
                    <div className="space-y-2 mb-4">
                      <div className="flex items-center gap-2 text-sm">
                        <MessageCircle className="h-4 w-4" />
                        <span>{request.total_mentions} menciones</span>
                      </div>
                      <div className="text-xs text-muted-foreground">
                        √öltima actividad: {new Date(request.last_mention_at).toLocaleDateString()}
                      </div>
                    </div>

                    <div className="flex gap-2">
                      <Dialog>
                        <DialogTrigger asChild>
                          <Button 
                            size="sm" 
                            className="flex-1"
                            onClick={() => setSelectedRequest(request)}
                          >
                            <Check className="h-4 w-4 mr-1" />
                            Aprobar
                          </Button>
                        </DialogTrigger>
                        <DialogContent>
                          <DialogHeader>
                            <DialogTitle>Aprobar Embajador</DialogTitle>
                          </DialogHeader>
                          <div className="space-y-4">
                            <div className="text-sm text-muted-foreground">
                              Completa los datos del embajador @{selectedRequest?.instagram_username}
                            </div>
                            
                            <div className="grid grid-cols-2 gap-4">
                              <div>
                                <Label htmlFor="first_name">Nombre *</Label>
                                <Input
                                  id="first_name"
                                  value={approvalForm.first_name}
                                  onChange={(e) => setApprovalForm({ ...approvalForm, first_name: e.target.value })}
                                  required
                                />
                              </div>
                              <div>
                                <Label htmlFor="last_name">Apellido *</Label>
                                <Input
                                  id="last_name"
                                  value={approvalForm.last_name}
                                  onChange={(e) => setApprovalForm({ ...approvalForm, last_name: e.target.value })}
                                  required
                                />
                              </div>
                            </div>
                            
                            <div>
                              <Label htmlFor="email">Email *</Label>
                              <Input
                                id="email"
                                type="email"
                                value={approvalForm.email}
                                onChange={(e) => setApprovalForm({ ...approvalForm, email: e.target.value })}
                                required
                              />
                            </div>
                            
                            <div className="grid grid-cols-2 gap-4">
                              <div>
                                <Label htmlFor="date_of_birth">Fecha de Nacimiento</Label>
                                <Input
                                  id="date_of_birth"
                                  type="date"
                                  value={approvalForm.date_of_birth}
                                  onChange={(e) => setApprovalForm({ ...approvalForm, date_of_birth: e.target.value })}
                                />
                              </div>
                              <div>
                                <Label htmlFor="rut">RUT</Label>
                                <Input
                                  id="rut"
                                  value={approvalForm.rut}
                                  onChange={(e) => setApprovalForm({ ...approvalForm, rut: e.target.value })}
                                />
                              </div>
                            </div>

                            <div className="flex justify-end gap-2">
                              <Button variant="outline" onClick={() => setSelectedRequest(null)}>
                                Cancelar
                              </Button>
                              <Button onClick={handleApprove} disabled={actionLoading}>
                                {actionLoading ? "Aprobando..." : "Aprobar Embajador"}
                              </Button>
                            </div>
                          </div>
                        </DialogContent>
                      </Dialog>

                      <Dialog>
                        <DialogTrigger asChild>
                          <Button size="sm" variant="outline">
                            <X className="h-4 w-4 mr-1" />
                            Rechazar
                          </Button>
                        </DialogTrigger>
                        <DialogContent>
                          <DialogHeader>
                            <DialogTitle>Rechazar Solicitud</DialogTitle>
                          </DialogHeader>
                          <div className="space-y-4">
                            <div className="text-sm text-muted-foreground">
                              ¬øEst√°s seguro de rechazar la solicitud de @{request.instagram_username}?
                            </div>
                            
                            <div>
                              <Label htmlFor="rejection_reason">Raz√≥n del rechazo (opcional)</Label>
                              <Textarea
                                id="rejection_reason"
                                value={rejectionReason}
                                onChange={(e) => setRejectionReason(e.target.value)}
                                placeholder="Escribe la raz√≥n del rechazo..."
                              />
                            </div>

                            <div className="flex justify-end gap-2">
                              <Button variant="outline">Cancelar</Button>
                              <Button 
                                variant="destructive" 
                                onClick={() => handleReject(request.id)}
                                disabled={actionLoading}
                              >
                                {actionLoading ? "Rechazando..." : "Rechazar"}
                              </Button>
                            </div>
                          </div>
                        </DialogContent>
                      </Dialog>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Processed Requests */}
      {processedRequests.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Users className="h-5 w-5" />
              Solicitudes Procesadas ({processedRequests.length})
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {processedRequests.map((request) => (
                <div key={request.id} className="flex items-center justify-between p-3 border rounded-lg">
                  <div className="flex items-center gap-3">
                    <Avatar className="h-8 w-8">
                      <AvatarImage src={request.profile_picture_url} />
                      <AvatarFallback>
                        <Instagram className="h-4 w-4" />
                      </AvatarFallback>
                    </Avatar>
                    <div>
                      <p className="font-medium">@{request.instagram_username}</p>
                      <p className="text-sm text-muted-foreground">
                        {request.total_mentions} menciones
                      </p>
                    </div>
                  </div>
                  <Badge className={getStatusColor(request.status)}>
                    {getStatusLabel(request.status)}
                  </Badge>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="src/components/Ambassadors/DeleteAmbassadorModal.tsx">
import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { AlertTriangle } from "lucide-react";
import { toast } from "sonner";
import { supabase } from "@/integrations/supabase/client";

interface Ambassador {
  id: string;
  first_name: string;
  last_name: string;
  email?: string; // Optional - only available with manage_ambassadors permission
  instagram_user: string;
}

interface DeleteAmbassadorModalProps {
  isOpen: boolean;
  onClose: () => void;
  ambassador: Ambassador | null;
  onAmbassadorDeleted: () => void;
}

export function DeleteAmbassadorModal({ 
  isOpen, 
  onClose, 
  ambassador, 
  onAmbassadorDeleted 
}: DeleteAmbassadorModalProps) {
  const [loading, setLoading] = useState(false);

  const handleDelete = async () => {
    if (!ambassador) return;

    try {
      setLoading(true);

      // Instead of hard delete, we'll set status to 'deleted' (soft delete)
      const { error } = await supabase
        .from('embassadors')
        .update({ status: 'deleted' })
        .eq('id', ambassador.id);

      if (error) throw error;

      toast.success("Embajador eliminado exitosamente");
      onAmbassadorDeleted();
      onClose();
    } catch (error) {
      console.error('Error deleting ambassador:', error);
      toast.error("Error al eliminar embajador");
    } finally {
      setLoading(false);
    }
  };

  if (!ambassador) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <div className="flex items-center gap-3">
            <div className="p-2 bg-destructive/10 rounded-full">
              <AlertTriangle className="w-5 h-5 text-destructive" />
            </div>
            <div>
              <DialogTitle>Eliminar Embajador</DialogTitle>
              <DialogDescription>
                Esta acci√≥n no se puede deshacer
              </DialogDescription>
            </div>
          </div>
        </DialogHeader>

        <div className="space-y-4">
          <div className="p-4 bg-muted rounded-lg">
            <p className="text-sm text-muted-foreground mb-2">
              Vas a eliminar al siguiente embajador:
            </p>
            <div className="font-medium">
              {ambassador.first_name} {ambassador.last_name}
            </div>
            <div className="text-sm text-muted-foreground">
              @{ambassador.instagram_user}
            </div>
            <div className="text-sm text-muted-foreground">
              {ambassador.email}
            </div>
          </div>

          <div className="p-3 bg-warning/10 border border-warning/20 rounded-lg">
            <p className="text-sm text-warning-foreground">
              <strong>Importante:</strong> Sus tareas e historial permanecer√°n en el sistema para mantener la integridad de los datos de eventos pasados.
            </p>
          </div>

          <div className="flex justify-end space-x-3">
            <Button variant="outline" onClick={onClose} disabled={loading}>
              Cancelar
            </Button>
            <Button 
              variant="destructive" 
              onClick={handleDelete} 
              disabled={loading}
            >
              {loading ? "Eliminando..." : "Eliminar Embajador"}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Ambassadors/EnhancedAmbassadorDashboard.tsx">
import { useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Search, Eye, UserPlus, Upload, Download, Edit, Trash2, Clock } from "lucide-react";
import { AmbassadorMetricsCards } from "./AmbassadorMetricsCards";
import { AmbassadorPerformanceChart } from "./AmbassadorPerformanceChart";
import { AmbassadorActivityTimeline } from "./AmbassadorActivityTimeline";
import { AmbassadorRequestsTab } from "./AmbassadorRequestsTab";
import { useAmbassadorMetrics } from "@/hooks/useAmbassadorMetrics";
import { useAmbassadorRequests } from "@/hooks/useAmbassadorRequests";
import AddAmbassadorModal from "./AddAmbassadorModal";
import { EditAmbassadorModal } from "./EditAmbassadorModal";
import { DeleteAmbassadorModal } from "./DeleteAmbassadorModal";
import { InstagramProfileLink } from "./InstagramProfileLink";

interface Ambassador {
  id: string;
  first_name: string;
  last_name: string;
  email?: string; // Optional - only available with manage_ambassadors permission
  instagram_user: string;
  organization_id: string;
  status: string;
  global_points: number;
  global_category: string;
  performance_status: string;
  events_participated: number;
  completed_tasks: number;
  follower_count: number;
  instagram_access_token?: string;
  last_instagram_sync?: string;
  rut?: string; // Optional - only available with manage_ambassadors permission
  date_of_birth?: string | null; // Optional - only available with manage_ambassadors permission
  profile_picture_url?: string | null; // Optional - only available with manage_ambassadors permission
}

interface EnhancedAmbassadorDashboardProps {
  ambassadors: Ambassador[];
  onRefresh: () => void;
}

export function EnhancedAmbassadorDashboard({ ambassadors, onRefresh }: EnhancedAmbassadorDashboardProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedAmbassadorId, setSelectedAmbassadorId] = useState<string | null>(null);
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [editingAmbassador, setEditingAmbassador] = useState<Ambassador | null>(null);
  const [deletingAmbassador, setDeletingAmbassador] = useState<Ambassador | null>(null);
  
  const { metrics, loading: metricsLoading } = useAmbassadorMetrics(selectedAmbassadorId || undefined);
  const { getPendingCount } = useAmbassadorRequests();

  const pendingRequestsCount = getPendingCount();

  const filteredAmbassadors = ambassadors.filter(ambassador => {
    const searchText = `${ambassador.first_name} ${ambassador.last_name} ${ambassador.email || ''} ${ambassador.instagram_user}`.toLowerCase();
    return searchText.includes(searchTerm.toLowerCase());
  });

  const getCategoryBadge = (category: string) => {
    const styles = {
      'bronze': 'bg-amber-100 text-amber-800',
      'silver': 'bg-gray-100 text-gray-800', 
      'gold': 'bg-yellow-100 text-yellow-800',
      'diamond': 'bg-purple-100 text-purple-800'
    };
    return styles[category as keyof typeof styles] || styles.bronze;
  };

  const getPerformanceBadge = (status: string) => {
    const styles = {
      'cumple': 'bg-green-100 text-green-800',
      'advertencia': 'bg-yellow-100 text-yellow-800',
      'no_cumple': 'bg-red-100 text-red-800',
      'exclusivo': 'bg-purple-100 text-purple-800'
    };
    return styles[status as keyof typeof styles] || styles.cumple;
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">Dashboard de Embajadores</h1>
        <div className="flex gap-2">
          <Button variant="outline">
            <Upload className="w-4 h-4 mr-2" />
            Importar
          </Button>
          <Button variant="outline">
            <Download className="w-4 h-4 mr-2" />
            Exportar
          </Button>
          <Button onClick={() => setIsAddModalOpen(true)}>
            <UserPlus className="w-4 h-4 mr-2" />
            Agregar Embajador
          </Button>
        </div>
      </div>

      {/* Tabs */}
      <Tabs defaultValue="list" className="space-y-6">
        <TabsList className="grid grid-cols-2 w-full max-w-md">
          <TabsTrigger value="list">Embajadores</TabsTrigger>
          <TabsTrigger value="requests" className="relative">
            <Clock className="h-4 w-4 mr-1" />
            Solicitudes
            {pendingRequestsCount > 0 && (
              <Badge variant="destructive" className="ml-1 px-1 min-w-[1.2rem] h-5 text-xs">
                {pendingRequestsCount}
              </Badge>
            )}
          </TabsTrigger>
        </TabsList>

        <TabsContent value="list" className="space-y-6">
          {/* Search Bar */}
          <div className="flex gap-4 items-center">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Buscar embajadores..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-10"
              />
            </div>
          </div>

          {/* Ambassadors Table */}
          <Card>
            <CardContent className="p-0">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Embajador</TableHead>
                    <TableHead>Categor√≠a</TableHead>
                    <TableHead>Performance</TableHead>
                    <TableHead>Puntos</TableHead>
                    <TableHead>Eventos</TableHead>
                    <TableHead>Tareas</TableHead>
                    <TableHead>Seguidores</TableHead>
                    <TableHead>Perfil Instagram</TableHead>
                    <TableHead>Acciones</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {filteredAmbassadors.map((ambassador) => (
                    <TableRow key={ambassador.id}>
                      <TableCell>
                        <div className="flex items-center space-x-3">
                          <Avatar>
                            <AvatarFallback>
                              {ambassador.first_name[0]}{ambassador.last_name[0]}
                            </AvatarFallback>
                          </Avatar>
                          <div>
                            <p className="font-medium">{ambassador.first_name} {ambassador.last_name}</p>
                            <p className="text-sm text-muted-foreground">@{ambassador.instagram_user}</p>
                          </div>
                        </div>
                      </TableCell>
                      <TableCell>
                        <Badge className={getCategoryBadge(ambassador.global_category)}>
                          {ambassador.global_category}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        <Badge className={getPerformanceBadge(ambassador.performance_status)}>
                          {ambassador.performance_status === 'cumple' ? 'Cumple' :
                           ambassador.performance_status === 'advertencia' ? 'Advertencia' :
                           ambassador.performance_status === 'no_cumple' ? 'No Cumple' : 'Exclusivo'}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        <span className="font-semibold">{ambassador.global_points}</span>
                      </TableCell>
                      <TableCell>{ambassador.events_participated}</TableCell>
                      <TableCell>{ambassador.completed_tasks}</TableCell>
                      <TableCell>{ambassador.follower_count.toLocaleString()}</TableCell>
                      <TableCell>
                        <InstagramProfileLink 
                          username={ambassador.instagram_user}
                          followerCount={ambassador.follower_count}
                        />
                      </TableCell>
                      <TableCell>
                        <div className="flex gap-2">
                          <Button 
                            variant="outline" 
                            size="sm"
                            onClick={() => setSelectedAmbassadorId(ambassador.id)}
                          >
                            <Eye className="w-4 h-4" />
                          </Button>
                          <Button 
                            variant="outline" 
                            size="sm"
                            onClick={() => setEditingAmbassador(ambassador)}
                          >
                            <Edit className="w-4 h-4" />
                          </Button>
                          <Button 
                            variant="outline" 
                            size="sm"
                            onClick={() => setDeletingAmbassador(ambassador)}
                          >
                            <Trash2 className="w-4 h-4" />
                          </Button>
                        </div>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="requests">
          <AmbassadorRequestsTab />
        </TabsContent>
      </Tabs>

      {/* Ambassador Detail Modal */}
      <Dialog open={!!selectedAmbassadorId} onOpenChange={(open) => !open && setSelectedAmbassadorId(null)}>
        <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>Dashboard del Embajador</DialogTitle>
          </DialogHeader>
          
          {metricsLoading ? (
            <div className="flex items-center justify-center py-8">
              Cargando m√©tricas...
            </div>
          ) : metrics ? (
            <div className="space-y-6">
              <AmbassadorMetricsCards metrics={metrics} />
              <AmbassadorPerformanceChart monthlyData={metrics.monthly_performance} />
              <AmbassadorActivityTimeline activities={metrics.recent_activities} />
            </div>
          ) : (
            <div className="text-center py-8 text-muted-foreground">
              No se pudieron cargar las m√©tricas
            </div>
          )}
        </DialogContent>
      </Dialog>

      {/* Add Ambassador Modal */}
      <AddAmbassadorModal 
        isOpen={isAddModalOpen}
        onClose={() => setIsAddModalOpen(false)}
        onAmbassadorAdded={onRefresh}
      />

      {/* Edit Ambassador Modal */}
      <EditAmbassadorModal
        isOpen={!!editingAmbassador}
        onClose={() => setEditingAmbassador(null)}
        ambassador={editingAmbassador}
        onAmbassadorUpdated={onRefresh}
      />

      {/* Delete Ambassador Modal */}
      <DeleteAmbassadorModal
        isOpen={!!deletingAmbassador}
        onClose={() => setDeletingAmbassador(null)}
        ambassador={deletingAmbassador}
        onAmbassadorDeleted={onRefresh}
      />
    </div>
  );
}
</file>

<file path="src/components/Ambassadors/InstagramProfileLink.tsx">
import { Instagram, ExternalLink } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";

interface InstagramProfileLinkProps {
  username: string;
  followerCount?: number;
  className?: string;
}

export function InstagramProfileLink({ username, followerCount, className }: InstagramProfileLinkProps) {
  const instagramUrl = `https://instagram.com/${username.replace('@', '')}`;
  
  const handleClick = () => {
    window.open(instagramUrl, '_blank', 'noopener,noreferrer');
  };

  return (
    <div className={className}>
      <Button
        variant="outline"
        size="sm"
        onClick={handleClick}
        className="flex items-center gap-2 h-auto p-2"
      >
        <Instagram className="h-4 w-4 text-pink-600" />
        <div className="flex flex-col items-start">
          <span className="text-sm font-medium">@{username.replace('@', '')}</span>
          {followerCount && (
            <Badge variant="secondary" className="text-xs h-auto py-0 px-1">
              {followerCount.toLocaleString()} seguidores
            </Badge>
          )}
        </div>
        <ExternalLink className="h-3 w-3 text-muted-foreground" />
      </Button>
    </div>
  );
}
</file>

<file path="src/components/Analytics/EnhancedAnalytics.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { 
  Download, 
  TrendingUp, 
  Users, 
  BarChart3, 
  Calendar,
  Target,
  Award,
  Activity,
  HelpCircle,
  Filter
} from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip as RechartsTooltip, ResponsiveContainer, LineChart, Line, PieChart, Pie, Cell } from 'recharts';

interface AnalyticsData {
  summary: {
    total_reach: number;
    total_mentions: number;
    completion_rate: number;
    active_ambassadors: number;
    events_completed: number;
    average_engagement: number;
  };
  performance_distribution: Array<{
    category: string;
    count: number;
    percentage: number;
    color: string;
  }>;
  event_comparison: Array<{
    name: string;
    completed: number;
    pending: number;
    failed: number;
    total_reach: number;
  }>;
  top_ambassadors: Array<{
    id: string;
    name: string;
    instagram_user: string;
    total_points: number;
    events_participated: number;
    category: string;
    completion_rate: number;
    total_reach: number;
  }>;
  trends: Array<{
    date: string;
    reach: number;
    mentions: number;
    engagement: number;
  }>;
}

interface EnhancedAnalyticsProps {
  selectedEventId?: string;
}

export function EnhancedAnalytics({ selectedEventId }: EnhancedAnalyticsProps) {
  const [analyticsData, setAnalyticsData] = useState<AnalyticsData | null>(null);
  const [events, setEvents] = useState<Array<{ id: string; name: string }>>([]);
  const [selectedEvent, setSelectedEvent] = useState<string>("all");
  const [selectedPeriod, setSelectedPeriod] = useState<string>("30d");
  const [loading, setLoading] = useState(true);
  const { toast } = useToast();

  useEffect(() => {
    fetchEvents();
  }, []);

  useEffect(() => {
    if (selectedEventId) {
      setSelectedEvent(selectedEventId);
    }
  }, [selectedEventId]);

  useEffect(() => {
    fetchAnalyticsData();
  }, [selectedEvent, selectedPeriod]);

  const fetchEvents = async () => {
    try {
      const { data, error } = await supabase
        .from('fiestas')
        .select('id, name')
        .order('name', { ascending: true });

      if (error) throw error;
      setEvents(data || []);
    } catch (error) {
      console.error('Error fetching events:', error);
    }
  };

  const fetchAnalyticsData = async () => {
    try {
      // Get user organizations to filter data
      const { data: user } = await supabase.auth.getUser();
      if (!user.user) return;

      const { data: organizations } = await supabase
        .from('organizations')
        .select('id')
        .eq('created_by', user.user.id);

      if (!organizations || organizations.length === 0) {
        setAnalyticsData(null);
        return;
      }

      const orgIds = organizations.map(org => org.id);

      // Fetch real analytics data from Supabase
      const [
        summaryData,
        performanceData, 
        eventData,
        ambassadorsData,
        trendsData
      ] = await Promise.all([
        fetchSummaryMetrics(orgIds),
        fetchPerformanceDistribution(orgIds),
        fetchEventComparison(orgIds),
        fetchTopAmbassadors(orgIds),
        fetchTrends(orgIds)
      ]);

      const realData: AnalyticsData = {
        summary: summaryData,
        performance_distribution: performanceData,
        event_comparison: eventData,
        top_ambassadors: ambassadorsData,
        trends: trendsData
      };

      setAnalyticsData(realData);
    } catch (error) {
      console.error('Error fetching analytics:', error);
      toast({
        title: "Error",
        description: "No se pudieron cargar los datos anal√≠ticos",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const fetchSummaryMetrics = async (orgIds: string[]) => {
    // Get ambassadors count
    const { count: activeAmbassadors } = await supabase
      .from('embassadors')
      .select('*', { count: 'exact', head: true })
      .in('organization_id', orgIds)
      .eq('status', 'active');

    // Get tasks data
    const { data: ambassadors } = await supabase
      .from('embassadors')
      .select('id, completed_tasks, failed_tasks')
      .in('organization_id', orgIds);

    const ambassadorIds = ambassadors?.map(a => a.id) || [];

    const { data: tasks } = await supabase
      .from('tasks')
      .select('reach_count, engagement_score, status')
      .in('embassador_id', ambassadorIds);

    // Get completed fiestas
    const { count: completedEvents } = await supabase
      .from('fiestas')
      .select('*', { count: 'exact', head: true })
      .in('organization_id', orgIds)
      .eq('status', 'completed');

    const totalCompleted = ambassadors?.reduce((sum, amb) => sum + (amb.completed_tasks || 0), 0) || 0;
    const totalFailed = ambassadors?.reduce((sum, amb) => sum + (amb.failed_tasks || 0), 0) || 0;
    const totalTasks = totalCompleted + totalFailed;
    const totalReach = tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;
    const totalEngagement = tasks?.reduce((sum, t) => sum + (t.engagement_score || 0), 0) || 0;

    return {
      total_reach: totalReach,
      total_mentions: totalTasks,
      completion_rate: totalTasks > 0 ? Math.round((totalCompleted / totalTasks) * 100) : 0,
      active_ambassadors: activeAmbassadors || 0,
      events_completed: completedEvents || 0,
      average_engagement: tasks && tasks.length > 0 ? Number((totalEngagement / tasks.length).toFixed(1)) : 0
    };
  };

  const fetchPerformanceDistribution = async (orgIds: string[]) => {
    const { data: ambassadors } = await supabase
      .from('embassadors')
      .select('performance_status')
      .in('organization_id', orgIds)
      .eq('status', 'active');

    const distribution = { cumple: 0, advertencia: 0, no_cumple: 0, exclusivo: 0 };
    ambassadors?.forEach(amb => {
      const status = amb.performance_status || 'cumple';
      if (status in distribution) {
        distribution[status as keyof typeof distribution]++;
      }
    });

    const total = ambassadors?.length || 1;
    return [
      { category: "Cumple", count: distribution.cumple, percentage: Math.round((distribution.cumple / total) * 100), color: "#10b981" },
      { category: "Advertencia", count: distribution.advertencia, percentage: Math.round((distribution.advertencia / total) * 100), color: "#f59e0b" },
      { category: "No Cumple", count: distribution.no_cumple, percentage: Math.round((distribution.no_cumple / total) * 100), color: "#ef4444" },
      { category: "Exclusivo", count: distribution.exclusivo, percentage: Math.round((distribution.exclusivo / total) * 100), color: "#8b5cf6" }
    ];
  };

  const fetchEventComparison = async (orgIds: string[]) => {
    const { data: fiestas } = await supabase
      .from('fiestas')
      .select('id, name, events(id)')
      .in('organization_id', orgIds)
      .limit(4);

    if (!fiestas) return [];

    const eventComparison = [];
    for (const fiesta of fiestas) {
      if (fiesta.events && fiesta.events.length > 0) {
        const eventIds = fiesta.events.map((e: any) => e.id);
        const { data: tasks } = await supabase
          .from('tasks')
          .select('status, reach_count')
          .in('event_id', eventIds);

        const completed = tasks?.filter(t => t.status === 'completed').length || 0;
        const pending = tasks?.filter(t => ['pending', 'uploaded', 'in_progress'].includes(t.status)).length || 0;
        const failed = tasks?.filter(t => ['invalid', 'expired'].includes(t.status)).length || 0;
        const totalReach = tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;

        eventComparison.push({
          name: fiesta.name,
          completed,
          pending,
          failed,
          total_reach: totalReach
        });
      }
    }
    return eventComparison;
  };

  const fetchTopAmbassadors = async (orgIds: string[]) => {
    const { data: ambassadors } = await supabase
      .from('embassadors')
      .select('id, first_name, last_name, instagram_user, global_points, events_participated, global_category, completed_tasks, failed_tasks')
      .in('organization_id', orgIds)
      .eq('status', 'active')
      .order('global_points', { ascending: false })
      .limit(25);

    if (!ambassadors) return [];

    const ambassadorsWithReach = await Promise.all(
      ambassadors.map(async (amb) => {
        const { data: tasks } = await supabase
          .from('tasks')
          .select('reach_count')
          .eq('embassador_id', amb.id);

        const totalReach = tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;
        const totalTasks = (amb.completed_tasks || 0) + (amb.failed_tasks || 0);
        
        return {
          id: amb.id,
          name: `${amb.first_name} ${amb.last_name}`,
          instagram_user: amb.instagram_user,
          total_points: amb.global_points || 0,
          events_participated: amb.events_participated || 0,
          category: amb.global_category || 'bronze',
          completion_rate: totalTasks > 0 ? Math.round(((amb.completed_tasks || 0) / totalTasks) * 100) : 0,
          total_reach: totalReach
        };
      })
    );

    return ambassadorsWithReach;
  };

  const fetchTrends = async (orgIds: string[]) => {
    const trends = [];
    const now = new Date();
    
    const { data: ambassadors } = await supabase
      .from('embassadors')
      .select('id')
      .in('organization_id', orgIds);

    const ambassadorIds = ambassadors?.map(a => a.id) || [];
    
    for (let i = 29; i >= 0; i--) {
      const date = new Date(now);
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      
      const { data: dailyTasks } = await supabase
        .from('tasks')
        .select('reach_count, engagement_score')
        .in('embassador_id', ambassadorIds)
        .gte('created_at', `${dateStr}T00:00:00`)
        .lt('created_at', `${dateStr}T23:59:59`);

      const dailyReach = dailyTasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;
      const dailyMentions = dailyTasks?.length || 0;
      const dailyEngagement = dailyTasks && dailyTasks.length > 0 
        ? dailyTasks.reduce((sum, t) => sum + (t.engagement_score || 0), 0) / dailyTasks.length 
        : 0;

      trends.push({
        date: dateStr,
        reach: dailyReach,
        mentions: dailyMentions,
        engagement: Number(dailyEngagement.toFixed(1))
      });
    }
    
    return trends;
  };

  const exportAnalytics = async () => {
    try {
      // Implementar l√≥gica de exportaci√≥n
      toast({
        title: "√âxito",
        description: "Datos anal√≠ticos exportados correctamente",
      });
    } catch (error) {
      toast({
        title: "Error",
        description: "No se pudo exportar los datos",
        variant: "destructive",
      });
    }
  };

  const getCategoryBadge = (category: string) => {
    const colors = {
      bronze: "bg-amber-100 text-amber-800",
      silver: "bg-gray-100 text-gray-800",
      gold: "bg-yellow-100 text-yellow-800",
      diamond: "bg-blue-100 text-blue-800"
    };
    return colors[category as keyof typeof colors] || colors.bronze;
  };

  if (loading) {
    return (
      <div className="space-y-6">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-center">
              <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (!analyticsData) {
    return (
      <Card>
        <CardContent className="p-6">
          <div className="text-center text-muted-foreground">
            <BarChart3 className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>No se pudieron cargar los datos anal√≠ticos</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <TooltipProvider>
      <div className="space-y-6">
        {/* Header con Filtros */}
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle className="flex items-center gap-2">
                  <BarChart3 className="h-6 w-6" />
                  Anal√≠ticas Avanzadas
                </CardTitle>
                <CardDescription>
                  Dashboard integral de m√©tricas y performance de campa√±as
                </CardDescription>
              </div>
              <div className="flex items-center gap-3">
                <Select value={selectedEvent} onValueChange={setSelectedEvent}>
                  <SelectTrigger className="w-[200px]">
                    <SelectValue placeholder="Seleccionar evento" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">Todos los eventos</SelectItem>
                    {events.map((event) => (
                      <SelectItem key={event.id} value={event.id}>
                        {event.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>

                <Select value={selectedPeriod} onValueChange={setSelectedPeriod}>
                  <SelectTrigger className="w-[140px]">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="7d">7 d√≠as</SelectItem>
                    <SelectItem value="30d">30 d√≠as</SelectItem>
                    <SelectItem value="90d">3 meses</SelectItem>
                    <SelectItem value="1y">1 a√±o</SelectItem>
                  </SelectContent>
                </Select>

                <Button onClick={exportAnalytics}>
                  <Download className="h-4 w-4 mr-2" />
                  Exportar
                </Button>
              </div>
            </div>
          </CardHeader>
        </Card>

        {/* KPIs Principales */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          <Card>
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div>
                  <div className="flex items-center gap-2">
                    <p className="text-sm font-medium text-muted-foreground">Alcance Total</p>
                    <Tooltip>
                      <TooltipTrigger>
                        <HelpCircle className="h-3 w-3 text-muted-foreground" />
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>Suma del alcance estimado de todas las publicaciones</p>
                      </TooltipContent>
                    </Tooltip>
                  </div>
                  <p className="text-2xl font-bold">{analyticsData.summary.total_reach.toLocaleString()}</p>
                </div>
                <TrendingUp className="h-8 w-8 text-green-600" />
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div>
                  <div className="flex items-center gap-2">
                    <p className="text-sm font-medium text-muted-foreground">Total Menciones</p>
                    <Tooltip>
                      <TooltipTrigger>
                        <HelpCircle className="h-3 w-3 text-muted-foreground" />
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>N√∫mero total de menciones e historias</p>
                      </TooltipContent>
                    </Tooltip>
                  </div>
                  <p className="text-2xl font-bold">{analyticsData.summary.total_mentions}</p>
                </div>
                <Activity className="h-8 w-8 text-blue-600" />
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div>
                  <div className="flex items-center gap-2">
                    <p className="text-sm font-medium text-muted-foreground">Tasa Completitud</p>
                    <Tooltip>
                      <TooltipTrigger>
                        <HelpCircle className="h-3 w-3 text-muted-foreground" />
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>Porcentaje de tareas completadas exitosamente</p>
                      </TooltipContent>
                    </Tooltip>
                  </div>
                  <p className="text-2xl font-bold">{analyticsData.summary.completion_rate}%</p>
                </div>
                <Target className="h-8 w-8 text-purple-600" />
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm font-medium text-muted-foreground">Embajadores Activos</p>
                  <p className="text-2xl font-bold">{analyticsData.summary.active_ambassadors}</p>
                </div>
                <Users className="h-8 w-8 text-orange-600" />
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm font-medium text-muted-foreground">Eventos Completados</p>
                  <p className="text-2xl font-bold">{analyticsData.summary.events_completed}</p>
                </div>
                <Calendar className="h-8 w-8 text-indigo-600" />
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm font-medium text-muted-foreground">Engagement Promedio</p>
                  <p className="text-2xl font-bold">{analyticsData.summary.average_engagement.toFixed(1)}%</p>
                </div>
                <Award className="h-8 w-8 text-pink-600" />
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Tabs de An√°lisis Detallado */}
        <Tabs defaultValue="resumen" className="space-y-4">
          <TabsList className="grid w-full grid-cols-4">
            <TabsTrigger value="resumen">Resumen</TabsTrigger>
            <TabsTrigger value="rendimiento">Rendimiento</TabsTrigger>
            <TabsTrigger value="eventos">Eventos</TabsTrigger>
            <TabsTrigger value="top25">Top 25</TabsTrigger>
          </TabsList>

          <TabsContent value="resumen" className="space-y-4">
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <Card>
                <CardHeader>
                  <CardTitle>Distribuci√≥n de Performance</CardTitle>
                  <CardDescription>Estado actual de todos los embajadores</CardDescription>
                </CardHeader>
                <CardContent>
                  <ResponsiveContainer width="100%" height={300}>
                    <PieChart>
                      <Pie
                        data={analyticsData.performance_distribution}
                        cx="50%"
                        cy="50%"
                        innerRadius={60}
                        outerRadius={120}
                        paddingAngle={5}
                        dataKey="count"
                      >
                        {analyticsData.performance_distribution.map((entry, index) => (
                          <Cell key={`cell-${index}`} fill={entry.color} />
                        ))}
                      </Pie>
                      <RechartsTooltip formatter={(value) => [`${value} embajadores`, "Total"]} />
                    </PieChart>
                  </ResponsiveContainer>
                  <div className="flex justify-center gap-4 mt-4">
                    {analyticsData.performance_distribution.map((item) => (
                      <div key={item.category} className="flex items-center gap-2">
                        <div 
                          className="w-3 h-3 rounded-full" 
                          style={{ backgroundColor: item.color }}
                        ></div>
                        <span className="text-sm">{item.category} ({item.percentage}%)</span>
                      </div>
                    ))}
                  </div>
                </CardContent>
              </Card>

              <Card>
                <CardHeader>
                  <CardTitle>Evoluci√≥n de M√©tricas</CardTitle>
                  <CardDescription>Tendencias en los √∫ltimos 30 d√≠as</CardDescription>
                </CardHeader>
                <CardContent>
                  <ResponsiveContainer width="100%" height={300}>
                    <LineChart data={analyticsData.trends.slice(-7)}>
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="date" tickFormatter={(date) => new Date(date).getDate().toString()} />
                      <YAxis />
                      <RechartsTooltip />
                      <Line 
                        type="monotone" 
                        dataKey="reach" 
                        stroke="#8884d8" 
                        strokeWidth={2}
                        name="Alcance"
                      />
                      <Line 
                        type="monotone" 
                        dataKey="mentions" 
                        stroke="#82ca9d" 
                        strokeWidth={2}
                        name="Menciones"
                      />
                    </LineChart>
                  </ResponsiveContainer>
                </CardContent>
              </Card>
            </div>
          </TabsContent>

          <TabsContent value="eventos">
            <Card>
              <CardHeader>
                <CardTitle>Comparaci√≥n de Eventos</CardTitle>
                <CardDescription>Performance comparativa de diferentes eventos</CardDescription>
              </CardHeader>
              <CardContent>
                <ResponsiveContainer width="100%" height={400}>
                  <BarChart data={analyticsData.event_comparison}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="name" />
                    <YAxis />
                    <RechartsTooltip />
                    <Bar dataKey="completed" fill="#10b981" name="Completadas" />
                    <Bar dataKey="pending" fill="#f59e0b" name="Pendientes" />
                    <Bar dataKey="failed" fill="#ef4444" name="Fallidas" />
                  </BarChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="top25">
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <div>
                    <CardTitle>Top 25 Embajadores</CardTitle>
                    <CardDescription>Ranking de los mejores embajadores por puntos totales</CardDescription>
                  </div>
                  <Button onClick={exportAnalytics} variant="outline">
                    <Download className="h-4 w-4 mr-2" />
                    Exportar Ranking
                  </Button>
                </div>
              </CardHeader>
              <CardContent>
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Ranking</TableHead>
                      <TableHead>Embajador</TableHead>
                      <TableHead>Instagram</TableHead>
                      <TableHead>Puntos</TableHead>
                      <TableHead>Eventos</TableHead>
                      <TableHead>Categor√≠a</TableHead>
                      <TableHead>Completitud</TableHead>
                      <TableHead>Alcance</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {analyticsData.top_ambassadors.slice(0, 25).map((ambassador, index) => (
                      <TableRow key={ambassador.id}>
                        <TableCell>
                          <div className="flex items-center justify-center w-8 h-8 rounded-full bg-primary text-primary-foreground font-bold text-sm">
                            {index + 1}
                          </div>
                        </TableCell>
                        <TableCell className="font-medium">{ambassador.name}</TableCell>
                        <TableCell className="text-muted-foreground">{ambassador.instagram_user}</TableCell>
                        <TableCell className="font-bold">{ambassador.total_points}</TableCell>
                        <TableCell>{ambassador.events_participated}</TableCell>
                        <TableCell>
                          <Badge className={getCategoryBadge(ambassador.category)}>
                            {ambassador.category.charAt(0).toUpperCase() + ambassador.category.slice(1)}
                          </Badge>
                        </TableCell>
                        <TableCell>{ambassador.completion_rate}%</TableCell>
                        <TableCell>{ambassador.total_reach.toLocaleString()}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>
      </div>
    </TooltipProvider>
  );
}
</file>

<file path="src/components/Auth/AuthForm.tsx">
import { useState } from "react";
import { useAuth } from "@/hooks/useAuth";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useToast } from "@/hooks/use-toast";
import { Sparkles, Instagram, BarChart3, Users, Zap, Shield } from "lucide-react";
import { ModernLogo } from "@/components/Logo/ModernLogo";

export function AuthForm() {
  const [isLoading, setIsLoading] = useState(false);
  const { signIn, signUp } = useAuth();
  const { toast } = useToast();

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>, mode: 'signin' | 'signup') => {
    e.preventDefault();
    setIsLoading(true);

    const formData = new FormData(e.currentTarget);
    const email = formData.get('email') as string;
    const password = formData.get('password') as string;

    try {
      const { error } = mode === 'signin' 
        ? await signIn(email, password)
        : await signUp(email, password);

      if (error) {
        toast({
          title: "Error",
          description: error.message,
          variant: "destructive",
        });
      } else if (mode === 'signup') {
        toast({
          title: "¬°Cuenta creada!",
          description: "Revisa tu email para confirmar tu cuenta.",
        });
      }
    } catch (error) {
      toast({
        title: "Error",
        description: "Algo sali√≥ mal. Int√©ntalo de nuevo.",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 via-gray-100 to-gray-200 flex items-center justify-center p-4">
      <div className="w-full max-w-6xl mx-auto">
        {/* Centered Container */}
        <div className="flex flex-col lg:flex-row items-center justify-center gap-12 lg:gap-16">
          
          {/* Brand Section - Always Visible */}
          <div className="flex flex-col items-center space-y-8 text-center lg:flex-1">
            {/* Logo with Animation */}
            <div className="animate-fade-in">
              <ModernLogo size="xl" className="animate-scale-in" />
            </div>
            
            {/* Title with Futuristic Gradient */}
            <div className="space-y-4 animate-fade-in">
              <h1 className="text-4xl lg:text-6xl font-bold bg-gradient-to-r from-gray-900 via-gray-700 to-gray-600 bg-clip-text text-transparent">
                EVA System
              </h1>
              <p className="text-xl lg:text-2xl text-gray-600 max-w-2xl leading-relaxed">
                Gestiona tu equipo de embajadores de Instagram con 
                <span className="bg-gradient-to-r from-purple-600 to-blue-600 bg-clip-text text-transparent font-semibold"> inteligencia artificial</span>
              </p>
            </div>

            {/* Features Grid - More Futuristic */}
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6 text-left max-w-3xl animate-fade-in">
              <div className="group p-4 rounded-2xl bg-white/50 backdrop-blur-sm border border-gray-200/50 hover:shadow-lg transition-all duration-300 hover:scale-105">
                <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-pink-500 to-purple-600 flex items-center justify-center mb-3 group-hover:scale-110 transition-transform">
                  <Instagram className="w-6 h-6 text-white" />
                </div>
                <h3 className="font-semibold text-gray-900 mb-1">Integraci√≥n Instagram</h3>
                <p className="text-sm text-gray-600">Conexi√≥n directa y segura</p>
              </div>
              
              <div className="group p-4 rounded-2xl bg-white/50 backdrop-blur-sm border border-gray-200/50 hover:shadow-lg transition-all duration-300 hover:scale-105">
                <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-blue-500 to-cyan-600 flex items-center justify-center mb-3 group-hover:scale-110 transition-transform">
                  <BarChart3 className="w-6 h-6 text-white" />
                </div>
                <h3 className="font-semibold text-gray-900 mb-1">Anal√≠ticas IA</h3>
                <p className="text-sm text-gray-600">Insights en tiempo real</p>
              </div>
              
              <div className="group p-4 rounded-2xl bg-white/50 backdrop-blur-sm border border-gray-200/50 hover:shadow-lg transition-all duration-300 hover:scale-105">
                <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-green-500 to-emerald-600 flex items-center justify-center mb-3 group-hover:scale-110 transition-transform">
                  <Users className="w-6 h-6 text-white" />
                </div>
                <h3 className="font-semibold text-gray-900 mb-1">Gesti√≥n Inteligente</h3>
                <p className="text-sm text-gray-600">Embajadores y eventos</p>
              </div>
            </div>
          </div>

          {/* Auth Form - Modern Card */}
          <div className="w-full max-w-md lg:flex-none animate-fade-in">
            <div className="backdrop-blur-md bg-white/80 rounded-3xl shadow-2xl border border-gray-200/50 p-8">
              {/* Mobile Brand Header */}
              <div className="text-center mb-8 lg:hidden">
                <ModernLogo size="lg" className="mx-auto mb-4" />
                <h2 className="text-2xl font-bold text-gray-900 mb-2">EVA System</h2>
                <p className="text-gray-600">Tu plataforma de embajadores IA</p>
              </div>

              <Tabs defaultValue="signin" className="w-full">
                <TabsList className="grid w-full grid-cols-2 bg-gray-100/50 rounded-2xl p-1">
                  <TabsTrigger 
                    value="signin" 
                    className="rounded-xl data-[state=active]:bg-white data-[state=active]:shadow-sm transition-all"
                  >
                    Iniciar Sesi√≥n
                  </TabsTrigger>
                  <TabsTrigger 
                    value="signup"
                    className="rounded-xl data-[state=active]:bg-white data-[state=active]:shadow-sm transition-all"
                  >
                    Registrarse
                  </TabsTrigger>
                </TabsList>
                
                <TabsContent value="signin" className="mt-6">
                  <div className="space-y-6">
                    <div className="text-center space-y-2">
                      <h3 className="text-2xl font-bold text-gray-900">Bienvenido de vuelta</h3>
                      <p className="text-gray-600">
                        Ingresa tus credenciales para continuar
                      </p>
                    </div>
                    
                    <form onSubmit={(e) => handleSubmit(e, 'signin')} className="space-y-5">
                      <div className="space-y-2">
                        <Label htmlFor="signin-email" className="text-gray-700 font-medium">Email</Label>
                        <Input
                          id="signin-email"
                          name="email"
                          type="email"
                          placeholder="tu@email.com"
                          className="h-12 rounded-xl border-gray-200 focus:border-gray-400 bg-white/50"
                          required
                        />
                      </div>
                      <div className="space-y-2">
                        <Label htmlFor="signin-password" className="text-gray-700 font-medium">Contrase√±a</Label>
                        <Input
                          id="signin-password"
                          name="password"
                          type="password"
                          placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                          className="h-12 rounded-xl border-gray-200 focus:border-gray-400 bg-white/50"
                          required
                        />
                      </div>
                      <Button 
                        type="submit" 
                        className="w-full h-12 rounded-xl bg-gradient-to-r from-gray-900 to-gray-700 hover:from-gray-800 hover:to-gray-600 text-white font-semibold shadow-lg hover:shadow-xl transition-all duration-300 hover:scale-[1.02]" 
                        disabled={isLoading}
                      >
                        {isLoading ? (
                          <div className="flex items-center gap-2">
                            <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                            Iniciando sesi√≥n...
                          </div>
                        ) : (
                          <div className="flex items-center gap-2">
                            <Zap className="w-4 h-4" />
                            Iniciar Sesi√≥n
                          </div>
                        )}
                      </Button>
                    </form>
                  </div>
                </TabsContent>
                
                <TabsContent value="signup" className="mt-6">
                  <div className="space-y-6">
                    <div className="text-center space-y-2">
                      <h3 className="text-2xl font-bold text-gray-900">Crear cuenta</h3>
                      <p className="text-gray-600">
                        √önete a EVA System y comienza tu transformaci√≥n digital
                      </p>
                    </div>
                    
                    <form onSubmit={(e) => handleSubmit(e, 'signup')} className="space-y-5">
                      <div className="space-y-2">
                        <Label htmlFor="signup-email" className="text-gray-700 font-medium">Email</Label>
                        <Input
                          id="signup-email"
                          name="email"
                          type="email"
                          placeholder="tu@email.com"
                          className="h-12 rounded-xl border-gray-200 focus:border-gray-400 bg-white/50"
                          required
                        />
                      </div>
                      <div className="space-y-2">
                        <Label htmlFor="signup-password" className="text-gray-700 font-medium">Contrase√±a</Label>
                        <Input
                          id="signup-password"
                          name="password"
                          type="password"
                          placeholder="M√≠nimo 6 caracteres"
                          className="h-12 rounded-xl border-gray-200 focus:border-gray-400 bg-white/50"
                          required
                        />
                      </div>
                      <Button 
                        type="submit" 
                        className="w-full h-12 rounded-xl bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-500 hover:to-blue-500 text-white font-semibold shadow-lg hover:shadow-xl transition-all duration-300 hover:scale-[1.02]" 
                        disabled={isLoading}
                      >
                        {isLoading ? (
                          <div className="flex items-center gap-2">
                            <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                            Creando cuenta...
                          </div>
                        ) : (
                          <div className="flex items-center gap-2">
                            <Shield className="w-4 h-4" />
                            Crear Cuenta
                          </div>
                        )}
                      </Button>
                    </form>
                  </div>
                </TabsContent>
              </Tabs>
            </div>
          </div>
        </div>
        
        {/* Floating Elements for Futuristic Feel */}
        <div className="absolute inset-0 overflow-hidden pointer-events-none">
          <div className="absolute top-1/4 left-1/4 w-2 h-2 bg-purple-400 rounded-full animate-pulse opacity-40"></div>
          <div className="absolute top-3/4 right-1/3 w-1 h-1 bg-blue-400 rounded-full animate-pulse opacity-30 delay-1000"></div>
          <div className="absolute bottom-1/3 left-1/5 w-1.5 h-1.5 bg-pink-400 rounded-full animate-pulse opacity-20 delay-500"></div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/Auth/ProtectedRoute.tsx">
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "@/hooks/useAuth";

interface ProtectedRouteProps {
  children: React.ReactNode;
  redirectTo?: string;
}

export function ProtectedRoute({ children, redirectTo = "/auth" }: ProtectedRouteProps) {
  const { user, loading } = useAuth();
  const navigate = useNavigate();

  useEffect(() => {
    if (!loading && !user) {
      console.log("No authenticated user, redirecting to:", redirectTo);
      navigate(redirectTo, { replace: true });
    }
  }, [user, loading, navigate, redirectTo]);

  // Show loading while checking auth
  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-background">
        <div className="flex flex-col items-center space-y-4">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
          <p className="text-sm text-muted-foreground animate-pulse">Verificando autenticaci√≥n...</p>
        </div>
      </div>
    );
  }

  // Don't render children if no user
  if (!user) {
    return null;
  }

  return <>{children}</>;
}
</file>

<file path="src/components/Auth/SimpleAuthForm.tsx">
import { useState } from "react";
import { useAuth } from "@/hooks/useAuth";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { toast } from "sonner";
import { ModernLogo } from "@/components/Logo/ModernLogo";

export function SimpleAuthForm() {
  const [isLoading, setIsLoading] = useState(false);
  const { signIn, signUp } = useAuth();

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>, mode: 'signin' | 'signup') => {
    e.preventDefault();
    setIsLoading(true);

    const formData = new FormData(e.currentTarget);
    const email = formData.get('email') as string;
    const password = formData.get('password') as string;

    // Validaci√≥n b√°sica
    if (!email || !password) {
      toast.error('Por favor completa todos los campos');
      setIsLoading(false);
      return;
    }

    if (mode === 'signup' && password.length < 6) {
      toast.error('La contrase√±a debe tener al menos 6 caracteres');
      setIsLoading(false);
      return;
    }

    try {
      const { error } = mode === 'signin' 
        ? await signIn(email, password)
        : await signUp(email, password);

      if (error) {
        toast.error(error.message);
      } else if (mode === 'signup') {
        toast.success("¬°Cuenta creada! Revisa tu email para confirmar tu cuenta.");
      }
    } catch (error) {
      toast.error("Algo sali√≥ mal. Int√©ntalo de nuevo.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Tabs defaultValue="signin" className="w-full">
      <TabsList className="grid w-full grid-cols-2">
        <TabsTrigger value="signin">Iniciar Sesi√≥n</TabsTrigger>
        <TabsTrigger value="signup">Registrarse</TabsTrigger>
      </TabsList>
      
      <TabsContent value="signin">
        <form onSubmit={(e) => handleSubmit(e, 'signin')} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="signin-email">Email</Label>
            <Input
              id="signin-email"
              name="email"
              type="email"
              placeholder="tu@email.com"
              required
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="signin-password">Contrase√±a</Label>
            <Input
              id="signin-password"
              name="password"
              type="password"
              required
            />
          </div>
          <Button type="submit" className="w-full" disabled={isLoading}>
            {isLoading ? "Iniciando sesi√≥n..." : "Iniciar Sesi√≥n"}
          </Button>
        </form>
      </TabsContent>
      
      <TabsContent value="signup">
        <form onSubmit={(e) => handleSubmit(e, 'signup')} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="signup-email">Email</Label>
            <Input
              id="signup-email"
              name="email"
              type="email"
              placeholder="tu@email.com"
              required
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="signup-password">Contrase√±a</Label>
            <Input
              id="signup-password"
              name="password"
              type="password"
              placeholder="M√≠nimo 6 caracteres"
              required
            />
          </div>
          <Button type="submit" className="w-full" disabled={isLoading}>
            {isLoading ? "Creando cuenta..." : "Crear Cuenta"}
          </Button>
        </form>
      </TabsContent>
    </Tabs>
  );
}
</file>

<file path="src/components/Automation/AutomationRules.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Zap,
  Plus,
  Play,
  Pause,
  Settings,
  AlertTriangle,
  Mail,
  Bell,
  Award,
  Clock,
  Target,
  Trash2,
  Edit
} from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";

interface AutomationRule {
  id: string;
  name: string;
  description: string;
  trigger_type: "performance_change" | "task_deadline" | "event_completion" | "point_milestone";
  trigger_condition: any;
  action_type: "send_notification" | "send_email" | "assign_reward" | "change_status";
  action_config: any;
  active: boolean;
  created_at: string;
  last_executed?: string;
  execution_count: number;
}

export function AutomationRules() {
  const [rules, setRules] = useState<AutomationRule[]>([]);
  const [loading, setLoading] = useState(true);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editingRule, setEditingRule] = useState<AutomationRule | null>(null);
  const { toast } = useToast();

  // Mock data for demonstration
  useEffect(() => {
    loadAutomationRules();
  }, []);

  const loadAutomationRules = async () => {
    try {
      setLoading(true);
      
      // Mock automation rules - replace with real Supabase queries
      const mockRules: AutomationRule[] = [
        {
          id: "1",
          name: "Advertencia por Performance",
          description: "Enviar notificaci√≥n cuando un embajador recibe 3 advertencias",
          trigger_type: "performance_change",
          trigger_condition: { performance: "advertencia", count: 3 },
          action_type: "send_notification",
          action_config: { 
            message: "El embajador {ambassador_name} ha recibido 3 advertencias. Revisar performance.",
            recipients: ["admin", "rrpp"]
          },
          active: true,
          created_at: new Date().toISOString(),
          last_executed: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
          execution_count: 5
        },
        {
          id: "2",
          name: "Reconocimiento por Milestone",
          description: "Asignar recompensa al alcanzar 100 puntos",
          trigger_type: "point_milestone",
          trigger_condition: { points: 100 },
          action_type: "assign_reward",
          action_config: { 
            reward_type: "badge",
            reward_name: "Embajador Destacado",
            auto_notify: true
          },
          active: true,
          created_at: new Date().toISOString(),
          last_executed: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
          execution_count: 12
        },
        {
          id: "3",
          name: "Alerta de Evento Pr√≥ximo",
          description: "Recordatorio 24h antes del evento",
          trigger_type: "task_deadline",
          trigger_condition: { hours_before: 24 },
          action_type: "send_email",
          action_config: { 
            subject: "Recordatorio: Evento ma√±ana",
            template: "event_reminder",
            send_to_ambassadors: true
          },
          active: false,
          created_at: new Date().toISOString(),
          execution_count: 0
        }
      ];

      setRules(mockRules);
    } catch (error) {
      console.error("Error loading automation rules:", error);
      toast({
        title: "Error",
        description: "No se pudieron cargar las reglas de automatizaci√≥n",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  const toggleRuleStatus = async (ruleId: string) => {
    try {
      setRules(prev => prev.map(rule => 
        rule.id === ruleId 
          ? { ...rule, active: !rule.active }
          : rule
      ));

      toast({
        title: "Regla actualizada",
        description: "El estado de la regla ha sido cambiado"
      });
    } catch (error) {
      console.error("Error toggling rule:", error);
    }
  };

  const executeRule = async (ruleId: string) => {
    try {
      // Mock execution
      setRules(prev => prev.map(rule => 
        rule.id === ruleId 
          ? { 
              ...rule, 
              last_executed: new Date().toISOString(),
              execution_count: rule.execution_count + 1
            }
          : rule
      ));

      toast({
        title: "Regla ejecutada",
        description: "La regla se ha ejecutado correctamente"
      });
    } catch (error) {
      console.error("Error executing rule:", error);
    }
  };

  const deleteRule = async (ruleId: string) => {
    try {
      setRules(prev => prev.filter(rule => rule.id !== ruleId));
      
      toast({
        title: "Regla eliminada",
        description: "La regla de automatizaci√≥n ha sido eliminada"
      });
    } catch (error) {
      console.error("Error deleting rule:", error);
    }
  };

  const getTriggerIcon = (type: string) => {
    switch (type) {
      case "performance_change":
        return <AlertTriangle className="w-4 h-4" />;
      case "task_deadline":
        return <Clock className="w-4 h-4" />;
      case "event_completion":
        return <Target className="w-4 h-4" />;
      case "point_milestone":
        return <Award className="w-4 h-4" />;
      default:
        return <Zap className="w-4 h-4" />;
    }
  };

  const getActionIcon = (type: string) => {
    switch (type) {
      case "send_notification":
        return <Bell className="w-4 h-4" />;
      case "send_email":
        return <Mail className="w-4 h-4" />;
      case "assign_reward":
        return <Award className="w-4 h-4" />;
      default:
        return <Zap className="w-4 h-4" />;
    }
  };

  const formatLastExecution = (dateString?: string) => {
    if (!dateString) return "Nunca";
    const date = new Date(dateString);
    const now = new Date();
    const diffInHours = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60));
    
    if (diffInHours < 24) return `Hace ${diffInHours} horas`;
    const diffInDays = Math.floor(diffInHours / 24);
    return `Hace ${diffInDays} d√≠as`;
  };

  if (loading) {
    return (
      <div className="p-6">
        <div className="animate-pulse space-y-6">
          <div className="h-8 bg-muted rounded w-64" />
          <div className="grid gap-4">
            {[...Array(3)].map((_, i) => (
              <div key={i} className="h-32 bg-muted rounded-lg" />
            ))}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold bg-gradient-primary bg-clip-text text-transparent">
            Automatizaci√≥n
          </h1>
          <p className="text-muted-foreground">
            Configura reglas autom√°ticas para optimizar la gesti√≥n de embajadores
          </p>
        </div>
        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
          <DialogTrigger asChild>
            <Button>
              <Plus className="w-4 h-4 mr-2" />
              Nueva Regla
            </Button>
          </DialogTrigger>
          <DialogContent className="max-w-2xl">
            <DialogHeader>
              <DialogTitle>Crear Regla de Automatizaci√≥n</DialogTitle>
              <DialogDescription>
                Define los disparadores y acciones para automatizar procesos
              </DialogDescription>
            </DialogHeader>
            <AutomationRuleForm 
              rule={editingRule}
              onSave={() => {
                setDialogOpen(false);
                setEditingRule(null);
                loadAutomationRules();
              }}
              onCancel={() => {
                setDialogOpen(false);
                setEditingRule(null);
              }}
            />
          </DialogContent>
        </Dialog>
      </div>

      {/* Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-blue-500/10 rounded-lg">
                <Zap className="w-5 h-5 text-blue-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Reglas Activas</p>
                <p className="text-2xl font-bold">{rules.filter(r => r.active).length}</p>
              </div>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-green-500/10 rounded-lg">
                <Play className="w-5 h-5 text-green-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Ejecuciones Hoy</p>
                <p className="text-2xl font-bold">
                  {rules.reduce((sum, rule) => sum + rule.execution_count, 0)}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-yellow-500/10 rounded-lg">
                <Pause className="w-5 h-5 text-yellow-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Reglas Pausadas</p>
                <p className="text-2xl font-bold">{rules.filter(r => !r.active).length}</p>
              </div>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-purple-500/10 rounded-lg">
                <Settings className="w-5 h-5 text-purple-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Total Reglas</p>
                <p className="text-2xl font-bold">{rules.length}</p>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Rules List */}
      <div className="space-y-4">
        {rules.length === 0 ? (
          <Card className="shadow-card">
            <CardContent className="p-8 text-center">
              <Zap className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
              <h3 className="text-lg font-medium mb-2">No hay reglas configuradas</h3>
              <p className="text-muted-foreground mb-4">
                Crea tu primera regla de automatizaci√≥n para optimizar los procesos
              </p>
              <Button onClick={() => setDialogOpen(true)}>
                <Plus className="w-4 h-4 mr-2" />
                Crear Primera Regla
              </Button>
            </CardContent>
          </Card>
        ) : (
          rules.map((rule) => (
            <Card key={rule.id} className="shadow-card">
              <CardContent className="p-6">
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="flex items-center space-x-3 mb-2">
                      <h3 className="text-lg font-semibold">{rule.name}</h3>
                      <Badge variant={rule.active ? "default" : "secondary"}>
                        {rule.active ? "Activa" : "Pausada"}
                      </Badge>
                    </div>
                    
                    <p className="text-muted-foreground mb-4">{rule.description}</p>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div className="space-y-2">
                        <h4 className="font-medium text-sm">Disparador</h4>
                        <div className="flex items-center space-x-2 p-2 bg-muted/50 rounded">
                          {getTriggerIcon(rule.trigger_type)}
                          <span className="text-sm capitalize">
                            {rule.trigger_type.replace("_", " ")}
                          </span>
                        </div>
                      </div>
                      
                      <div className="space-y-2">
                        <h4 className="font-medium text-sm">Acci√≥n</h4>
                        <div className="flex items-center space-x-2 p-2 bg-muted/50 rounded">
                          {getActionIcon(rule.action_type)}
                          <span className="text-sm capitalize">
                            {rule.action_type.replace("_", " ")}
                          </span>
                        </div>
                      </div>
                    </div>
                    
                    <div className="flex items-center space-x-6 mt-4 text-sm text-muted-foreground">
                      <span>Ejecutada: {formatLastExecution(rule.last_executed)}</span>
                      <span>Veces ejecutada: {rule.execution_count}</span>
                    </div>
                  </div>
                  
                  <div className="flex items-center space-x-2 ml-4">
                    <Switch
                      checked={rule.active}
                      onCheckedChange={() => toggleRuleStatus(rule.id)}
                    />
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => executeRule(rule.id)}
                      disabled={!rule.active}
                    >
                      <Play className="w-4 h-4" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => {
                        setEditingRule(rule);
                        setDialogOpen(true);
                      }}
                    >
                      <Edit className="w-4 h-4" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => deleteRule(rule.id)}
                    >
                      <Trash2 className="w-4 h-4" />
                    </Button>
                  </div>
                </div>
              </CardContent>
            </Card>
          ))
        )}
      </div>
    </div>
  );
}

function AutomationRuleForm({ rule, onSave, onCancel }: {
  rule: AutomationRule | null;
  onSave: () => void;
  onCancel: () => void;
}) {
  const [formData, setFormData] = useState({
    name: rule?.name || "",
    description: rule?.description || "",
    trigger_type: rule?.trigger_type || "performance_change",
    action_type: rule?.action_type || "send_notification",
    active: rule?.active ?? true
  });

  const handleSave = () => {
    // Mock save - implement real logic
    onSave();
  };

  return (
    <div className="space-y-6">
      <div className="space-y-4">
        <div className="space-y-2">
          <Label htmlFor="rule-name">Nombre de la Regla</Label>
          <Input
            id="rule-name"
            value={formData.name}
            onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
            placeholder="Ej: Alerta por performance baja"
          />
        </div>
        
        <div className="space-y-2">
          <Label htmlFor="rule-description">Descripci√≥n</Label>
          <Textarea
            id="rule-description"
            value={formData.description}
            onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
            placeholder="Describe qu√© hace esta regla..."
          />
        </div>
        
        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label>Disparador</Label>
            <Select
              value={formData.trigger_type}
              onValueChange={(value) => setFormData(prev => ({ ...prev, trigger_type: value as any }))}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="performance_change">Cambio de Performance</SelectItem>
                <SelectItem value="task_deadline">Fecha L√≠mite de Tarea</SelectItem>
                <SelectItem value="event_completion">Finalizaci√≥n de Evento</SelectItem>
                <SelectItem value="point_milestone">Milestone de Puntos</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          <div className="space-y-2">
            <Label>Acci√≥n</Label>
            <Select
              value={formData.action_type}
              onValueChange={(value) => setFormData(prev => ({ ...prev, action_type: value as any }))}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="send_notification">Enviar Notificaci√≥n</SelectItem>
                <SelectItem value="send_email">Enviar Email</SelectItem>
                <SelectItem value="assign_reward">Asignar Recompensa</SelectItem>
                <SelectItem value="change_status">Cambiar Estado</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>
        
        <div className="flex items-center space-x-2">
          <Switch
            id="rule-active"
            checked={formData.active}
            onCheckedChange={(checked) => setFormData(prev => ({ ...prev, active: checked }))}
          />
          <Label htmlFor="rule-active">Activar regla inmediatamente</Label>
        </div>
      </div>
      
      <div className="flex justify-end space-x-2">
        <Button variant="outline" onClick={onCancel}>
          Cancelar
        </Button>
        <Button onClick={handleSave} disabled={!formData.name}>
          {rule ? "Actualizar" : "Crear"} Regla
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/Cards/FeedbackCards.tsx">
import { useState, useEffect } from "react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { X, CheckCircle, AlertTriangle, AlertCircle, Info } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

interface SimpleActivity {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info';
  message: string;
  created_at: string;
}

export default function FeedbackCards() {
  const [activities, setActivities] = useState<SimpleActivity[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    generateActivities();
  }, []);

  const generateActivities = async () => {
    try {
      const { data: user } = await supabase.auth.getUser();
      if (!user.user) return;

      // Generar actividades basadas en los datos existentes
      const activities: SimpleActivity[] = [];

      // Verificar organizaciones del usuario
      const { data: organizations, error: orgError } = await supabase
        .from('organizations')
        .select('id, name, description, timezone, logo_url, plan_type, instagram_username, facebook_page_id, instagram_business_account_id, instagram_user_id, last_instagram_sync, created_by, created_at')
        .eq('created_by', user.user.id);

      if (!orgError && organizations && organizations.length > 0) {
        activities.push({
          id: `org-${Date.now()}`,
          type: 'success',
          message: `Tienes ${organizations.length} organizaci√≥n(es) activa(s)`,
          created_at: new Date().toISOString()
        });

        // Para cada organizaci√≥n, verificar eventos
        for (const org of organizations) {
          // Verificar embajadores
          const { data: ambassadors } = await supabase
            .from('embassadors')
            .select('id, first_name, last_name, email, instagram_user, organization_id, status')
            .eq('organization_id', org.id);

          if (ambassadors && ambassadors.length > 0) {
            activities.push({
              id: `ambassadors-${org.id}`,
              type: 'success',
              message: `${org.name}: ${ambassadors.length} embajador(es) registrado(s)`,
              created_at: new Date().toISOString()
            });
          }
        }
      } else {
        activities.push({
          id: 'no-org',
          type: 'warning',
          message: 'No tienes organizaciones creadas. ¬°Crea una para empezar!',
          created_at: new Date().toISOString()
        });
      }

      setActivities(activities);
    } catch (error) {
      console.error('Error generating activities:', error);
    } finally {
      setLoading(false);
    }
  };

  const dismissActivity = (activityId: string) => {
    setActivities(prev => prev.filter(activity => activity.id !== activityId));
  };

  const getActivityIcon = (type: string) => {
    switch (type) {
      case 'success':
        return <CheckCircle className="w-4 h-4 text-green-500" />;
      case 'error':
        return <AlertCircle className="w-4 h-4 text-red-500" />;
      case 'warning':
        return <AlertTriangle className="w-4 h-4 text-yellow-500" />;
      case 'info':
        return <Info className="w-4 h-4 text-blue-500" />;
      default:
        return <Info className="w-4 h-4 text-blue-500" />;
    }
  };

  const getActivityStyle = (type: string) => {
    switch (type) {
      case 'success':
        return 'border-green-200 bg-green-50 text-green-800';
      case 'error':
        return 'border-red-200 bg-red-50 text-red-800';
      case 'warning':
        return 'border-yellow-200 bg-yellow-50 text-yellow-800';
      case 'info':
        return 'border-blue-200 bg-blue-50 text-blue-800';
      default:
        return 'border-blue-200 bg-blue-50 text-blue-800';
    }
  };

  if (loading) {
    return (
      <div className="space-y-2">
        {[...Array(3)].map((_, i) => (
          <div key={i} className="h-16 bg-muted animate-pulse rounded-lg" />
        ))}
      </div>
    );
  }

  if (activities.length === 0) {
    return null;
  }

  return (
    <div className="space-y-2 mb-6">
      {activities.map((activity) => (
        <Alert key={activity.id} className={getActivityStyle(activity.type)}>
          <div className="flex items-start justify-between">
            <div className="flex items-start gap-2">
              {getActivityIcon(activity.type)}
              <AlertDescription className="flex-1">
                {activity.message}
              </AlertDescription>
            </div>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => dismissActivity(activity.id)}
              className="h-auto p-1"
            >
              <X className="w-4 h-4" />
            </Button>
          </div>
        </Alert>
      ))}
    </div>
  );
}
</file>

<file path="src/components/Cards/RealtimeCards.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { CheckCircle, AlertCircle, Info, Star, Eye, RefreshCw, Loader2 } from "lucide-react";
import { useRealtimeCards } from "@/hooks/useRealtimeCards";
import { formatDistance } from "date-fns";
import { es } from "date-fns/locale";
import { useState } from "react";

const getCardIcon = (type: string) => {
  switch (type) {
    case 'success':
      return <CheckCircle className="w-5 h-5 text-green-500" />;
    case 'warning':
      return <AlertCircle className="w-5 h-5 text-yellow-500" />;
    case 'info':
      return <Info className="w-5 h-5 text-blue-500" />;
    case 'achievement':
      return <Star className="w-5 h-5 text-purple-500" />;
    default:
      return <Info className="w-5 h-5 text-gray-500" />;
  }
};

const getCardColor = (type: string) => {
  switch (type) {
    case 'success':
      return 'border-green-200 bg-green-50';
    case 'warning':
      return 'border-yellow-200 bg-yellow-50';
    case 'info':
      return 'border-blue-200 bg-blue-50';
    case 'achievement':
      return 'border-purple-200 bg-purple-50';
    default:
      return 'border-gray-200 bg-gray-50';
  }
};

export default function RealtimeCards() {
  const { cards, loading, markAsRead, refreshCards } = useRealtimeCards();
  const [refreshing, setRefreshing] = useState(false);

  const handleRefresh = async () => {
    setRefreshing(true);
    await refreshCards();
    setRefreshing(false);
  };

  if (loading) {
    return (
      <Card>
        <CardContent className="p-6">
          <div className="flex items-center justify-center">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
            <span className="ml-2">Cargando actividad reciente...</span>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle className="flex items-center gap-2">
              <Info className="w-5 h-5" />
              Actividad Reciente
            </CardTitle>
            <CardDescription>
              {cards.length === 0 ? 'No hay actividad reciente' : `√öltimas ${cards.length} actividades del sistema`}
            </CardDescription>
          </div>
          <Button
            variant="ghost"
            size="sm"
            onClick={handleRefresh}
            disabled={refreshing}
            className="h-8 w-8 p-0"
          >
            {refreshing ? (
              <Loader2 className="w-4 h-4 animate-spin" />
            ) : (
              <RefreshCw className="w-4 h-4" />
            )}
          </Button>
        </div>
      </CardHeader>
      <CardContent className="space-y-3">
        {cards.length === 0 ? (
          <div className="text-center py-6 text-muted-foreground">
            <Info className="w-8 h-8 mx-auto mb-2 opacity-50" />
            <p>No hay actividad registrada a√∫n</p>
            <p className="text-sm">Las nuevas actividades aparecer√°n aqu√≠ autom√°ticamente</p>
            <Button
              variant="outline"
              size="sm"
              onClick={handleRefresh}
              className="mt-3"
              disabled={refreshing}
            >
              {refreshing ? (
                <>
                  <Loader2 className="w-3 h-3 mr-2 animate-spin" />
                  Actualizando...
                </>
              ) : (
                <>
                  <RefreshCw className="w-3 h-3 mr-2" />
                  Buscar actividad
                </>
              )}
            </Button>
          </div>
        ) : (
          cards.map((card) => (
            <div
              key={card.id}
              className={`p-3 rounded-lg border-l-4 ${getCardColor(card.type)}`}
            >
              <div className="flex items-start justify-between">
                <div className="flex items-start gap-3 flex-1">
                  {getCardIcon(card.type)}
                  <div className="flex-1 min-w-0">
                    <p className="text-sm font-medium text-gray-900">
                      {card.message}
                    </p>
                    <p className="text-xs text-gray-500 mt-1">
                      {formatDistance(new Date(card.created_at), new Date(), {
                        addSuffix: true,
                        locale: es
                      })}
                    </p>
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  <Badge variant="secondary" className="text-xs">
                    Nuevo
                  </Badge>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-6 w-6 p-0"
                    onClick={() => markAsRead(card.id)}
                  >
                    <Eye className="w-3 h-3" />
                  </Button>
                </div>
              </div>
            </div>
          ))
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Dashboard/AmbassadorRanking.tsx">
import { useState, useEffect, useCallback } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { Trophy, RefreshCw, TrendingUp, Eye, MessageSquare, Award, Target } from "lucide-react";

interface AmbassadorRankingData {
  id: string;
  first_name: string;
  last_name: string;
  instagram_user: string | null;
  rank: number;
  global_points: number;
  global_category: string;
  events_participated: number;
  completed_tasks: number;
  failed_tasks: number;
  completion_rate: number;
  total_tasks: number;
}

export function AmbassadorRanking() {
  const { organization } = useCurrentOrganization();
  const [ranking, setRanking] = useState<AmbassadorRankingData[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const fetchRanking = useCallback(async () => {
    if (!organization?.id) return;

    try {
      setLoading(true);

      // Fetch ambassadors for the organization, ordered by global_points
      const { data: ambassadors, error: ambassadorsError } = await supabase
        .from('embassadors')
        .select('id, first_name, last_name, instagram_user, global_points, global_category, events_participated, completed_tasks, failed_tasks')
        .eq('organization_id', organization.id)
        .eq('status', 'active')
        .order('global_points', { ascending: false });

      if (ambassadorsError) {
        throw ambassadorsError;
      }

      if (!ambassadors || ambassadors.length === 0) {
        setRanking([]);
        return;
      }

      // Process and rank ambassadors
      const rankedAmbassadors: AmbassadorRankingData[] = ambassadors.map((ambassador, index) => {
        const totalTasks = (ambassador.completed_tasks || 0) + (ambassador.failed_tasks || 0);
        const completionRate = totalTasks > 0
          ? Math.round(((ambassador.completed_tasks || 0) / totalTasks) * 100)
          : 0;

        return {
          id: ambassador.id,
          first_name: ambassador.first_name,
          last_name: ambassador.last_name,
          instagram_user: ambassador.instagram_user,
          rank: index + 1,
          global_points: ambassador.global_points || 0,
          global_category: ambassador.global_category || 'bronze',
          events_participated: ambassador.events_participated || 0,
          completed_tasks: ambassador.completed_tasks || 0,
          failed_tasks: ambassador.failed_tasks || 0,
          completion_rate: completionRate,
          total_tasks: totalTasks
        };
      });

      setRanking(rankedAmbassadors);

    } catch (error) {
      console.error('Error fetching ambassador ranking:', error);
      toast.error('Error al cargar el ranking de embajadores');
    } finally {
      setLoading(false);
    }
  }, [organization?.id]);

  useEffect(() => {
    if (organization?.id) {
      fetchRanking();
    }
  }, [organization?.id, fetchRanking]);

  const handleRefresh = async () => {
    setRefreshing(true);
    await fetchRanking();
    setRefreshing(false);
    toast.success('Ranking actualizado');
  };

  const getRankBadge = (rank: number) => {
    if (rank === 1) {
      return <span className="text-3xl">ü•á</span>;
    } else if (rank === 2) {
      return <span className="text-3xl">ü•à</span>;
    } else if (rank === 3) {
      return <span className="text-3xl">ü•â</span>;
    }
    return <span className="text-muted-foreground font-medium">#{rank}</span>;
  };

  const getCategoryBadge = (category: string) => {
    const styles = {
      'bronze': 'bg-amber-100 text-amber-800 border-amber-300',
      'silver': 'bg-gray-100 text-gray-800 border-gray-300',
      'gold': 'bg-yellow-100 text-yellow-800 border-yellow-300',
      'diamond': 'bg-purple-100 text-purple-800 border-purple-300'
    };
    const style = styles[category as keyof typeof styles] || styles.bronze;
    return (
      <Badge variant="outline" className={style}>
        {category.charAt(0).toUpperCase() + category.slice(1)}
      </Badge>
    );
  };

  const formatNumber = (num: number) => {
    if (num >= 1000000) {
      return `${(num / 1000000).toFixed(1)}M`;
    } else if (num >= 1000) {
      return `${(num / 1000).toFixed(1)}K`;
    }
    return num.toString();
  };

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <div className="flex items-center gap-2">
          <Trophy className="h-5 w-5 text-yellow-500" />
          <CardTitle>Ranking de Embajadores</CardTitle>
        </div>
        <Button
          variant="outline"
          size="sm"
          onClick={handleRefresh}
          disabled={refreshing || loading}
        >
          <RefreshCw className={`h-4 w-4 mr-2 ${refreshing ? 'animate-spin' : ''}`} />
          Actualizar
        </Button>
      </CardHeader>
      <CardContent>
        {loading ? (
          <div className="text-center py-8 text-muted-foreground">
            Cargando ranking...
          </div>
        ) : ranking.length === 0 ? (
          <div className="text-center py-8 text-muted-foreground">
            <Trophy className="h-12 w-12 mx-auto mb-4 opacity-50" />
            <p>No hay embajadores activos en tu organizaci√≥n.</p>
            <p className="text-sm mt-2">
              Los embajadores aparecer√°n aqu√≠ cuando se registren y participen en eventos.
            </p>
          </div>
        ) : (
          <div className="overflow-x-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-16">Rank</TableHead>
                  <TableHead>Embajador</TableHead>
                  <TableHead className="text-right">
                    <div className="flex items-center justify-end gap-1">
                      <Award className="h-4 w-4" />
                      Puntos
                    </div>
                  </TableHead>
                  <TableHead className="text-center">Categor√≠a</TableHead>
                  <TableHead className="text-right">
                    <div className="flex items-center justify-end gap-1">
                      <Target className="h-4 w-4" />
                      Eventos
                    </div>
                  </TableHead>
                  <TableHead className="text-right">
                    <div className="flex items-center justify-end gap-1">
                      <MessageSquare className="h-4 w-4" />
                      Tareas
                    </div>
                  </TableHead>
                  <TableHead className="text-right">
                    <div className="flex items-center justify-end gap-1">
                      <TrendingUp className="h-4 w-4" />
                      Completaci√≥n
                    </div>
                  </TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {ranking.map((ambassador) => (
                  <TableRow key={ambassador.id}>
                    <TableCell>
                      {getRankBadge(ambassador.rank)}
                    </TableCell>
                    <TableCell>
                      <div>
                        <div className="font-medium">
                          {ambassador.first_name} {ambassador.last_name}
                        </div>
                        {ambassador.instagram_user && (
                          <div className="text-sm text-muted-foreground">
                            @{ambassador.instagram_user}
                          </div>
                        )}
                      </div>
                    </TableCell>
                    <TableCell className="text-right font-medium">
                      {formatNumber(ambassador.global_points)}
                    </TableCell>
                    <TableCell className="text-center">
                      {getCategoryBadge(ambassador.global_category)}
                    </TableCell>
                    <TableCell className="text-right">
                      {ambassador.events_participated}
                    </TableCell>
                    <TableCell className="text-right">
                      <div className="flex flex-col items-end">
                        <span className="font-medium">{ambassador.completed_tasks}</span>
                        <span className="text-xs text-muted-foreground">
                          / {ambassador.total_tasks} total
                        </span>
                      </div>
                    </TableCell>
                    <TableCell className="text-right">
                      <div className="flex items-center justify-end gap-1">
                        <span className={ambassador.completion_rate >= 80 ? 'text-green-600 font-medium' : ambassador.completion_rate >= 60 ? 'text-yellow-600' : 'text-red-600'}>
                          {ambassador.completion_rate}%
                        </span>
                      </div>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Dashboard/DashboardContent.tsx">
import { AlertCircle, Loader2 } from "lucide-react";
import { useUserProfile } from "@/hooks/useUserProfile";
import { ErrorBoundary } from "@/components/ErrorBoundary/ErrorBoundary";
import { EVABrandedDashboard } from "./EVABrandedDashboard";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { GlassPanel } from "@/components/Layout/GlassPanel";
import { PageHeader } from "@/components/Layout/PageHeader";

export default function DashboardContent() {
  const { profile, loading, error, retryFetch } = useUserProfile();

  if (loading) {
    return (
      <div className="space-y-6">
        <PageHeader 
          title="Dashboard EVA" 
          description="Cargando tu experiencia personalizada..."
        />
        <GlassPanel className="flex flex-col items-center justify-center min-h-[400px] space-y-4">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <p className="text-muted-foreground">Cargando tu perfil...</p>
        </GlassPanel>
      </div>
    );
  }

  if (error) {
    return (
      <div className="space-y-6">
        <PageHeader 
          title="Dashboard EVA" 
          description="Error al cargar el dashboard"
        />
        <GlassPanel className="max-w-md mx-auto">
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              {error}
            </AlertDescription>
          </Alert>
          <div className="mt-4 text-center">
            <Button onClick={retryFetch} variant="outline">
              Reintentar
            </Button>
          </div>
        </GlassPanel>
      </div>
    );
  }

  if (!profile) {
    return (
      <div className="space-y-6">
        <PageHeader 
          title="Dashboard EVA" 
          description="Configurando tu perfil"
        />
        <GlassPanel className="text-center py-12">
          <h2 className="text-2xl font-semibold mb-4">Perfil no encontrado</h2>
          <p className="text-muted-foreground mb-6">
            No se pudo cargar tu perfil. Por favor, contacta al soporte t√©cnico.
          </p>
          <Button onClick={retryFetch}>
            Reintentar
          </Button>
        </GlassPanel>
      </div>
    );
  }

  return (
    <ErrorBoundary>
      <EVABrandedDashboard />
    </ErrorBoundary>
  );
}
</file>

<file path="src/components/Dashboard/EnhancedDashboardContent.tsx">
import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { 
  PartyPopper,
  Users,
  Trophy,
  Target,
  TrendingUp,
  Calendar,
  Download,
  Filter
} from "lucide-react";
import { useUserProfile } from "@/hooks/useUserProfile";
import { useFiestas } from "@/hooks/useFiestas";
import { FiestaSelector } from "./FiestaSelector";
import { FiestaMetricsCard } from "./FiestaMetricsCard";
import { MetricCard } from "./MetricCard";

export default function EnhancedDashboardContent() {
  const { profile } = useUserProfile();
  const { fiestas, loading: fiestasLoading } = useFiestas();

  const handleExportReport = () => {
    console.log('Exportar reporte general');
  };

  if (fiestasLoading) {
    return (
      <div className="flex items-center justify-center p-8">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2 text-sm text-muted-foreground">Cargando dashboard...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="space-y-4">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
          <div>
            <h1 className="text-3xl font-bold tracking-tight flex items-center gap-2">
              <PartyPopper className="h-8 w-8 text-primary" />
              Dashboard de Fiestas
            </h1>
            <p className="text-lg text-muted-foreground">
              ¬°Bienvenido, {profile?.name || 'Usuario'}! Gestiona las m√©tricas de tus eventos
            </p>
          </div>
          <Button onClick={handleExportReport} variant="outline" className="gap-2">
            <Download className="h-4 w-4" />
            Exportar Reporte
          </Button>
        </div>
      </div>

      {/* Fiesta Cards Grid */}
      <div className="space-y-4">
        <h2 className="text-2xl font-semibold flex items-center gap-2">
          <Calendar className="h-6 w-6 text-primary" />
          Tus Fiestas
        </h2>
        
        {fiestas.length > 0 ? (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {fiestas.map((fiesta) => (
              <FiestaMetricsCard key={fiesta.id} fiesta={fiesta} />
            ))}
          </div>
        ) : (
          <Card>
            <CardContent className="flex flex-col items-center justify-center py-12">
              <PartyPopper className="h-12 w-12 text-muted-foreground mb-4" />
              <h3 className="text-lg font-semibold mb-2">¬°No hay fiestas a√∫n!</h3>
              <p className="text-muted-foreground text-center mb-4">
                Crea tu primera fiesta para empezar a gestionar embajadores y eventos.
              </p>
              <Button>
                Crear Primera Fiesta
              </Button>
            </CardContent>
          </Card>
        )}
      </div>

      {/* Quick Stats */}
      {fiestas.length > 0 && (
        <div className="space-y-4">
          <h2 className="text-xl font-semibold">Estad√≠sticas Generales</h2>
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
            <MetricCard
              title="Total Fiestas"
              value={fiestas.length.toString()}
              icon={<PartyPopper className="h-4 w-4" />}
              description="Fiestas creadas"
            />
            <MetricCard
              title="Fiestas Activas"
              value={fiestas.filter(f => f.status === 'active').length.toString()}
              icon={<Trophy className="h-4 w-4" />}
              description="En progreso actualmente"
            />
            <MetricCard
              title="Pr√≥ximas Fiestas"
              value={fiestas.filter(f => f.event_date && new Date(f.event_date) > new Date()).length.toString()}
              icon={<Calendar className="h-4 w-4" />}
              description="Programadas a futuro"
            />
            <MetricCard
              title="Completadas"
              value={fiestas.filter(f => f.status === 'completed').length.toString()}
              icon={<Target className="h-4 w-4" />}
              description="Finalizadas exitosamente"
            />
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/Dashboard/EVABrandedDashboard.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Instagram, Calendar, Users, Settings, CheckCircle, AlertCircle } from "lucide-react";
import { useNavigate } from "react-router-dom";
import { useOnboardingStatus } from "@/hooks/useOnboardingStatus";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { SimpleDashboardContent } from "./SimpleDashboardContent";

export function EVABrandedDashboard() {
  const navigate = useNavigate();
  const { steps, overallProgress } = useOnboardingStatus();
  const { organization } = useCurrentOrganization();

  // Filtrar pasos recomendados que no est√°n completados
  const pendingRecommendedSteps = steps.filter(step => !step.required && !step.completed);

  return (
    <div className="space-y-6">
      {/* Banner de onboarding para pasos recomendados pendientes */}
      {pendingRecommendedSteps.length > 0 && (
        <Card className="border-blue-200 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900/20 dark:to-indigo-900/20">
          <CardHeader className="pb-3">
            <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
              <div className="flex-1">
                <CardTitle className="flex items-center gap-2 text-blue-800 dark:text-blue-400">
                  <AlertCircle className="h-5 w-5" />
                  Completa la configuraci√≥n de tu sistema
                </CardTitle>
                <CardDescription className="text-blue-600 dark:text-blue-500">
                  Tienes {pendingRecommendedSteps.length} paso{pendingRecommendedSteps.length !== 1 ? 's' : ''} recomendado{pendingRecommendedSteps.length !== 1 ? 's' : ''} pendiente{pendingRecommendedSteps.length !== 1 ? 's' : ''} para aprovechar al m√°ximo EVA System
                </CardDescription>
              </div>
              <Button 
                onClick={() => navigate('/onboarding')}
                className="gap-2 w-full sm:w-auto text-sm sm:text-base shrink-0"
              >
                <Settings className="h-4 w-4" />
                <span className="hidden sm:inline">Completar Configuraci√≥n</span>
                <span className="sm:hidden">Completar</span>
              </Button>
            </div>
          </CardHeader>
          <CardContent>
            <div className="flex flex-wrap gap-2">
              {pendingRecommendedSteps.map((step) => {
                const getStepInfo = (stepId: string) => {
                  switch (stepId) {
                    case 'instagram':
                      return { 
                        icon: Instagram, 
                        label: 'Conectar Instagram',
                        action: () => navigate('/settings')
                      };
                    case 'fiesta':
                      return { 
                        icon: Calendar, 
                        label: 'Crear Primera Fiesta',
                        action: () => navigate('/events')
                      };
                    case 'ambassadors':
                      return { 
                        icon: Users, 
                        label: 'A√±adir Embajadores',
                        action: () => navigate('/ambassadors')
                      };
                    default:
                      return { icon: AlertCircle, label: step.title, action: () => {} };
                  }
                };

                const stepInfo = getStepInfo(step.id);
                const Icon = stepInfo.icon;

                return (
                  <Button
                    key={step.id}
                    variant="outline"
                    size="sm"
                    onClick={stepInfo.action}
                    className="gap-2"
                  >
                    <Icon className="h-4 w-4" />
                    {stepInfo.label}
                  </Button>
                );
              })}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Indicador de progreso general */}
      {overallProgress < 100 && (
        <Card>
          <CardHeader className="pb-3">
            <div className="flex items-center justify-between">
              <div>
                <CardTitle className="text-lg">Progreso de Configuraci√≥n</CardTitle>
                <CardDescription>
                  {Math.round(overallProgress)}% completado
                </CardDescription>
              </div>
              <Badge variant={overallProgress === 100 ? "default" : "secondary"}>
                {Math.round(overallProgress)}%
              </Badge>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2 dark:bg-gray-800">
              <div 
                className="bg-gradient-to-r from-blue-500 to-indigo-600 h-2 rounded-full transition-all duration-300"
                style={{ width: `${overallProgress}%` }}
              />
            </div>
          </CardHeader>
        </Card>
      )}

      {/* Confirmaci√≥n cuando todo est√© completo */}
      {overallProgress === 100 && (
        <Card className="border-green-200 bg-green-50 dark:bg-green-900/20">
          <CardContent className="p-4">
            <div className="flex items-center gap-3">
              <CheckCircle className="h-5 w-5 text-green-600" />
              <div>
                <p className="font-medium text-green-800 dark:text-green-400">
                  ¬°Configuraci√≥n completa!
                </p>
                <p className="text-sm text-green-600 dark:text-green-500">
                  Tu sistema EVA est√° completamente configurado y listo para usar
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Dashboard principal */}
      <SimpleDashboardContent />
    </div>
  );
}
</file>

<file path="src/components/Dashboard/EventDashboard.tsx">
import { useState, useEffect } from "react";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { 
  Calendar, 
  Users, 
  TrendingUp, 
  Star, 
  Download, 
  Instagram, 
  BarChart3,
  Trophy,
  Target,
  DollarSign,
  Clock
} from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";
import { format } from "date-fns";
import { es } from "date-fns/locale";
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, LineChart, Line, PieChart, Pie, Cell } from 'recharts';

interface SimpleEvent {
  id: string;
  name: string;
  description: string;
  location: string;
  event_date: string;
  active: boolean;
  organization_id: string;
  created_at: string;
}

interface EventStats {
  total_mentions: number;
  total_stories: number;
  total_points: number;
  total_reach: number;
  active_ambassadors: number;
  completion_rate: number;
  top_ambassadors: Array<{
    id: string;
    name: string;
    points: number;
    category: string;
    instagram_user: string;
  }>;
  daily_performance: Array<{
    date: string;
    mentions: number;
    stories: number;
    reach: number;
  }>;
}

interface EventDashboardProps {
  selectedEventId?: string;
  onEventChange?: (eventId: string) => void;
}

export function EventDashboard({ selectedEventId, onEventChange }: EventDashboardProps) {
  const { organization } = useCurrentOrganization();
  const [events, setEvents] = useState<SimpleEvent[]>([]);
  const [selectedEvent, setSelectedEvent] = useState<SimpleEvent | null>(null);
  const [eventStats, setEventStats] = useState<EventStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [period, setPeriod] = useState("7d");
  const { toast } = useToast();

  useEffect(() => {
    fetchEvents();
  }, []);

  useEffect(() => {
    if (selectedEventId && events.length > 0) {
      const event = events.find(e => e.id === selectedEventId);
      if (event) {
        setSelectedEvent(event);
        fetchEventStats(event.id);
      }
    }
  }, [selectedEventId, events]);

  const fetchEvents = async () => {
    try {
      const { data, error } = await supabase
        .from('fiestas')
        .select('id, name, description, event_date, location, status, created_at')
        .order('created_at', { ascending: false });

      if (error) throw error;
      setEvents(data?.map(f => ({
        id: f.id,
        name: f.name,
        description: f.description || '',
        location: f.location || '',
        event_date: f.event_date || f.created_at,
        active: f.status === 'active',
        organization_id: '', // Not needed anymore
        created_at: f.created_at
      })) || []);
      
      if (data && data.length > 0 && !selectedEventId) {
        const activeEvent = data.find(e => e.status === 'active') || data[0];
        const mappedEvent = {
          id: activeEvent.id,
          name: activeEvent.name,
          description: activeEvent.description || '',
          location: activeEvent.location || '',
          event_date: activeEvent.event_date || activeEvent.created_at,
          active: activeEvent.status === 'active',
          organization_id: '',
          created_at: activeEvent.created_at
        };
        setSelectedEvent(mappedEvent);
        fetchEventStats(activeEvent.id);
        onEventChange?.(activeEvent.id);
      }
    } catch (error) {
      console.error('Error fetching events:', error);
      toast({
        title: "Error",
        description: "No se pudieron cargar los eventos",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const calculateParticipationStats = async () => {
    if (!organization?.id) return { total_ambassadors: 0, active_ambassadors: 0, completion_rate: 0, pending_tasks: 0 };

    const { count: totalAmbassadors } = await supabase
      .from('embassadors')
      .select('*', { count: 'exact', head: true })
      .eq('organization_id', organization.id);

    const { count: activeAmbassadors } = await supabase
      .from('embassadors')
      .select('*', { count: 'exact', head: true })
      .eq('organization_id', organization.id)
      .eq('status', 'active');

    const { data: ambassadors } = await supabase
      .from('embassadors')
      .select('id, completed_tasks, failed_tasks')
      .eq('organization_id', organization.id);

    const totalCompleted = ambassadors?.reduce((sum, amb) => sum + (amb.completed_tasks || 0), 0) || 0;
    const totalFailed = ambassadors?.reduce((sum, amb) => sum + (amb.failed_tasks || 0), 0) || 0;
    const totalTasks = totalCompleted + totalFailed;

    const { count: pendingTasks } = await supabase
      .from('tasks')
      .select('*', { count: 'exact', head: true })
      .in('embassador_id', ambassadors?.map(a => a.id) || [])
      .in('status', ['pending', 'uploaded', 'in_progress']);

    return {
      total_ambassadors: totalAmbassadors || 0,
      active_ambassadors: activeAmbassadors || 0,
      completion_rate: totalTasks > 0 ? Math.round((totalCompleted / totalTasks) * 100) : 0,
      pending_tasks: pendingTasks || 0
    };
  };

  const calculateMetrics = async () => {
    if (!organization?.id) return { total_reach: 0, total_mentions: 0, average_engagement: 0, success_rate: 0 };

    const { data: ambassadors } = await supabase
      .from('embassadors')
      .select('id, completed_tasks, failed_tasks')
      .eq('organization_id', organization.id);

    const { data: tasks } = await supabase
      .from('tasks')
      .select('reach_count, engagement_score, status')
      .in('embassador_id', ambassadors?.map(a => a.id) || []);

    const totalReach = tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;
    const totalMentions = tasks?.length || 0;
    const totalEngagement = tasks?.reduce((sum, t) => sum + (t.engagement_score || 0), 0) || 0;
    const completedTasks = tasks?.filter(t => t.status === 'completed').length || 0;

    return {
      total_reach: totalReach,
      total_mentions: totalMentions,
      average_engagement: totalMentions > 0 ? Number((totalEngagement / totalMentions).toFixed(1)) : 0,
      success_rate: totalMentions > 0 ? Math.round((completedTasks / totalMentions) * 100) : 0
    };
  };

  const fetchRecentActivities = async () => {
    if (!organization?.id) return [];

    const { data: recentTasks } = await supabase
      .from('tasks')
      .select('id, status, last_status_update, embassadors(first_name, last_name)')
      .in('embassador_id', await getAmbassadorIds())
      .order('last_status_update', { ascending: false })
      .limit(5);

    return recentTasks?.map(task => ({
      id: task.id,
      type: task.status === 'completed' ? 'success' : 'info',
      message: `Tarea ${task.status} por ${(task.embassadors as any)?.first_name} ${(task.embassadors as any)?.last_name}`,
      timestamp: task.last_status_update || new Date().toISOString()
    })) || [];
  };

  const getAmbassadorIds = async () => {
    const { data: ambassadors } = await supabase
      .from('embassadors')
      .select('id')
      .eq('organization_id', organization?.id || '');
    return ambassadors?.map(a => a.id) || [];
  };

  const fetchRealEventStats = async (eventId: string): Promise<EventStats> => {
    try {
      if (!organization?.id) {
        return {
          total_mentions: 0,
          total_stories: 0,
          total_points: 0,
          total_reach: 0,
          active_ambassadors: 0,
          completion_rate: 0,
          top_ambassadors: [],
          daily_performance: []
        };
      }

      // Get ambassadors for this organization
      const { data: ambassadors } = await supabase
        .from('embassadors')
        .select('id, first_name, last_name, instagram_user, global_points, global_category')
        .eq('organization_id', organization.id)
        .eq('status', 'active');

      if (!ambassadors || ambassadors.length === 0) {
        return {
          total_mentions: 0,
          total_stories: 0,
          total_points: 0,
          total_reach: 0,
          active_ambassadors: 0,
          completion_rate: 0,
          top_ambassadors: [],
          daily_performance: []
        };
      }

      // Get events for this fiesta
      const { data: events } = await supabase
        .from('events')
        .select('id')
        .eq('fiesta_id', eventId);

      const eventIds = events?.map(e => e.id) || [];

      // Get tasks for these events
      const { data: tasks } = await supabase
        .from('tasks')
        .select('id, event_id, embassador_id, status, points_earned, engagement_score, reach_count, verified_through_api, instagram_story_id, task_type, platform, completion_method, upload_time, expiry_time, story_url, expected_hashtag, last_status_update, created_at')
        .in('event_id', eventIds)
        .in('embassador_id', ambassadors.map(a => a.id));

      // Calculate metrics
      const totalMentions = tasks?.length || 0;
      const totalStories = tasks?.filter(t => t.task_type === 'story').length || 0;
      const totalReach = tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;
      const totalPoints = tasks?.reduce((sum, t) => sum + (t.points_earned || 0), 0) || 0;
      const completedTasks = tasks?.filter(t => t.status === 'completed').length || 0;
      const completionRate = totalMentions > 0 ? Math.round((completedTasks / totalMentions) * 100) : 0;

      // Get top ambassadors (sort by points)
      const topAmbassadors = ambassadors
        .sort((a, b) => (b.global_points || 0) - (a.global_points || 0))
        .slice(0, 3)
        .map(amb => ({
          id: amb.id,
          name: `${amb.first_name} ${amb.last_name}`,
          points: amb.global_points || 0,
          category: amb.global_category || 'bronze',
          instagram_user: amb.instagram_user
        }));

      // Generate daily performance for last 7 days
      const dailyPerformance = [];
      for (let i = 6; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        
        const dailyTasks = tasks?.filter(t => 
          t.created_at && t.created_at.startsWith(dateStr)
        ) || [];

        dailyPerformance.push({
          date: format(date, 'dd/MM'),
          mentions: dailyTasks.length,
          stories: dailyTasks.filter(t => t.task_type === 'story').length,
          reach: dailyTasks.reduce((sum, t) => sum + (t.reach_count || 0), 0)
        });
      }

      return {
        total_mentions: totalMentions,
        total_stories: totalStories,
        total_points: totalPoints,
        total_reach: totalReach,
        active_ambassadors: ambassadors.length,
        completion_rate: completionRate,
        top_ambassadors: topAmbassadors,
        daily_performance: dailyPerformance
      };
    } catch (error) {
      console.error('Error fetching real event stats:', error);
      return {
        total_mentions: 0,
        total_stories: 0,
        total_points: 0,
        total_reach: 0,
        active_ambassadors: 0,
        completion_rate: 0,
        top_ambassadors: [],
        daily_performance: []
      };
    }
  };

  const fetchEventStats = async (eventId: string) => {
    try {
      const realStats = await fetchRealEventStats(eventId);
      setEventStats(realStats);
    } catch (error) {
      console.error('Error fetching event stats:', error);
    }
  };

  const handleEventChange = (eventId: string) => {
    const event = events.find(e => e.id === eventId);
    if (event) {
      setSelectedEvent(event);
      fetchEventStats(eventId);
      onEventChange?.(eventId);
    }
  };

  const exportEventReport = async () => {
    try {
      // Aqu√≠ implementar√≠amos la l√≥gica de exportaci√≥n
      toast({
        title: "√âxito",
        description: "Reporte exportado correctamente",
      });
    } catch (error) {
      toast({
        title: "Error",
        description: "No se pudo exportar el reporte",
        variant: "destructive",
      });
    }
  };

  const getCategoryBadge = (category: string) => {
    const colors = {
      bronze: "bg-amber-100 text-amber-800 border-amber-200",
      silver: "bg-gray-100 text-gray-800 border-gray-200",
      gold: "bg-yellow-100 text-yellow-800 border-yellow-200",
      diamond: "bg-blue-100 text-blue-800 border-blue-200"
    };
    return colors[category as keyof typeof colors] || colors.bronze;
  };

  if (loading) {
    return (
      <div className="space-y-6">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-center">
              <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (!selectedEvent || !eventStats) {
    return (
      <Card>
        <CardContent className="p-6">
          <div className="text-center text-muted-foreground">
            <Calendar className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>Selecciona un evento para ver el dashboard</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  const performanceDistribution = [
    { name: 'Cumple', value: 65, color: '#10b981' },
    { name: 'Advertencia', value: 25, color: '#f59e0b' },
    { name: 'No Cumple', value: 10, color: '#ef4444' }
  ];

  return (
    <div className="space-y-6">
      {/* Header del Evento */}
      <Card>
        <CardHeader>
          <div className="flex items-start justify-between">
            <div className="flex-1">
              <div className="flex items-center gap-3 mb-2">
                <CardTitle className="text-2xl">{selectedEvent.name}</CardTitle>
                {selectedEvent.active && (
                  <Badge variant="default">Activo</Badge>
                )}
              </div>
              <CardDescription className="text-base mb-4">
                {selectedEvent.description}
              </CardDescription>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                {selectedEvent.location && (
                  <div className="flex items-center gap-2">
                    <Users className="h-4 w-4 text-muted-foreground" />
                    <span className="text-muted-foreground">Ubicaci√≥n:</span>
                    <span className="font-medium">{selectedEvent.location}</span>
                  </div>
                )}
                <div className="flex items-center gap-2">
                  <Calendar className="h-4 w-4 text-muted-foreground" />
                  <span className="text-muted-foreground">Fecha:</span>
                  <span className="font-medium">
                    {format(new Date(selectedEvent.event_date), "PPP", { locale: es })}
                  </span>
                </div>
              </div>
            </div>
            <div className="flex items-center gap-2">
              <Select value={selectedEvent.id} onValueChange={handleEventChange}>
                <SelectTrigger className="w-[250px]">
                  <SelectValue placeholder="Seleccionar evento" />
                </SelectTrigger>
                <SelectContent>
                  {events.map((event) => (
                    <SelectItem key={event.id} value={event.id}>
                      {event.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <Button onClick={exportEventReport}>
                <Download className="h-4 w-4 mr-2" />
                Exportar
              </Button>
            </div>
          </div>
        </CardHeader>
      </Card>

      {/* KPIs del Evento */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-muted-foreground">Total Menciones</p>
                <p className="text-2xl font-bold">{eventStats.total_mentions}</p>
              </div>
              <Instagram className="h-8 w-8 text-muted-foreground" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-muted-foreground">Historias</p>
                <p className="text-2xl font-bold">{eventStats.total_stories}</p>
              </div>
              <BarChart3 className="h-8 w-8 text-muted-foreground" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-muted-foreground">Alcance Total</p>
                <p className="text-2xl font-bold">{eventStats.total_reach.toLocaleString()}</p>
              </div>
              <TrendingUp className="h-8 w-8 text-muted-foreground" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-muted-foreground">Tasa Completitud</p>
                <p className="text-2xl font-bold">{eventStats.completion_rate}%</p>
              </div>
              <Trophy className="h-8 w-8 text-muted-foreground" />
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Tabs de An√°lisis */}
      <Tabs defaultValue="overview" className="space-y-4">
        <TabsList>
          <TabsTrigger value="overview">Resumen</TabsTrigger>
          <TabsTrigger value="performance">Rendimiento</TabsTrigger>
          <TabsTrigger value="ambassadors">Top Embajadores</TabsTrigger>
          <TabsTrigger value="trends">Tendencias</TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-4">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <Card>
              <CardHeader>
                <CardTitle>Rendimiento Diario</CardTitle>
              </CardHeader>
              <CardContent>
                <ResponsiveContainer width="100%" height={300}>
                  <BarChart data={eventStats.daily_performance}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="date" />
                    <YAxis />
                    <Tooltip />
                    <Bar dataKey="mentions" fill="#8884d8" name="Menciones" />
                    <Bar dataKey="stories" fill="#82ca9d" name="Historias" />
                  </BarChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle>Distribuci√≥n de Performance</CardTitle>
              </CardHeader>
              <CardContent>
                <ResponsiveContainer width="100%" height={300}>
                  <PieChart>
                    <Pie
                      data={performanceDistribution}
                      cx="50%"
                      cy="50%"
                      innerRadius={60}
                      outerRadius={120}
                      paddingAngle={5}
                      dataKey="value"
                    >
                      {performanceDistribution.map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={entry.color} />
                      ))}
                    </Pie>
                    <Tooltip />
                  </PieChart>
                </ResponsiveContainer>
                <div className="flex justify-center gap-4 mt-4">
                  {performanceDistribution.map((item) => (
                    <div key={item.name} className="flex items-center gap-2">
                      <div 
                        className="w-3 h-3 rounded-full" 
                        style={{ backgroundColor: item.color }}
                      ></div>
                      <span className="text-sm">{item.name} ({item.value}%)</span>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          </div>
        </TabsContent>

        <TabsContent value="ambassadors">
          <Card>
            <CardHeader>
              <CardTitle>Top Embajadores del Evento</CardTitle>
              <CardDescription>Los embajadores con mejor performance en este evento</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {eventStats.top_ambassadors.map((ambassador, index) => (
                  <div key={ambassador.id} className="flex items-center justify-between p-4 border rounded-lg">
                    <div className="flex items-center gap-4">
                      <div className="flex items-center justify-center w-8 h-8 rounded-full bg-primary text-primary-foreground font-bold">
                        {index + 1}
                      </div>
                      <Avatar>
                        <AvatarFallback>{ambassador.name.split(' ').map(n => n[0]).join('')}</AvatarFallback>
                      </Avatar>
                      <div>
                        <p className="font-medium">{ambassador.name}</p>
                        <p className="text-sm text-muted-foreground">{ambassador.instagram_user}</p>
                      </div>
                    </div>
                    <div className="flex items-center gap-4">
                      <Badge className={getCategoryBadge(ambassador.category)}>
                        {ambassador.category.charAt(0).toUpperCase() + ambassador.category.slice(1)}
                      </Badge>
                      <div className="text-right">
                        <p className="font-bold">{ambassador.points} pts</p>
                        <p className="text-sm text-muted-foreground">puntos</p>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="trends">
          <Card>
            <CardHeader>
              <CardTitle>Evoluci√≥n del Alcance</CardTitle>
              <CardDescription>Tendencia de menciones y alcance en los √∫ltimos d√≠as</CardDescription>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={400}>
                <LineChart data={eventStats.daily_performance}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="date" />
                  <YAxis />
                  <Tooltip />
                  <Line 
                    type="monotone" 
                    dataKey="reach" 
                    stroke="#8884d8" 
                    strokeWidth={2}
                    name="Alcance"
                  />
                  <Line 
                    type="monotone" 
                    dataKey="mentions" 
                    stroke="#82ca9d" 
                    strokeWidth={2}
                    name="Menciones"
                  />
                </LineChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/components/Dashboard/FiestaMetricsCard.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { 
  Calendar,
  Users,
  Trophy,
  TrendingUp,
  Eye,
  CheckCircle,
  Clock,
  XCircle,
  Settings
} from "lucide-react";
import { useFiestaMetrics } from "@/hooks/useFiestaMetrics";
import { MetricCard } from "./MetricCard";

interface FiestaMetricsCardProps {
  fiesta: {
    id: string;
    name: string;
    event_date?: string;
    description?: string;
    status: string;
  };
}

export function FiestaMetricsCard({ fiesta }: FiestaMetricsCardProps) {
  const { metrics, loading } = useFiestaMetrics(fiesta.id);

  if (loading) {
    return (
      <Card className="shadow-card hover:shadow-elegant transition-all duration-300">
        <CardContent className="p-6">
          <div className="animate-pulse space-y-3">
            <div className="h-4 bg-muted rounded w-3/4" />
            <div className="h-8 bg-muted rounded w-1/2" />
            <div className="grid grid-cols-3 gap-2">
              <div className="h-12 bg-muted rounded" />
              <div className="h-12 bg-muted rounded" />
              <div className="h-12 bg-muted rounded" />
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  const getStatusBadge = (status: string) => {
    const styles = {
      'active': 'bg-success/10 text-success',
      'completed': 'bg-blue-100 text-blue-800',
      'draft': 'bg-gray-100 text-gray-800',
    };
    return styles[status as keyof typeof styles] || styles.active;
  };

  return (
    <Card className="shadow-card hover:shadow-elegant transition-all duration-300 group">
      <CardHeader className="pb-3">
        <div className="flex items-center justify-between">
          <div>
            <CardTitle className="text-lg font-semibold">{fiesta.name}</CardTitle>
            <div className="flex items-center gap-2 mt-1">
              <Badge className={getStatusBadge(fiesta.status)}>
                {fiesta.status === 'active' ? 'Activa' : 
                 fiesta.status === 'completed' ? 'Completada' : 'Borrador'}
              </Badge>
              {fiesta.event_date && (
                <span className="text-sm text-muted-foreground flex items-center gap-1">
                  <Calendar className="w-3 h-3" />
                  {new Date(fiesta.event_date).toLocaleDateString()}
                </span>
              )}
            </div>
          </div>
          
          <Dialog>
            <DialogTrigger asChild>
              <Button variant="ghost" size="sm" className="opacity-0 group-hover:opacity-100 transition-opacity">
                <Eye className="w-4 h-4" />
              </Button>
            </DialogTrigger>
            <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle className="text-2xl">
                  {fiesta.name} - Detalles Completos
                </DialogTitle>
              </DialogHeader>
              
              <Tabs defaultValue="overview" className="space-y-6">
                <TabsList className="grid w-full grid-cols-4">
                  <TabsTrigger value="overview">Resumen</TabsTrigger>
                  <TabsTrigger value="ambassadors">Embajadores</TabsTrigger>
                  <TabsTrigger value="events">Eventos</TabsTrigger>
                  <TabsTrigger value="metrics">M√©tricas</TabsTrigger>
                </TabsList>

                <TabsContent value="overview" className="space-y-4">
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <MetricCard
                      title="Embajadores"
                      value={metrics?.total_ambassadors || 0}
                      icon={<Users className="w-4 h-4" />}
                    />
                    <MetricCard
                      title="Tareas Completadas"
                      value={metrics?.completed_tasks || 0}
                      icon={<CheckCircle className="w-4 h-4" />}
                    />
                    <MetricCard
                      title="Alcance Total"
                      value={`${((metrics?.total_reach || 0) / 1000).toFixed(1)}K`}
                      icon={<TrendingUp className="w-4 h-4" />}
                    />
                    <MetricCard
                      title="Tasa Completitud"
                      value={`${metrics?.completion_rate || 0}%`}
                      icon={<Trophy className="w-4 h-4" />}
                    />
                  </div>
                  
                  {fiesta.description && (
                    <Card>
                      <CardHeader>
                        <CardTitle className="text-lg">Descripci√≥n</CardTitle>
                      </CardHeader>
                      <CardContent>
                        <p className="text-muted-foreground">{fiesta.description}</p>
                      </CardContent>
                    </Card>
                  )}
                </TabsContent>

                <TabsContent value="ambassadors" className="space-y-4">
                  <div className="space-y-3">
                    {metrics?.top_ambassadors?.slice(0, 10).map((ambassador, index) => (
                      <div key={ambassador.id} className="flex items-center justify-between p-3 rounded-lg border">
                        <div className="flex items-center gap-3">
                          <div className="w-8 h-8 rounded-full bg-gradient-primary flex items-center justify-center text-primary-foreground font-bold text-sm">
                            {index + 1}
                          </div>
                          <Avatar className="w-8 h-8">
                            <AvatarFallback>{ambassador.name.charAt(0)}</AvatarFallback>
                          </Avatar>
                          <div>
                            <p className="font-medium">{ambassador.name}</p>
                            <p className="text-sm text-muted-foreground">
                              {ambassador.tasks_completed} tareas completadas
                            </p>
                          </div>
                        </div>
                        <div className="text-right">
                          <div className="font-bold text-primary">{ambassador.points}</div>
                          <div className="text-xs text-muted-foreground">puntos</div>
                        </div>
                      </div>
                    ))}
                  </div>
                </TabsContent>

                <TabsContent value="events" className="space-y-4">
                  <div className="text-center text-muted-foreground py-8">
                    <Calendar className="w-12 h-12 mx-auto mb-2 opacity-50" />
                    <p>Gesti√≥n de eventos en desarrollo</p>
                  </div>
                </TabsContent>

                <TabsContent value="metrics" className="space-y-4">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <Card>
                      <CardHeader>
                        <CardTitle className="text-lg">Distribuci√≥n de Tareas</CardTitle>
                      </CardHeader>
                      <CardContent>
                        <div className="space-y-2">
                          <div className="flex justify-between">
                            <span className="flex items-center gap-2">
                              <CheckCircle className="w-4 h-4 text-success" />
                              Completadas
                            </span>
                            <span className="font-medium">{metrics?.completed_tasks || 0}</span>
                          </div>
                          <div className="flex justify-between">
                            <span className="flex items-center gap-2">
                              <Clock className="w-4 h-4 text-warning" />
                              Pendientes
                            </span>
                            <span className="font-medium">{metrics?.pending_tasks || 0}</span>
                          </div>
                          <div className="flex justify-between">
                            <span className="flex items-center gap-2">
                              <XCircle className="w-4 h-4 text-destructive" />
                              Inv√°lidas
                            </span>
                            <span className="font-medium">{metrics?.invalid_tasks || 0}</span>
                          </div>
                        </div>
                      </CardContent>
                    </Card>

                    <Card>
                      <CardHeader>
                        <CardTitle className="text-lg">M√©tricas de Alcance</CardTitle>
                      </CardHeader>
                      <CardContent>
                        <div className="space-y-3">
                          <div className="text-center">
                            <div className="text-3xl font-bold text-primary">
                              {((metrics?.total_reach || 0) / 1000000).toFixed(1)}M
                            </div>
                            <div className="text-sm text-muted-foreground">Alcance Total</div>
                          </div>
                          <div className="text-center">
                            <div className="text-2xl font-bold text-secondary">
                              {metrics?.avg_engagement?.toFixed(1) || 0}%
                            </div>
                            <div className="text-sm text-muted-foreground">Engagement Promedio</div>
                          </div>
                        </div>
                      </CardContent>
                    </Card>
                  </div>
                </TabsContent>
              </Tabs>
            </DialogContent>
          </Dialog>
        </div>
      </CardHeader>
      
      <CardContent className="pt-0">
        <div className="grid grid-cols-3 gap-3">
          <div className="text-center p-3 rounded-lg bg-accent/20">
            <div className="flex items-center justify-center mb-1">
              <Users className="w-4 h-4 text-primary" />
            </div>
            <div className="text-lg font-bold">{metrics?.total_ambassadors || 0}</div>
            <div className="text-xs text-muted-foreground">Embajadores</div>
          </div>
          
          <div className="text-center p-3 rounded-lg bg-accent/20">
            <div className="flex items-center justify-center mb-1">
              <CheckCircle className="w-4 h-4 text-success" />
            </div>
            <div className="text-lg font-bold">{metrics?.completed_tasks || 0}</div>
            <div className="text-xs text-muted-foreground">Completadas</div>
          </div>
          
          <div className="text-center p-3 rounded-lg bg-accent/20">
            <div className="flex items-center justify-center mb-1">
              <TrendingUp className="w-4 h-4 text-secondary" />
            </div>
            <div className="text-lg font-bold">
              {((metrics?.total_reach || 0) / 1000).toFixed(0)}K
            </div>
            <div className="text-xs text-muted-foreground">Alcance</div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Dashboard/FiestaSelector.tsx">
import { useState, useEffect } from "react";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Card, CardContent } from "@/components/ui/card";
import { PartyPopper, Calendar } from "lucide-react";
import { useFiestas } from "@/hooks/useFiestas";

interface FiestaSelectorProps {
  onFiestaChange: (fiestaId: string | null) => void;
  selectedFiestaId: string | null;
}

export function FiestaSelector({ onFiestaChange, selectedFiestaId }: FiestaSelectorProps) {
  const { fiestas, loading } = useFiestas();

  if (loading) {
    return (
      <Card>
        <CardContent className="p-4">
          <div className="animate-pulse h-10 bg-muted rounded"></div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardContent className="p-4">
        <div className="flex items-center gap-3">
          <PartyPopper className="h-5 w-5 text-primary" />
          <div className="flex-1">
            <Select value={selectedFiestaId || "all"} onValueChange={(value) => onFiestaChange(value === "all" ? null : value)}>
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Seleccionar fiesta..." />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">
                  <div className="flex items-center gap-2">
                    <Calendar className="h-4 w-4" />
                    Todas las fiestas
                  </div>
                </SelectItem>
                {fiestas.map((fiesta) => (
                  <SelectItem key={fiesta.id} value={fiesta.id}>
                    <div className="flex items-center gap-2">
                      <PartyPopper className="h-4 w-4" />
                      <div>
                        <p className="font-medium">{fiesta.name}</p>
                        {fiesta.event_date && (
                          <p className="text-xs text-muted-foreground">
                            {new Date(fiesta.event_date).toLocaleDateString('es-ES')}
                          </p>
                        )}
                      </div>
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Dashboard/MetricCard.tsx">
import { ReactNode } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { cn } from "@/lib/utils";

interface MetricCardProps {
  title: string;
  value: string | number;
  description?: string;
  icon?: ReactNode;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
}

export function MetricCard({
  title,
  value,
  description,
  icon,
  trend,
  className
}: MetricCardProps) {
  return (
    <Card className={cn("shadow-card hover:shadow-elegant transition-all duration-300", className)}>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium text-muted-foreground">
          {title}
        </CardTitle>
        {icon && (
          <div className="text-primary">
            {icon}
          </div>
        )}
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold bg-gradient-primary bg-clip-text text-transparent">
          {value}
        </div>
        {description && (
          <p className="text-xs text-muted-foreground mt-1">
            {description}
          </p>
        )}
        {trend && (
          <div className={cn(
            "text-xs mt-2 flex items-center",
            trend.isPositive ? "text-success" : "text-destructive"
          )}>
            <span className={cn(
              "mr-1",
              trend.isPositive ? "text-success" : "text-destructive"
            )}>
              {trend.isPositive ? "‚Üó" : "‚Üò"}
            </span>
            {trend.value}% vs mes anterior
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Dashboard/SimpleEventDashboard.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Calendar, MapPin, Users, Plus } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useAuth } from "@/hooks/useAuth";
import { toast } from "sonner";
import { format } from "date-fns";
import { es } from "date-fns/locale";

interface SimpleEvent {
  id: string;
  event_date: string;
  active: boolean;
  created_at: string;
  created_by_user_id: string;
  end_date: string;
  fiesta_id: string;
  start_date: string;
  fiestas?: {
    name: string;
    description: string;
    location: string;
  };
}

interface SimpleEventDashboardProps {
  onCreateEvent?: () => void;
}

export function SimpleEventDashboard({ onCreateEvent }: SimpleEventDashboardProps) {
  const { user } = useAuth();
  const [events, setEvents] = useState<SimpleEvent[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (user) {
      fetchEvents();
    }
  }, [user]);

  const fetchEvents = async () => {
    try {
      setLoading(true);

      // Primero obtener las organizaciones del usuario
      const { data: organizations, error: orgError } = await supabase
        .from('organizations')
        .select('id')
        .eq('created_by', user!.id);

      if (orgError) throw orgError;

      if (!organizations || organizations.length === 0) {
        setEvents([]);
        return;
      }

      const organizationIds = organizations.map(org => org.id);

      // Obtener eventos de las organizaciones del usuario
      const { data: eventsData, error: eventsError } = await supabase
        .from('events')
        .select(`
          *,
          fiestas (
            name,
            description,
            location
          )
        `)
        .eq('fiestas.organization_id', organizationIds[0])
        .order('event_date', { ascending: false });

      if (eventsError) throw eventsError;

      setEvents(eventsData || []);
    } catch (error) {
      console.error('Error fetching events:', error);
      toast.error('Error al cargar eventos');
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <Card>
        <CardContent className="p-6">
          <div className="flex items-center justify-center">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
            <span className="ml-2">Cargando eventos...</span>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle className="flex items-center gap-2">
              <Calendar className="h-5 w-5" />
              Eventos Recientes
            </CardTitle>
            <CardDescription>
              {events.length === 0 ? 'No hay eventos creados' : `${events.length} evento(s) registrado(s)`}
            </CardDescription>
          </div>
          {onCreateEvent && (
            <Button onClick={onCreateEvent} size="sm">
              <Plus className="h-4 w-4 mr-2" />
              Nuevo Evento
            </Button>
          )}
        </div>
      </CardHeader>
      <CardContent>
        {events.length === 0 ? (
          <div className="text-center py-8 text-muted-foreground">
            <Calendar className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>No hay eventos registrados</p>
            <p className="text-sm">Crea tu primer evento para comenzar</p>
          </div>
        ) : (
          <div className="space-y-4">
            {events.slice(0, 5).map((event) => (
              <div key={event.id} className="flex items-center justify-between p-3 border rounded-lg">
                <div className="flex-1">
                  <div className="flex items-center gap-2 mb-1">
                    <h3 className="font-medium">
                      {event.fiestas?.name || `Evento ${event.id.slice(0, 8)}`}
                    </h3>
                    <Badge variant={event.active ? "default" : "secondary"}>
                      {event.active ? "Activo" : "Inactivo"}
                    </Badge>
                  </div>
                  <div className="flex items-center gap-4 text-sm text-muted-foreground">
                    <div className="flex items-center gap-1">
                      <Calendar className="h-3 w-3" />
                      {format(new Date(event.event_date), "PPP", { locale: es })}
                    </div>
                    {event.fiestas?.location && (
                      <div className="flex items-center gap-1">
                        <MapPin className="h-3 w-3" />
                        {event.fiestas.location}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            ))}
            {events.length > 5 && (
              <p className="text-center text-sm text-muted-foreground">
                Y {events.length - 5} evento(s) m√°s...
              </p>
            )}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/ErrorBoundary/ErrorBoundary.tsx">
import React, { Component, ReactNode } from 'react';
import { ErrorMessage } from './ErrorMessage';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }
      
      return (
        <ErrorMessage
          title="Error de la aplicaci√≥n"
          message={this.state.error?.message || "Ha ocurrido un error inesperado"}
          onRetry={() => this.setState({ hasError: false, error: undefined })}
        />
      );
    }

    return this.props.children;
  }
}
</file>

<file path="src/components/ErrorBoundary/ErrorMessage.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { AlertTriangle, RefreshCw } from "lucide-react";

interface ErrorMessageProps {
  title?: string;
  message: string;
  showRetry?: boolean;
  onRetry?: () => void;
}

export function ErrorMessage({ 
  title = "Error", 
  message, 
  showRetry = true, 
  onRetry 
}: ErrorMessageProps) {
  return (
    <div className="flex items-center justify-center p-8">
      <Card className="max-w-md text-center">
        <CardHeader>
          <CardTitle className="flex items-center gap-2 justify-center text-destructive">
            <AlertTriangle className="h-5 w-5" />
            {title}
          </CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-muted-foreground mb-4">{message}</p>
          {showRetry && (
            <Button 
              onClick={onRetry || (() => window.location.reload())}
              variant="outline"
              className="gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Reintentar
            </Button>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/Events/CreateEventModal.tsx">
import React, { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Calendar, MapPin, Clock, Hash, DollarSign, Target, User, Instagram } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

interface CreateEventModalProps {
  isOpen: boolean;
  onClose: () => void;
  onEventCreated: () => void;
}

interface EventFormData {
  name: string;
  description: string;
  location: string;
  event_date: string;
  start_time: string;
  end_time: string;
  main_hashtag: string;
  is_cyclic: boolean;
  cyclic_type: "semanal" | "mensual" | "personalizado" | "";
  active: boolean;
  budget_estimate: string;
  objective: string;
  client_name: string;
  event_type: string;
  instagram_account: string;
}

export default function CreateEventModal({ isOpen, onClose, onEventCreated }: CreateEventModalProps) {
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState<EventFormData>({
    name: "",
    description: "",
    location: "",
    event_date: "",
    start_time: "",
    end_time: "",
    main_hashtag: "",
    is_cyclic: false,
    cyclic_type: "",
    active: true,
    budget_estimate: "",
    objective: "",
    client_name: "",
    event_type: "",
    instagram_account: ""
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      // Validaciones b√°sicas
      if (!formData.name.trim() || !formData.event_date) {
        toast.error('El nombre del evento y la fecha son obligatorios');
        return;
      }

      // Obtener el usuario actual y su organizaci√≥n
      const { data: user } = await supabase.auth.getUser();
      if (!user.user) {
        toast.error('Usuario no autenticado');
        return;
      }

      const { data: userData, error: userError } = await supabase
        .from('users')
        .select('id, organization_id')
        .eq('auth_user_id', user.user.id)
        .single();

      if (userError || !userData) {
        console.error('Error getting user data:', userError);
        toast.error('Error al obtener datos del usuario');
        return;
      }

      // Preparar datos del evento - solo los campos que existen en la tabla
      const eventData = {
        name: formData.name.trim(),
        description: formData.description.trim() || null,
        location: formData.location.trim() || null,
        event_date: formData.event_date,
        active: formData.active,
        organization_id: userData.organization_id
      };

      console.log('Creando evento con datos:', eventData);

      // Crear el evento en Supabase
      const { data: newEvent, error: eventError } = await supabase
        .from('events')
        .insert(eventData)
        .select()
        .single();

      if (eventError) {
        console.error('Error creating event:', eventError);
        toast.error('Error al crear evento: ' + eventError.message);
        return;
      }

      toast.success('Evento creado exitosamente');
      resetForm();
      onClose();
      onEventCreated();
    } catch (error) {
      console.error('Error creating event:', error);
      toast.error('Error al crear evento');
    } finally {
      setLoading(false);
    }
  };

  const resetForm = () => {
    setFormData({
      name: "",
      description: "",
      location: "",
      event_date: "",
      start_time: "",
      end_time: "",
      main_hashtag: "",
      is_cyclic: false,
      cyclic_type: "",
      active: true,
      budget_estimate: "",
      objective: "",
      client_name: "",
      event_type: "",
      instagram_account: ""
    });
  };

  const handleClose = () => {
    resetForm();
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Crear Nuevo Evento</DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-6">
          {/* Informaci√≥n B√°sica */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium">Informaci√≥n B√°sica</h3>
            
            <div>
              <Label htmlFor="name">Nombre del Evento *</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                placeholder="Ej: Fiesta de A√±o Nuevo 2024"
                required
              />
            </div>

            <div>
              <Label htmlFor="description">Descripci√≥n</Label>
              <Textarea
                id="description"
                value={formData.description}
                onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                placeholder="Describe el evento..."
                rows={3}
              />
            </div>
          </div>

          {/* Fecha y Ubicaci√≥n */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium">Fecha y Ubicaci√≥n</h3>
            
            <div className="grid grid-cols-2 gap-4">
              <div>
                <Label htmlFor="event_date">Fecha del Evento *</Label>
                <div className="relative">
                  <Calendar className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
                  <Input
                    id="event_date"
                    type="date"
                    value={formData.event_date}
                    onChange={(e) => setFormData({ ...formData, event_date: e.target.value })}
                    className="pl-10"
                    required
                  />
                </div>
              </div>
              <div>
                <Label htmlFor="location">Ubicaci√≥n</Label>
                <div className="relative">
                  <MapPin className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
                  <Input
                    id="location"
                    value={formData.location}
                    onChange={(e) => setFormData({ ...formData, location: e.target.value })}
                    placeholder="Direcci√≥n o lugar del evento"
                    className="pl-10"
                  />
                </div>
              </div>
            </div>
          </div>

          {/* Configuraci√≥n Avanzada */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium">Configuraci√≥n</h3>
            
            <div className="flex items-center space-x-2">
              <Switch
                id="active"
                checked={formData.active}
                onCheckedChange={(checked) => setFormData({ ...formData, active: checked })}
              />
              <Label htmlFor="active">Evento Activo</Label>
            </div>
          </div>

          <div className="flex justify-end gap-2 pt-4 border-t">
            <Button type="button" variant="outline" onClick={handleClose} disabled={loading}>
              Cancelar
            </Button>
            <Button type="submit" disabled={loading}>
              {loading ? 'Creando...' : 'Crear Evento'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Events/EventChecklists.tsx">
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { CheckSquare, Plus } from "lucide-react";
import { toast } from "sonner";

interface SimpleEventChecklistsProps {
  eventId: string;
}

export function EventChecklists({ eventId }: SimpleEventChecklistsProps) {
  const [tasks, setTasks] = useState<string[]>([]);
  const [newTask, setNewTask] = useState("");

  const handleAddTask = () => {
    if (newTask.trim()) {
      setTasks([...tasks, newTask.trim()]);
      setNewTask("");
      toast.success("Tarea agregada correctamente");
    }
  };

  const handleRemoveTask = (index: number) => {
    setTasks(tasks.filter((_, i) => i !== index));
    toast.success("Tarea eliminada");
  };

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle className="flex items-center gap-2">
              <CheckSquare className="h-5 w-5" />
              Lista de Tareas (Temporal)
            </CardTitle>
            <CardDescription>
              Gestiona las tareas del evento (solo en memoria por ahora)
            </CardDescription>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div className="flex gap-2">
            <input
              type="text"
              value={newTask}
              onChange={(e) => setNewTask(e.target.value)}
              placeholder="Agregar nueva tarea..."
              className="flex-1 px-3 py-2 border border-gray-200 rounded-md"
              onKeyPress={(e) => e.key === 'Enter' && handleAddTask()}
            />
            <Button onClick={handleAddTask} disabled={!newTask.trim()}>
              <Plus className="h-4 w-4 mr-2" />
              Agregar
            </Button>
          </div>

          {tasks.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              <CheckSquare className="h-8 w-8 mx-auto mb-2 opacity-50" />
              <p>No hay tareas registradas</p>
              <p className="text-sm">Agrega la primera tarea para organizar el trabajo</p>
            </div>
          ) : (
            <div className="space-y-2">
              {tasks.map((task, index) => (
                <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
                  <span>{task}</span>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleRemoveTask(index)}
                  >
                    Eliminar
                  </Button>
                </div>
              ))}
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Events/EventManagement.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Search, Plus, Calendar, MapPin } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useAuth } from "@/hooks/useAuth";
import { toast } from "sonner";
import { SimpleCreateEventModal } from "./SimpleCreateEventModal";

interface EventData {
  id: string;
  event_date: string;
  active: boolean;
  created_at: string;
  created_by_user_id: string;
  end_date: string;
  fiesta_id: string;
  start_date: string;
  fiestas?: {
    name: string;
    description: string;
    location: string;
  };
}

export default function EventManagement() {
  const { user } = useAuth();
  const [events, setEvents] = useState<EventData[]>([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [loading, setLoading] = useState(true);
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);

  useEffect(() => {
    if (user) {
      fetchEvents();
    }
  }, [user]);

  const fetchEvents = async () => {
    try {
      setLoading(true);

      // Primero obtener las organizaciones del usuario
      const { data: organizations, error: orgError } = await supabase
        .from('organizations')
        .select('id')
        .eq('created_by', user!.id);

      if (orgError) throw orgError;

      if (!organizations || organizations.length === 0) {
        setEvents([]);
        return;
      }

      const organizationIds = organizations.map(org => org.id);

      // Obtener eventos de las organizaciones del usuario con informaci√≥n de fiestas
      const { data: eventsData, error: eventsError } = await supabase
        .from('events')
        .select(`
          *,
          fiestas (
            name,
            description,
            location
          )
        `)
        .eq('fiestas.organization_id', organizationIds[0])
        .order('event_date', { ascending: false });

      if (eventsError) throw eventsError;

      setEvents(eventsData || []);
    } catch (error) {
      console.error('Error fetching events:', error);
      toast.error('Error al cargar eventos');
    } finally {
      setLoading(false);
    }
  };

  const filteredEvents = events.filter(event =>
    searchTerm === "" ||
    event.fiestas?.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    event.fiestas?.location?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    event.fiestas?.description?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  if (loading) {
    return (
      <div className="space-y-6">
        <div className="text-center">Cargando eventos...</div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Gesti√≥n de Eventos</h1>
          <p className="text-muted-foreground">
            Administra los eventos de tu organizaci√≥n
          </p>
        </div>
        <Button onClick={() => setIsCreateModalOpen(true)}>
          <Plus className="h-4 w-4 mr-2" />
          Nuevo Evento
        </Button>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Buscar Eventos</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground h-4 w-4" />
            <Input
              placeholder="Buscar por nombre, ubicaci√≥n o descripci√≥n..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="pl-10"
            />
          </div>
        </CardContent>
      </Card>

      {filteredEvents.length === 0 && searchTerm !== "" ? (
        <Card>
          <CardContent className="p-6 text-center text-muted-foreground">
            <p>No se encontraron eventos que coincidan con "{searchTerm}"</p>
          </CardContent>
        </Card>
      ) : filteredEvents.length === 0 ? (
        <Card>
          <CardContent className="p-6 text-center text-muted-foreground">
            <Calendar className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>No hay eventos registrados</p>
            <p className="text-sm">Crea tu primer evento para comenzar</p>
          </CardContent>
        </Card>
      ) : (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {filteredEvents.map((event) => (
            <Card key={event.id}>
              <CardHeader>
                <div className="space-y-2">
                  <CardTitle className="text-lg">
                    {event.fiestas?.name || `Evento ${event.id.slice(0, 8)}`}
                  </CardTitle>
                  <div className="space-y-2">
                    <Badge variant={event.active ? "default" : "secondary"}>
                      {event.active ? "Activo" : "Inactivo"}
                    </Badge>
                    <p className="text-sm text-muted-foreground">
                      Fecha: {new Date(event.event_date).toLocaleDateString()}
                    </p>
                    <p className="text-sm text-muted-foreground">
                      Inicio: {event.start_date ? new Date(event.start_date).toLocaleDateString() : 'No definido'}
                    </p>
                    <p className="text-sm text-muted-foreground">
                      Fin: {event.end_date ? new Date(event.end_date).toLocaleDateString() : 'No definido'}
                    </p>
                    {event.fiestas?.location && (
                      <div className="flex items-center text-sm text-muted-foreground">
                        <MapPin className="h-4 w-4 mr-1" />
                        {event.fiestas.location}
                      </div>
                    )}
                    {event.fiestas?.description && (
                      <p className="text-sm text-muted-foreground">
                        {event.fiestas.description}
                      </p>
                    )}
                  </div>
                </div>
              </CardHeader>
            </Card>
          ))}
        </div>
      )}

      <SimpleCreateEventModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
        onEventCreated={fetchEvents}
      />
    </div>
  );
}
</file>

<file path="src/components/Events/EventPhases.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { Calendar, Clock, Plus, Edit, Trash2 } from "lucide-react";
import { toast } from "sonner";
import { format } from "date-fns";
import { es } from "date-fns/locale";

interface SimpleEventPhase {
  id: string;
  name: string;
  start_date: string;
  end_date: string;
}

interface EventPhasesProps {
  eventId: string;
}

export function EventPhases({ eventId }: EventPhasesProps) {
  const [phases, setPhases] = useState<SimpleEventPhase[]>([]);
  const [loading, setLoading] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingPhase, setEditingPhase] = useState<SimpleEventPhase | null>(null);
  const [formData, setFormData] = useState({
    name: "",
    start_date: "",
    end_date: "",
  });

  // Simulamos las fases con datos locales por ahora
  useEffect(() => {
    // Simulamos fases por defecto
    setPhases([
      {
        id: "1",
        name: "Pre-evento",
        start_date: new Date().toISOString(),
        end_date: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
      },
    ]);
    setLoading(false);
  }, [eventId]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      if (editingPhase) {
        // Actualizar fase existente
        setPhases(phases.map(phase => 
          phase.id === editingPhase.id 
            ? { ...phase, ...formData }
            : phase
        ));
        toast.success("Fase actualizada correctamente");
      } else {
        // Crear nueva fase
        const newPhase: SimpleEventPhase = {
          id: Date.now().toString(),
          name: formData.name,
          start_date: formData.start_date,
          end_date: formData.end_date,
        };
        setPhases([...phases, newPhase]);
        toast.success("Fase creada correctamente");
      }

      resetForm();
    } catch (error) {
      console.error('Error saving phase:', error);
      toast.error("No se pudo guardar la fase");
    }
  };

  const handleDelete = async (phaseId: string) => {
    try {
      setPhases(phases.filter(phase => phase.id !== phaseId));
      toast.success("Fase eliminada correctamente");
    } catch (error) {
      console.error('Error deleting phase:', error);
      toast.error("No se pudo eliminar la fase");
    }
  };

  const resetForm = () => {
    setFormData({ name: "", start_date: "", end_date: "" });
    setEditingPhase(null);
    setIsModalOpen(false);
  };

  const openEditModal = (phase: SimpleEventPhase) => {
    setEditingPhase(phase);
    setFormData({
      name: phase.name,
      start_date: format(new Date(phase.start_date), "yyyy-MM-dd'T'HH:mm"),
      end_date: format(new Date(phase.end_date), "yyyy-MM-dd'T'HH:mm"),
    });
    setIsModalOpen(true);
  };

  const getPhaseStatus = (phase: SimpleEventPhase) => {
    const now = new Date();
    const startDate = new Date(phase.start_date);
    const endDate = new Date(phase.end_date);

    if (now < startDate) return { status: "upcoming", color: "bg-blue-500" };
    if (now >= startDate && now <= endDate) return { status: "active", color: "bg-green-500" };
    return { status: "completed", color: "bg-gray-500" };
  };

  if (loading) {
    return (
      <Card>
        <CardContent className="p-6">
          <div className="flex items-center justify-center">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle className="flex items-center gap-2">
              <Calendar className="h-5 w-5" />
              Fases del Evento (Temporal)
            </CardTitle>
            <CardDescription>
              Gestiona las fases del evento (solo en memoria por ahora)
            </CardDescription>
          </div>
          <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
            <DialogTrigger asChild>
              <Button onClick={() => resetForm()}>
                <Plus className="h-4 w-4 mr-2" />
                Nueva Fase
              </Button>
            </DialogTrigger>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>
                  {editingPhase ? "Editar Fase" : "Nueva Fase"}
                </DialogTitle>
                <DialogDescription>
                  {editingPhase ? "Modifica los detalles de la fase" : "Crea una nueva fase para el evento"}
                </DialogDescription>
              </DialogHeader>
              <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                  <Label htmlFor="name">Nombre de la Fase</Label>
                  <Input
                    id="name"
                    value={formData.name}
                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                    placeholder="Ej: Pre-evento, Ejecuci√≥n, Post-evento"
                    required
                  />
                </div>
                <div>
                  <Label htmlFor="start_date">Fecha de Inicio</Label>
                  <Input
                    id="start_date"
                    type="datetime-local"
                    value={formData.start_date}
                    onChange={(e) => setFormData({ ...formData, start_date: e.target.value })}
                    required
                  />
                </div>
                <div>
                  <Label htmlFor="end_date">Fecha de Fin</Label>
                  <Input
                    id="end_date"
                    type="datetime-local"
                    value={formData.end_date}
                    onChange={(e) => setFormData({ ...formData, end_date: e.target.value })}
                    required
                  />
                </div>
                <div className="flex justify-end gap-2">
                  <Button type="button" variant="outline" onClick={resetForm}>
                    Cancelar
                  </Button>
                  <Button type="submit">
                    {editingPhase ? "Actualizar" : "Crear"} Fase
                  </Button>
                </div>
              </form>
            </DialogContent>
          </Dialog>
        </div>
      </CardHeader>
      <CardContent>
        {phases.length === 0 ? (
          <div className="text-center text-muted-foreground py-8">
            <Calendar className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>No hay fases configuradas para este evento</p>
            <p className="text-sm">Crea la primera fase para organizar el cronograma</p>
          </div>
        ) : (
          <div className="space-y-4">
            {phases.map((phase) => {
              const { status, color } = getPhaseStatus(phase);
              return (
                <div key={phase.id} className="border rounded-lg p-4 hover:bg-muted/50 transition-colors">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      <div className={`w-3 h-3 rounded-full ${color}`}></div>
                      <div>
                        <h4 className="font-medium">{phase.name}</h4>
                        <div className="flex items-center gap-4 text-sm text-muted-foreground">
                          <span className="flex items-center gap-1">
                            <Clock className="h-3 w-3" />
                            {format(new Date(phase.start_date), "PPp", { locale: es })}
                          </span>
                          <span>‚Üí</span>
                          <span>{format(new Date(phase.end_date), "PPp", { locale: es })}</span>
                        </div>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <Badge variant={status === "active" ? "default" : "secondary"}>
                        {status === "upcoming" && "Pr√≥xima"}
                        {status === "active" && "Activa"}
                        {status === "completed" && "Completada"}
                      </Badge>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => openEditModal(phase)}
                      >
                        <Edit className="h-4 w-4" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => handleDelete(phase.id)}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Events/SimpleCreateEventModal.tsx">
import { useState } from "react";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Calendar, MapPin, Building2 } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { useAuth } from "@/hooks/useAuth";
import { useEffect } from "react";

interface SimpleCreateEventModalProps {
  isOpen: boolean;
  onClose: () => void;
  onEventCreated: () => void;
}

interface Organization {
  id: string;
  name: string;
}

export function SimpleCreateEventModal({ isOpen, onClose, onEventCreated }: SimpleCreateEventModalProps) {
  const { user } = useAuth();
  const [formData, setFormData] = useState({
    name: "",
    description: "",
    event_date: "",
    location: "",
    organization_id: ""
  });
  const [organizations, setOrganizations] = useState<Organization[]>([]);
  const [loading, setLoading] = useState(false);
  const [organizationsLoaded, setOrganizationsLoaded] = useState(false);

  const loadOrganizations = async () => {
    if (!user || organizationsLoaded) return;

    try {
      const { data, error } = await supabase
        .from('organizations')
        .select('id, name')
        .eq('created_by', user.id)
        .order('name');

      if (error) throw error;
      setOrganizations(data || []);
      setOrganizationsLoaded(true);
    } catch (error) {
      console.error('Error loading organizations:', error);
      toast.error('Error al cargar organizaciones');
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      if (!formData.name || !formData.event_date || !formData.organization_id) {
        toast.error('Nombre, fecha y organizaci√≥n son obligatorios');
        return;
      }

      const { data, error } = await supabase
        .from('events')
        .insert([{
          name: formData.name,
          description: formData.description || null,
          event_date: formData.event_date,
          location: formData.location || null,
          organization_id: formData.organization_id,
          active: true
        }])
        .select()
        .single();

      if (error) throw error;

      toast.success('Evento creado exitosamente');
      resetForm();
      onClose();
      onEventCreated();
    } catch (error) {
      console.error('Error creating event:', error);
      toast.error('Error al crear evento');
    } finally {
      setLoading(false);
    }
  };

  const resetForm = () => {
    setFormData({
      name: "",
      description: "",
      event_date: "",
      location: "",
      organization_id: ""
    });
  };

  // Cargar organizaciones cuando se abre el modal
  useEffect(() => {
    if (isOpen && user) {
      loadOrganizations();
    }
  }, [isOpen, user]);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Crear Nuevo Evento</DialogTitle>
          <DialogDescription>
            Completa la informaci√≥n b√°sica para crear un nuevo evento
          </DialogDescription>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-6">
          <div className="space-y-4">
            <h3 className="text-lg font-medium flex items-center gap-2">
              <Building2 className="w-5 h-5" />
              Organizaci√≥n
            </h3>
            
            <div>
              <Label htmlFor="organization_id">Seleccionar Organizaci√≥n/Productora *</Label>
              <Select 
                value={formData.organization_id} 
                onValueChange={(value) => setFormData({ ...formData, organization_id: value })}
                required
              >
                <SelectTrigger>
                  <SelectValue placeholder="Selecciona una organizaci√≥n..." />
                </SelectTrigger>
                <SelectContent>
                  {organizations.map((org) => (
                    <SelectItem key={org.id} value={org.id}>
                      {org.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          <div className="space-y-4">
            <h3 className="text-lg font-medium">Informaci√≥n del Evento</h3>
            
            <div>
              <Label htmlFor="name">Nombre del Evento *</Label>
              <div className="relative">
                <Calendar className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
                <Input
                  id="name"
                  value={formData.name}
                  onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  placeholder="Ej: Fiesta de A√±o Nuevo"
                  className="pl-10"
                  required
                />
              </div>
            </div>

            <div>
              <Label htmlFor="event_date">Fecha del Evento *</Label>
              <Input
                id="event_date"
                type="date"
                value={formData.event_date}
                onChange={(e) => setFormData({ ...formData, event_date: e.target.value })}
                required
              />
            </div>

            <div>
              <Label htmlFor="location">Ubicaci√≥n</Label>
              <div className="relative">
                <MapPin className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
                <Input
                  id="location"
                  value={formData.location}
                  onChange={(e) => setFormData({ ...formData, location: e.target.value })}
                  placeholder="Ej: Club Social, Santiago"
                  className="pl-10"
                />
              </div>
            </div>

            <div>
              <Label htmlFor="description">Descripci√≥n</Label>
              <Textarea
                id="description"
                value={formData.description}
                onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                placeholder="Describe el evento..."
                rows={3}
              />
            </div>
          </div>

          <div className="flex justify-end gap-2 pt-4 border-t">
            <Button type="button" variant="outline" onClick={onClose} disabled={loading}>
              Cancelar
            </Button>
            <Button type="submit" disabled={loading}>
              {loading ? 'Creando...' : 'Crear Evento'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Events/SimpleEventChecklists.tsx">
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { CheckSquare, Plus } from "lucide-react";
import { toast } from "sonner";

interface SimpleEventChecklistsProps {
  eventId: string;
}

export function SimpleEventChecklists({ eventId }: SimpleEventChecklistsProps) {
  const [tasks, setTasks] = useState<string[]>([]);
  const [newTask, setNewTask] = useState("");

  const handleAddTask = () => {
    if (newTask.trim()) {
      setTasks([...tasks, newTask.trim()]);
      setNewTask("");
      toast.success("Tarea agregada correctamente");
    }
  };

  const handleRemoveTask = (index: number) => {
    setTasks(tasks.filter((_, i) => i !== index));
    toast.success("Tarea eliminada");
  };

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle className="flex items-center gap-2">
              <CheckSquare className="h-5 w-5" />
              Lista de Tareas (Temporal)
            </CardTitle>
            <CardDescription>
              Gestiona las tareas del evento (solo en memoria por ahora)
            </CardDescription>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div className="flex gap-2">
            <input
              type="text"
              value={newTask}
              onChange={(e) => setNewTask(e.target.value)}
              placeholder="Agregar nueva tarea..."
              className="flex-1 px-3 py-2 border border-gray-200 rounded-md"
              onKeyPress={(e) => e.key === 'Enter' && handleAddTask()}
            />
            <Button onClick={handleAddTask} disabled={!newTask.trim()}>
              <Plus className="h-4 w-4 mr-2" />
              Agregar
            </Button>
          </div>

          {tasks.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              <CheckSquare className="h-8 w-8 mx-auto mb-2 opacity-50" />
              <p>No hay tareas registradas</p>
              <p className="text-sm">Agrega la primera tarea para organizar el trabajo</p>
            </div>
          ) : (
            <div className="space-y-2">
              {tasks.map((task, index) => (
                <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
                  <span>{task}</span>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleRemoveTask(index)}
                  >
                    Eliminar
                  </Button>
                </div>
              ))}
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Events/SimpleEventsList.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Calendar, MapPin, Plus } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { toast } from "sonner";

interface EventData {
  id: string;
  event_date: string;
  active: boolean;
  created_at: string;
  created_by_user_id: string;
  end_date: string;
  fiesta_id: string;
  start_date: string;
  fiestas?: {
    name: string;
    description: string;
    location: string;
  };
}

export function SimpleEventsList() {
  const { organization } = useCurrentOrganization();
  const [events, setEvents] = useState<EventData[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (organization) {
      fetchEvents();
    }
  }, [organization]);

  const fetchEvents = async () => {
    if (!organization) return;

    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('events')
        .select(`
          *,
          fiestas (
            name,
            description,
            location
          )
        `)
        .eq('fiestas.organization_id', organization.id)
        .order('event_date', { ascending: false });

      if (error) throw error;
      setEvents(data || []);
    } catch (error) {
      console.error('Error fetching events:', error);
      toast.error('Error al cargar eventos');
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="space-y-4">
        {[...Array(3)].map((_, i) => (
          <div key={i} className="h-32 bg-muted animate-pulse rounded-lg" />
        ))}
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">Eventos</h2>
        <Button>
          <Plus className="h-4 w-4 mr-2" />
          Nuevo Evento
        </Button>
      </div>

      {events.length === 0 ? (
        <Card>
          <CardContent className="p-6 text-center text-muted-foreground">
            <Calendar className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>No hay eventos registrados</p>
          </CardContent>
        </Card>
      ) : (
        <div className="grid gap-4">
          {events.map((event) => (
            <Card key={event.id}>
              <CardHeader>
                <div className="flex justify-between items-start">
                  <div>
                    <CardTitle>{event.fiestas?.name || `Evento ${event.id.slice(0, 8)}`}</CardTitle>
                    {event.fiestas?.description && (
                      <p className="text-sm text-muted-foreground mt-1">
                        {event.fiestas.description}
                      </p>
                    )}
                  </div>
                  <Badge variant={event.active ? "default" : "secondary"}>
                    {event.active ? "Activo" : "Inactivo"}
                  </Badge>
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-2">
                  <div className="flex items-center text-sm text-muted-foreground">
                    <Calendar className="h-4 w-4 mr-2" />
                    Fecha: {new Date(event.event_date).toLocaleDateString()}
                  </div>
                  {event.fiestas?.location && (
                    <div className="flex items-center text-sm text-muted-foreground">
                      <MapPin className="h-4 w-4 mr-2" />
                      {event.fiestas.location}
                    </div>
                  )}
                  <div className="flex items-center text-sm text-muted-foreground">
                    <span>Inicio: {event.start_date ? new Date(event.start_date).toLocaleDateString() : 'No definido'}</span>
                    <span className="mx-2">‚Ä¢</span>
                    <span>Fin: {event.end_date ? new Date(event.end_date).toLocaleDateString() : 'No definido'}</span>
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/Fiestas/CreateFiestaModal.tsx">
import { useState } from "react";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { CalendarDays, Loader2 } from "lucide-react";
import { useFiestas } from "@/hooks/useFiestas";

interface CreateFiestaModalProps {
  isOpen: boolean;
  onClose: () => void;
  onFiestaCreated: () => void;
}

interface FiestaFormData {
  name: string;
  description: string;
  event_date: string;
  location: string;
  main_hashtag: string;
  secondary_hashtags: string;
}

export function CreateFiestaModal({ isOpen, onClose, onFiestaCreated }: CreateFiestaModalProps) {
  const { createFiesta } = useFiestas();
  const [isLoading, setIsLoading] = useState(false);
  const [formData, setFormData] = useState<FiestaFormData>({
    name: '',
    description: '',
    event_date: '',
    location: '',
    main_hashtag: '',
    secondary_hashtags: ''
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!formData.name.trim()) {
      return;
    }

    setIsLoading(true);
    
    const fiestaData = {
      name: formData.name.trim(),
      description: formData.description.trim() || null,
      event_date: formData.event_date || null,
      location: formData.location.trim() || null,
      main_hashtag: formData.main_hashtag.trim() || null,
      secondary_hashtags: formData.secondary_hashtags.trim() ? 
        formData.secondary_hashtags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0) : 
        null,
      status: 'active'
    };

    const result = await createFiesta(fiestaData);
    
    if (result) {
      resetForm();
      onFiestaCreated();
    }
    
    setIsLoading(false);
  };

  const resetForm = () => {
    setFormData({
      name: '',
      description: '',
      event_date: '',
      location: '',
      main_hashtag: '',
      secondary_hashtags: ''
    });
  };

  const handleClose = () => {
    resetForm();
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <CalendarDays className="h-5 w-5" />
            Crear Nueva Fiesta
          </DialogTitle>
          <DialogDescription>
            Crea una nueva fiesta para gestionar eventos y embajadores.
          </DialogDescription>
        </DialogHeader>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="name">Nombre de la Fiesta *</Label>
            <Input
              id="name"
              placeholder="Ej: Fiesta de A√±o Nuevo 2024"
              value={formData.name}
              onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
              required
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="description">Descripci√≥n</Label>
            <Textarea
              id="description"
              placeholder="Describe la fiesta..."
              value={formData.description}
              onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
              rows={3}
            />
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="event_date">Fecha del Evento</Label>
              <Input
                id="event_date"
                type="date"
                value={formData.event_date}
                onChange={(e) => setFormData(prev => ({ ...prev, event_date: e.target.value }))}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="location">Ubicaci√≥n</Label>
              <Input
                id="location"
                placeholder="Ej: Santiago, Chile"
                value={formData.location}
                onChange={(e) => setFormData(prev => ({ ...prev, location: e.target.value }))}
              />
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="main_hashtag">Hashtag Principal</Label>
            <Input
              id="main_hashtag"
              placeholder="Ej: #FiestaA√±oNuevo2024"
              value={formData.main_hashtag}
              onChange={(e) => setFormData(prev => ({ ...prev, main_hashtag: e.target.value }))}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="secondary_hashtags">Hashtags Secundarios</Label>
            <Input
              id="secondary_hashtags"
              placeholder="Ej: #fiesta, #celebracion, #2024 (separados por comas)"
              value={formData.secondary_hashtags}
              onChange={(e) => setFormData(prev => ({ ...prev, secondary_hashtags: e.target.value }))}
            />
          </div>

          <div className="flex justify-end space-x-2 pt-4">
            <Button type="button" variant="outline" onClick={handleClose}>
              Cancelar
            </Button>
            <Button type="submit" disabled={isLoading || !formData.name.trim()}>
              {isLoading ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Creando...
                </>
              ) : (
                'Crear Fiesta'
              )}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Fiestas/FiestaDetailsModal.tsx">
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { Calendar, MapPin, Hash, Clock, Users } from "lucide-react";
import { Fiesta } from "@/hooks/useFiestas";

interface FiestaDetailsModalProps {
  fiesta: Fiesta | null;
  isOpen: boolean;
  onClose: () => void;
}

export function FiestaDetailsModal({ fiesta, isOpen, onClose }: FiestaDetailsModalProps) {
  if (!fiesta) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[600px] backdrop-blur-md bg-white/95">
        <DialogHeader>
          <div className="flex items-center justify-between">
            <DialogTitle className="text-2xl font-bold bg-gradient-to-r from-gray-900 to-gray-700 bg-clip-text text-transparent">
              {fiesta.name}
            </DialogTitle>
            <Badge variant={fiesta.status === 'active' ? 'default' : 'secondary'} className="ml-2">
              {fiesta.status === 'active' ? 'Activa' : 'Inactiva'}
            </Badge>
          </div>
          {fiesta.description && (
            <DialogDescription className="text-base text-gray-600 mt-2">
              {fiesta.description}
            </DialogDescription>
          )}
        </DialogHeader>
        
        <div className="space-y-6">
          {/* Event Details */}
          <div className="space-y-4">
            <h3 className="font-semibold text-lg text-gray-900">Detalles del Evento</h3>
            <div className="grid gap-4">
              {fiesta.event_date && (
                <div className="flex items-center gap-3 p-3 rounded-xl bg-gray-50/50 border border-gray-200/50">
                  <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-blue-500 to-cyan-600 flex items-center justify-center">
                    <Calendar className="w-5 h-5 text-white" />
                  </div>
                  <div>
                    <p className="font-medium text-gray-900">Fecha del Evento</p>
                    <p className="text-gray-600">
                      {new Date(fiesta.event_date).toLocaleDateString('es-ES', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        weekday: 'long'
                      })}
                    </p>
                  </div>
                </div>
              )}
              
              {fiesta.location && (
                <div className="flex items-center gap-3 p-3 rounded-xl bg-gray-50/50 border border-gray-200/50">
                  <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-green-500 to-emerald-600 flex items-center justify-center">
                    <MapPin className="w-5 h-5 text-white" />
                  </div>
                  <div>
                    <p className="font-medium text-gray-900">Ubicaci√≥n</p>
                    <p className="text-gray-600">{fiesta.location}</p>
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* Hashtags */}
          {(fiesta.main_hashtag || fiesta.secondary_hashtags) && (
            <div className="space-y-4">
              <h3 className="font-semibold text-lg text-gray-900">Hashtags</h3>
              <div className="space-y-3">
                {fiesta.main_hashtag && (
                  <div className="flex items-center gap-3 p-3 rounded-xl bg-purple-50/50 border border-purple-200/50">
                    <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-purple-500 to-pink-600 flex items-center justify-center">
                      <Hash className="w-5 h-5 text-white" />
                    </div>
                    <div>
                      <p className="font-medium text-gray-900">Hashtag Principal</p>
                      <p className="text-purple-700 font-mono">{fiesta.main_hashtag}</p>
                    </div>
                  </div>
                )}
                
                {fiesta.secondary_hashtags && fiesta.secondary_hashtags.length > 0 && (
                  <div className="p-3 rounded-xl bg-gray-50/50 border border-gray-200/50">
                    <p className="font-medium text-gray-900 mb-2">Hashtags Secundarios</p>
                    <div className="flex flex-wrap gap-2">
                      {fiesta.secondary_hashtags.map((hashtag, index) => (
                        <Badge key={index} variant="outline" className="text-gray-700 border-gray-300">
                          {hashtag}
                        </Badge>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Timestamps */}
          <div className="space-y-4">
            <h3 className="font-semibold text-lg text-gray-900">Informaci√≥n del Sistema</h3>
            <div className="grid gap-3">
              <div className="flex items-center gap-3 p-3 rounded-xl bg-gray-50/50 border border-gray-200/50">
                <Clock className="w-5 h-5 text-gray-600" />
                <div>
                  <p className="font-medium text-gray-900">Creada</p>
                  <p className="text-gray-600">
                    {new Date(fiesta.created_at).toLocaleDateString('es-ES', {
                      year: 'numeric',
                      month: 'long',
                      day: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit'
                    })}
                  </p>
                </div>
              </div>
              
              <div className="flex items-center gap-3 p-3 rounded-xl bg-gray-50/50 border border-gray-200/50">
                <Clock className="w-5 h-5 text-gray-600" />
                <div>
                  <p className="font-medium text-gray-900">√öltima Actualizaci√≥n</p>
                  <p className="text-gray-600">
                    {new Date(fiesta.updated_at).toLocaleDateString('es-ES', {
                      year: 'numeric',
                      month: 'long',
                      day: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit'
                    })}
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Fiestas/FiestaSelector.tsx">
import { useState } from "react";
import { Check, ChevronsUpDown, Plus } from "lucide-react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { useFiestas } from "@/hooks/useFiestas";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";

interface FiestaSelectorProps {
  className?: string;
}

export function FiestaSelector({ className }: FiestaSelectorProps) {
  const [open, setOpen] = useState(false);
  const { fiestas, selectedFiesta, setSelectedFiestaId, loading } = useFiestas();
  const { organization } = useCurrentOrganization();

  if (loading) {
    return (
      <div className={cn("flex items-center space-x-2", className)}>
        <div className="h-9 w-full animate-pulse rounded-md bg-muted"></div>
      </div>
    );
  }

  if (!organization) {
    return (
      <div className={cn("flex items-center space-x-2", className)}>
        <span className="text-sm text-muted-foreground">Sin organizaci√≥n</span>
      </div>
    );
  }

  if (fiestas.length === 0) {
    return (
      <div className={cn("flex items-center space-x-2", className)}>
        <span className="text-sm text-muted-foreground">Sin fiestas</span>
        <Button size="sm" variant="outline">
          <Plus className="h-4 w-4 mr-2" />
          Crear Fiesta
        </Button>
      </div>
    );
  }

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className={cn("justify-between", className)}
        >
          <div className="flex items-center space-x-2 truncate">
            <span className="truncate">
              {selectedFiesta ? selectedFiesta.name : "Seleccionar fiesta..."}
            </span>
          </div>
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-80 p-0" align="start">
        <Command>
          <CommandInput placeholder="Buscar fiesta..." />
          <CommandList>
            <CommandEmpty>No se encontraron fiestas.</CommandEmpty>
            <CommandGroup>
              {fiestas.map((fiesta) => (
                <CommandItem
                  key={fiesta.id}
                  value={`${fiesta.name} ${fiesta.description || ''}`}
                  onSelect={() => {
                    setSelectedFiestaId(fiesta.id);
                    setOpen(false);
                  }}
                >
                  <Check
                    className={cn(
                      "mr-2 h-4 w-4",
                      selectedFiesta?.id === fiesta.id ? "opacity-100" : "opacity-0"
                    )}
                  />
                  <div className="flex flex-col">
                    <span className="font-medium">{fiesta.name}</span>
                    {fiesta.description && (
                      <span className="text-xs text-muted-foreground">
                        {fiesta.description}
                      </span>
                    )}
                    {fiesta.event_date && (
                      <span className="text-xs text-muted-foreground">
                        {new Date(fiesta.event_date).toLocaleDateString()}
                      </span>
                    )}
                  </div>
                </CommandItem>
              ))}
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="src/components/Fiestas/FiestasManagement.tsx">
import { useState } from "react";
import { Plus, Calendar, MapPin, Hash } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { useFiestas, Fiesta } from "@/hooks/useFiestas";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { CreateFiestaModal } from "./CreateFiestaModal";
import { FiestaDetailsModal } from "./FiestaDetailsModal";
import { PageHeader } from "@/components/Layout/PageHeader";
import { GlassPanel } from "@/components/Layout/GlassPanel";

const FiestasManagement = () => {
  const { organization } = useCurrentOrganization();
  const { fiestas, loading } = useFiestas();
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const [selectedFiesta, setSelectedFiesta] = useState<Fiesta | null>(null);
  const [isDetailsModalOpen, setIsDetailsModalOpen] = useState(false);

  const handleViewDetails = (fiesta: Fiesta) => {
    setSelectedFiesta(fiesta);
    setIsDetailsModalOpen(true);
  };

  if (!organization) {
    return (
      <div className="space-y-6">
        <PageHeader 
          title="Fiestas"
          description="Carga de organizaci√≥n..."
        />
        <GlassPanel>
          <p className="text-gray-600 text-center py-8">No se encontr√≥ organizaci√≥n. Por favor, configura tu organizaci√≥n primero.</p>
        </GlassPanel>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader 
        title="Fiestas"
        description={`Gestiona las fiestas y eventos de ${organization.name}`}
      >
        <Button 
          onClick={() => setIsCreateModalOpen(true)}
          className="bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-500 hover:to-blue-500 text-white shadow-lg hover:shadow-xl transition-all duration-300 hover:scale-105"
        >
          <Plus className="h-4 w-4 mr-2" />
          Nueva Fiesta
        </Button>
      </PageHeader>

      {loading ? (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {[...Array(6)].map((_, i) => (
            <GlassPanel key={i} className="animate-pulse">
              <div className="space-y-3">
                <div className="h-4 bg-gray-300 rounded"></div>
                <div className="h-3 bg-gray-300 rounded w-2/3"></div>
                <div className="h-3 bg-gray-300 rounded w-1/2"></div>
              </div>
            </GlassPanel>
          ))}
        </div>
      ) : fiestas.length === 0 ? (
        <GlassPanel className="text-center py-12">
          <Calendar className="h-12 w-12 mx-auto mb-4 text-gray-500" />
          <h3 className="text-xl font-semibold mb-2 text-gray-900">No hay fiestas</h3>
          <p className="text-gray-600 mb-6">
            Comienza creando tu primera fiesta para gestionar eventos y embajadores.
          </p>
          <Button 
            onClick={() => setIsCreateModalOpen(true)}
            className="bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-500 hover:to-blue-500 text-white shadow-lg hover:shadow-xl transition-all duration-300 hover:scale-105"
          >
            <Plus className="h-4 w-4 mr-2" />
            Crear Primera Fiesta
          </Button>
        </GlassPanel>
      ) : (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {fiestas.map((fiesta) => (
            <GlassPanel key={fiesta.id} className="hover:shadow-xl transition-all duration-300 hover:scale-[1.02] group">
              <div className="space-y-4">
                <div className="flex justify-between items-start">
                  <div>
                    <h3 className="text-xl font-bold text-gray-900 group-hover:bg-gradient-to-r group-hover:from-purple-600 group-hover:to-blue-600 group-hover:bg-clip-text group-hover:text-transparent transition-all duration-300">
                      {fiesta.name}
                    </h3>
                    {fiesta.description && (
                      <p className="text-gray-600 mt-2 line-clamp-2">
                        {fiesta.description}
                      </p>
                    )}
                  </div>
                  <Badge 
                    variant={fiesta.status === 'active' ? 'default' : 'secondary'}
                    className={fiesta.status === 'active' ? 'bg-gradient-to-r from-green-500 to-emerald-600 text-white' : ''}
                  >
                    {fiesta.status === 'active' ? 'Activa' : 'Inactiva'}
                  </Badge>
                </div>

                <div className="space-y-3">
                  {fiesta.event_date && (
                    <div className="flex items-center text-sm text-gray-600">
                      <Calendar className="h-4 w-4 mr-2 text-blue-500" />
                      {new Date(fiesta.event_date).toLocaleDateString('es-ES', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                      })}
                    </div>
                  )}
                  
                  {fiesta.location && (
                    <div className="flex items-center text-sm text-gray-600">
                      <MapPin className="h-4 w-4 mr-2 text-green-500" />
                      {fiesta.location}
                    </div>
                  )}
                  
                  {fiesta.main_hashtag && (
                    <div className="flex items-center text-sm text-gray-600">
                      <Hash className="h-4 w-4 mr-2 text-purple-500" />
                      {fiesta.main_hashtag}
                    </div>
                  )}
                </div>
                
                <div className="pt-4 border-t border-gray-200/50 flex justify-between items-center">
                  <span className="text-xs text-gray-500">
                    Creada {new Date(fiesta.created_at).toLocaleDateString()}
                  </span>
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={() => handleViewDetails(fiesta)}
                    className="hover:bg-gradient-to-r hover:from-purple-600 hover:to-blue-600 hover:text-white hover:border-transparent transition-all duration-300"
                  >
                    Ver Detalles
                  </Button>
                </div>
              </div>
            </GlassPanel>
          ))}
        </div>
      )}

      <CreateFiestaModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
        onFiestaCreated={() => {
          setIsCreateModalOpen(false);
        }}
      />

      <FiestaDetailsModal
        fiesta={selectedFiesta}
        isOpen={isDetailsModalOpen}
        onClose={() => {
          setIsDetailsModalOpen(false);
          setSelectedFiesta(null);
        }}
      />
    </div>
  );
};

export default FiestasManagement;
</file>

<file path="src/components/ImportExport/BackupCenter.tsx">
import { useState, useEffect } from "react";
import { GlassPanel } from "@/components/Layout/GlassPanel";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { 
  Download, 
  Upload, 
  Database, 
  Shield, 
  History, 
  AlertCircle,
  CheckCircle,
  Clock,
  FileArchive
} from "lucide-react";
import { toast } from "sonner";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { supabase } from "@/integrations/supabase/client";

interface BackupLog {
  id: string;
  type: string;
  file_name: string;
  status: string;
  created_at: string;
  result_json: any;
  organization_id: string;
  user_id: string;
  source: string;
}

export default function BackupCenter() {
  const { organization } = useCurrentOrganization();
  const [isProcessing, setIsProcessing] = useState(false);
  const [backupLogs, setBackupLogs] = useState<BackupLog[]>([]);
  const [progress, setProgress] = useState(0);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [restoreOptions, setRestoreOptions] = useState({
    overwriteExisting: false,
    selectiveTables: [] as string[]
  });

  const availableTables = [
    'organizations',
    'embassadors', 
    'fiestas',
    'events',
    'tasks',
    'leaderboards',
    'organization_settings',
    'notifications'
  ];

  useEffect(() => {
    fetchBackupLogs();
  }, []);

  const fetchBackupLogs = async () => {
    try {
      const { data, error } = await supabase
        .from('import_logs')
        .select('id, user_id, organization_id, type, source, file_name, status, result_json, created_at')
        .in('type', ['backup', 'export', 'restore'])
        .order('created_at', { ascending: false })
        .limit(10);

      if (error) throw error;
      setBackupLogs(data || []);
    } catch (error) {
      console.error('Error fetching backup logs:', error);
    }
  };

  const createFullBackup = async () => {
    if (!organization) {
      toast.error('No se encontr√≥ la organizaci√≥n');
      return;
    }

    try {
      setIsProcessing(true);
      setProgress(10);

      const { data, error } = await supabase.functions.invoke('backup-full-database', {
        headers: {
          'Authorization': `Bearer ${(await supabase.auth.getSession()).data.session?.access_token}`
        }
      });

      setProgress(50);

      if (error) throw error;

      setProgress(80);

      // Download the backup file
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `eva-backup-full-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      setProgress(100);
      toast.success('Respaldo completo creado y descargado exitosamente');
      fetchBackupLogs();
    } catch (error) {
      console.error('Error creating backup:', error);
      toast.error('Error al crear el respaldo');
    } finally {
      setIsProcessing(false);
      setProgress(0);
    }
  };

  const exportOrganizationData = async (format: 'json' | 'csv' = 'json') => {
    if (!organization) {
      toast.error('No se encontr√≥ la organizaci√≥n');
      return;
    }

    try {
      setIsProcessing(true);
      setProgress(10);

      const { data, error } = await supabase.functions.invoke('export-organization-data', {
        body: {
          organizationId: organization.id,
          format,
          tables: 'all'
        },
        headers: {
          'Authorization': `Bearer ${(await supabase.auth.getSession()).data.session?.access_token}`
        }
      });

      setProgress(50);

      if (error) throw error;

      setProgress(80);

      // The response should be the file content directly
      const blob = new Blob([typeof data === 'string' ? data : JSON.stringify(data, null, 2)], { 
        type: format === 'csv' ? 'text/csv' : 'application/json' 
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `eva-export-${organization.name}-${new Date().toISOString().split('T')[0]}.${format}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      setProgress(100);
      toast.success(`Exportaci√≥n ${format.toUpperCase()} completada exitosamente`);
      fetchBackupLogs();
    } catch (error) {
      console.error('Error exporting data:', error);
      toast.error('Error al exportar los datos');
    } finally {
      setIsProcessing(false);
      setProgress(0);
    }
  };

  const restoreFromBackup = async () => {
    if (!selectedFile) {
      toast.error('Selecciona un archivo de respaldo');
      return;
    }

    try {
      setIsProcessing(true);
      setProgress(10);

      // Read the backup file
      const fileContent = await selectedFile.text();
      const backupData = JSON.parse(fileContent);

      setProgress(30);

      const { data, error } = await supabase.functions.invoke('restore-organization-data', {
        body: {
          backupData,
          options: restoreOptions
        },
        headers: {
          'Authorization': `Bearer ${(await supabase.auth.getSession()).data.session?.access_token}`
        }
      });

      setProgress(80);

      if (error) throw error;

      setProgress(100);

      if (data.success) {
        toast.success(`Restauraci√≥n completada: ${data.summary}`);
        if (data.errors && data.errors.length > 0) {
          toast.warning(`Advertencias: ${data.errors.length} errores encontrados`);
        }
      } else {
        toast.error(`Error en la restauraci√≥n: ${data.error}`);
      }

      fetchBackupLogs();
    } catch (error) {
      console.error('Error restoring backup:', error);
      toast.error('Error al restaurar el respaldo');
    } finally {
      setIsProcessing(false);
      setProgress(0);
      setSelectedFile(null);
    }
  };

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setSelectedFile(file);
    }
  };

  const toggleTable = (table: string, checked: boolean) => {
    setRestoreOptions(prev => ({
      ...prev,
      selectiveTables: checked 
        ? [...prev.selectiveTables, table]
        : prev.selectiveTables.filter(t => t !== table)
    }));
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'completed':
        return <CheckCircle className="w-4 h-4 text-green-600" />;
      case 'failed':
        return <AlertCircle className="w-4 h-4 text-red-600" />;
      case 'partial':
        return <AlertCircle className="w-4 h-4 text-yellow-600" />;
      default:
        return <Clock className="w-4 h-4 text-gray-600" />;
    }
  };

  const getStatusBadge = (status: string) => {
    const variants: Record<string, "default" | "secondary" | "destructive" | "outline"> = {
      completed: "default",
      failed: "destructive", 
      partial: "outline"
    };
    return <Badge variant={variants[status] || "secondary"}>{status}</Badge>;
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h3 className="text-xl font-semibold">Centro de Respaldos</h3>
        <div className="flex gap-2">
          <Button variant="outline" onClick={() => exportOrganizationData('csv')}>
            <Download className="w-4 h-4 mr-2" />
            Export CSV
          </Button>
          <Button onClick={createFullBackup} disabled={isProcessing}>
            <Database className="w-4 h-4 mr-2" />
            Respaldo Completo
          </Button>
        </div>
      </div>

      {isProcessing && (
        <GlassPanel size="sm">
          <div className="space-y-2">
            <div className="flex items-center justify-between text-sm">
              <span>Procesando...</span>
              <span>{progress}%</span>
            </div>
            <Progress value={progress} className="w-full" />
          </div>
        </GlassPanel>
      )}

      <Tabs defaultValue="backup" className="space-y-6">
        <TabsList className="grid w-full grid-cols-3">
          <TabsTrigger value="backup">Crear Respaldo</TabsTrigger>
          <TabsTrigger value="restore">Restaurar</TabsTrigger>
          <TabsTrigger value="history">Historial</TabsTrigger>
        </TabsList>

        <TabsContent value="backup" className="space-y-6">
          <div className="grid gap-6 md:grid-cols-2">
            <GlassPanel size="sm">
              <div className="flex items-center gap-2 mb-4">
                <Database className="w-5 h-5" />
                <h4 className="font-semibold">Respaldo Completo</h4>
              </div>
              <p className="text-sm text-muted-foreground mb-4">
                Crea un respaldo completo de todos los datos de tu organizaci√≥n incluyendo embajadores, eventos, tareas y configuraciones.
              </p>
              <Button onClick={createFullBackup} disabled={isProcessing} className="w-full">
                <Database className="w-4 h-4 mr-2" />
                Crear Respaldo Completo
              </Button>
            </GlassPanel>

            <GlassPanel size="sm">
              <div className="flex items-center gap-2 mb-4">
                <FileArchive className="w-5 h-5" />
                <h4 className="font-semibold">Exportaci√≥n Selectiva</h4>
              </div>
              <p className="text-sm text-muted-foreground mb-4">
                Exporta datos espec√≠ficos de tu organizaci√≥n en diferentes formatos.
              </p>
              <div className="space-y-2">
                <Button 
                  onClick={() => exportOrganizationData('json')} 
                  disabled={isProcessing} 
                  variant="outline" 
                  className="w-full"
                >
                  <Download className="w-4 h-4 mr-2" />
                  Exportar JSON
                </Button>
                <Button 
                  onClick={() => exportOrganizationData('csv')} 
                  disabled={isProcessing} 
                  variant="outline" 
                  className="w-full"
                >
                  <Download className="w-4 h-4 mr-2" />
                  Exportar CSV
                </Button>
              </div>
            </GlassPanel>
          </div>
        </TabsContent>

        <TabsContent value="restore" className="space-y-6">
          <GlassPanel>
            <div className="flex items-center gap-2 mb-6">
              <Upload className="w-5 h-5" />
              <h4 className="font-semibold">Restaurar desde Respaldo</h4>
            </div>
            
            <div className="space-y-4">
              <div>
                <Label>Archivo de Respaldo</Label>
                <input
                  type="file"
                  accept=".json"
                  onChange={handleFileSelect}
                  className="block w-full text-sm text-muted-foreground file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-primary file:text-primary-foreground hover:file:bg-primary/90 mt-2"
                />
                {selectedFile && (
                  <p className="text-sm text-muted-foreground mt-1">
                    Seleccionado: {selectedFile.name}
                  </p>
                )}
              </div>

              <div className="space-y-3">
                <div className="flex items-center space-x-2">
                  <Checkbox
                    id="overwrite"
                    checked={restoreOptions.overwriteExisting}
                    onCheckedChange={(checked) => 
                      setRestoreOptions(prev => ({ ...prev, overwriteExisting: checked as boolean }))
                    }
                  />
                  <Label htmlFor="overwrite" className="text-sm">
                    Sobrescribir datos existentes
                  </Label>
                </div>

                <div>
                  <Label className="text-sm font-medium">Tablas a restaurar (dejar vac√≠o para todas)</Label>
                  <div className="grid grid-cols-2 gap-2 mt-2 max-h-40 overflow-y-auto bg-white/30 rounded-lg p-3">
                    {availableTables.map((table) => (
                      <div key={table} className="flex items-center space-x-2">
                        <Checkbox
                          id={table}
                          checked={restoreOptions.selectiveTables.includes(table)}
                          onCheckedChange={(checked) => toggleTable(table, checked as boolean)}
                        />
                        <Label htmlFor={table} className="text-sm font-normal">
                          {table}
                        </Label>
                      </div>
                    ))}
                  </div>
                </div>
              </div>

              <div className="bg-warning/10 border border-warning/20 rounded-lg p-4">
                <div className="flex items-start gap-2">
                  <AlertCircle className="w-5 h-5 text-warning mt-0.5" />
                  <div>
                    <h4 className="font-medium">Advertencia</h4>
                    <p className="text-sm text-muted-foreground mt-1">
                      La restauraci√≥n puede sobrescribir datos existentes. Aseg√∫rate de tener un respaldo actual antes de proceder.
                    </p>
                  </div>
                </div>
              </div>

              <Button 
                onClick={restoreFromBackup} 
                disabled={isProcessing || !selectedFile} 
                className="w-full"
              >
                <Upload className="w-4 h-4 mr-2" />
                Restaurar Datos
              </Button>
            </div>
          </GlassPanel>
        </TabsContent>

        <TabsContent value="history" className="space-y-6">
          <GlassPanel>
            <div className="flex items-center gap-2 mb-6">
              <History className="w-5 h-5" />
              <h4 className="font-semibold">Historial de Operaciones</h4>
            </div>
            
            <div className="space-y-4">
              {backupLogs.length === 0 ? (
                <p className="text-center text-muted-foreground py-8">
                  No se encontraron operaciones de respaldo
                </p>
              ) : (
                backupLogs.map((log) => (
                  <div key={log.id} className="flex items-center justify-between p-4 bg-white/30 rounded-lg">
                    <div className="flex items-center gap-3">
                      {getStatusIcon(log.status)}
                      <div>
                        <p className="font-medium">{log.file_name}</p>
                        <p className="text-sm text-muted-foreground">
                          {log.type} ‚Ä¢ {new Date(log.created_at).toLocaleString()}
                        </p>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      {getStatusBadge(log.status)}
                      {log.result_json?.record_counts && typeof log.result_json.record_counts === 'object' && (
                        <Badge variant="outline">
                          {Object.values(log.result_json.record_counts as Record<string, number>).reduce((a: number, b: number) => a + b, 0)} registros
                        </Badge>
                      )}
                    </div>
                  </div>
                ))
              )}
            </div>
          </GlassPanel>
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/components/ImportExport/ImportExportCenter.tsx">
import { useState, useRef } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Progress } from "@/components/ui/progress";
import {
  Upload,
  Download,
  FileText,
  FileSpreadsheet,
  CheckCircle,
  AlertCircle,
  XCircle,
  Eye,
  Settings,
  Calendar,
  Users,
  History,
  RefreshCw
} from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";

interface ImportLog {
  id: string;
  type: "import" | "export";
  source: "manual" | "google_drive" | "excel" | "csv";
  file_name: string;
  status: "pending" | "processing" | "completed" | "failed";
  result_json: {
    total_records: number;
    successful: number;
    failed: number;
    incomplete: number;
    errors: Array<{ row: number; field: string; message: string }>;
  };
  created_at: string;
  user_id: string;
}

interface FieldMapping {
  source_field: string;
  target_field: string;
  required: boolean;
  validated: boolean;
}

export function ImportExportCenter() {
  const [activeTab, setActiveTab] = useState("import");
  const [importFile, setImportFile] = useState<File | null>(null);
  const [fieldMappings, setFieldMappings] = useState<FieldMapping[]>([]);
  const [importProgress, setImportProgress] = useState(0);
  const [isProcessing, setIsProcessing] = useState(false);
  const [previewData, setPreviewData] = useState<any[]>([]);
  const [importLogs, setImportLogs] = useState<ImportLog[]>([]);
  const [exportConfig, setExportConfig] = useState({
    format: "excel",
    entity: "ambassadors",
    period: "all",
    fields: [] as string[],
    filters: {}
  });

  const fileInputRef = useRef<HTMLInputElement>(null);
  const { toast } = useToast();

  const requiredFields = {
    ambassadors: [
      { key: "first_name", label: "Nombre", required: true },
      { key: "last_name", label: "Apellido", required: true },
      { key: "email", label: "Email", required: true },
      { key: "rut", label: "RUT", required: true },
      { key: "date_of_birth", label: "Fecha de Nacimiento", required: true },
      { key: "instagram_user", label: "Usuario Instagram", required: true },
      { key: "follower_count", label: "Seguidores", required: false },
      { key: "profile_picture_url", label: "Foto de Perfil", required: false }
    ]
  };

  const exportFields = {
    ambassadors: [
      "first_name", "last_name", "email", "rut", "date_of_birth", 
      "instagram_user", "follower_count", "global_points", "global_category",
      "performance_status", "events_participated", "completed_tasks", "failed_tasks"
    ],
    events: [
      "name", "description", "event_date", "location", "main_hashtag", 
      "instagram_account", "active", "is_cyclic", "cyclic_type"
    ],
    tasks: [
      "task_type", "status", "upload_time", "expiry_time", "points_earned",
      "instagram_story_id", "story_url", "time_in_air"
    ]
  };

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setImportFile(file);
      parseFile(file);
    }
  };

  const parseFile = async (file: File) => {
    try {
      setIsProcessing(true);
      
      // Mock file parsing - replace with actual CSV/Excel parsing
      const mockPreviewData = [
        { nombre: "Mar√≠a", apellido: "Gonz√°lez", email: "maria@email.com", rut: "12345678-9", instagram: "@maria_g" },
        { nombre: "Carlos", apellido: "Ruiz", email: "carlos@email.com", rut: "87654321-0", instagram: "@carlos_r" },
        { nombre: "Ana", apellido: "Silva", email: "ana@email.com", rut: "11223344-5", instagram: "@ana_s" }
      ];

      setPreviewData(mockPreviewData);

      // Auto-detect field mappings
      const sourceFields = Object.keys(mockPreviewData[0] || {});
      const mappings: FieldMapping[] = requiredFields.ambassadors.map(targetField => {
        const sourceField = sourceFields.find(sf => 
          sf.toLowerCase().includes(targetField.key.toLowerCase()) ||
          targetField.label.toLowerCase().includes(sf.toLowerCase())
        ) || "";
        
        return {
          source_field: sourceField,
          target_field: targetField.key,
          required: targetField.required,
          validated: sourceField !== ""
        };
      });

      setFieldMappings(mappings);
      
    } catch (error) {
      console.error("Error parsing file:", error);
      toast({
        title: "Error",
        description: "No se pudo procesar el archivo",
        variant: "destructive"
      });
    } finally {
      setIsProcessing(false);
    }
  };

  const updateFieldMapping = (targetField: string, sourceField: string) => {
    setFieldMappings(prev => 
      prev.map(mapping => 
        mapping.target_field === targetField 
          ? { ...mapping, source_field: sourceField, validated: sourceField !== "" && sourceField !== "none" }
          : mapping
      )
    );
  };

  const processImport = async () => {
    try {
      setIsProcessing(true);
      setImportProgress(0);

      // Validate mappings
      const invalidMappings = fieldMappings.filter(m => m.required && !m.validated);
      if (invalidMappings.length > 0) {
        toast({
          title: "Error de validaci√≥n",
          description: "Faltan campos obligatorios por mapear",
          variant: "destructive"
        });
        return;
      }

      // Simulate import progress
      for (let i = 0; i <= 100; i += 10) {
        setImportProgress(i);
        await new Promise(resolve => setTimeout(resolve, 200));
      }

      // Create import log
      const newLog: ImportLog = {
        id: Date.now().toString(),
        type: "import",
        source: importFile?.name.endsWith('.csv') ? 'csv' : 'excel',
        file_name: importFile?.name || "",
        status: "completed",
        result_json: {
          total_records: previewData.length,
          successful: previewData.length - 1,
          failed: 1,
          incomplete: 0,
          errors: [
            { row: 3, field: "email", message: "Email inv√°lido" }
          ]
        },
        created_at: new Date().toISOString(),
        user_id: "current-user"
      };

      setImportLogs(prev => [newLog, ...prev]);

      toast({
        title: "Importaci√≥n completada",
        description: `Se importaron ${newLog.result_json.successful} de ${newLog.result_json.total_records} registros`
      });

      // Reset form
      setImportFile(null);
      setPreviewData([]);
      setFieldMappings([]);
      setImportProgress(0);
      
    } catch (error) {
      console.error("Error during import:", error);
      toast({
        title: "Error",
        description: "Error durante la importaci√≥n",
        variant: "destructive"
      });
    } finally {
      setIsProcessing(false);
    }
  };

  const processExport = async () => {
    try {
      setIsProcessing(true);

      // Simulate export process
      await new Promise(resolve => setTimeout(resolve, 2000));

      const newLog: ImportLog = {
        id: Date.now().toString(),
        type: "export",
        source: "manual",
        file_name: `${exportConfig.entity}_export_${new Date().toISOString().split('T')[0]}.${exportConfig.format}`,
        status: "completed",
        result_json: {
          total_records: 156,
          successful: 156,
          failed: 0,
          incomplete: 0,
          errors: []
        },
        created_at: new Date().toISOString(),
        user_id: "current-user"
      };

      setImportLogs(prev => [newLog, ...prev]);

      toast({
        title: "Exportaci√≥n completada",
        description: `Se exportaron ${newLog.result_json.total_records} registros`
      });

    } catch (error) {
      console.error("Error during export:", error);
      toast({
        title: "Error",
        description: "Error durante la exportaci√≥n",
        variant: "destructive"
      });
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold bg-gradient-primary bg-clip-text text-transparent">
            Importaci√≥n y Exportaci√≥n
          </h1>
          <p className="text-muted-foreground">
            Gestiona la importaci√≥n y exportaci√≥n de datos
          </p>
        </div>
      </div>

      <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-6">
        <TabsList className="grid w-full grid-cols-3">
          <TabsTrigger value="import">Importar</TabsTrigger>
          <TabsTrigger value="export">Exportar</TabsTrigger>
          <TabsTrigger value="history">Historial</TabsTrigger>
        </TabsList>

        {/* Import Tab */}
        <TabsContent value="import" className="space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* File Upload */}
            <Card className="shadow-card">
              <CardHeader>
                <CardTitle className="flex items-center">
                  <Upload className="w-5 h-5 mr-2" />
                  Subir Archivo
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="border-2 border-dashed border-primary/20 rounded-lg p-6 text-center">
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept=".csv,.xlsx,.xls"
                    onChange={handleFileUpload}
                    className="hidden"
                  />
                  
                  {importFile ? (
                    <div className="space-y-2">
                      <FileSpreadsheet className="w-12 h-12 text-primary mx-auto" />
                      <p className="font-medium">{importFile.name}</p>
                      <p className="text-sm text-muted-foreground">
                        {(importFile.size / 1024).toFixed(1)} KB
                      </p>
                      <Button
                        variant="outline"
                        onClick={() => fileInputRef.current?.click()}
                      >
                        Cambiar archivo
                      </Button>
                    </div>
                  ) : (
                    <div className="space-y-2">
                      <Upload className="w-12 h-12 text-muted-foreground mx-auto" />
                      <p className="text-lg font-medium">Arrastra tu archivo aqu√≠</p>
                      <p className="text-sm text-muted-foreground">
                        Soporta archivos Excel (.xlsx, .xls) y CSV
                      </p>
                      <Button onClick={() => fileInputRef.current?.click()}>
                        Seleccionar archivo
                      </Button>
                    </div>
                  )}
                </div>

                {importFile && previewData.length > 0 && (
                  <div className="space-y-4">
                    <h3 className="font-medium">Vista previa de datos</h3>
                    <div className="border rounded-lg overflow-x-auto">
                      <table className="w-full text-sm">
                        <thead className="bg-muted">
                          <tr>
                            {Object.keys(previewData[0]).map(key => (
                              <th key={key} className="px-3 py-2 text-left font-medium">
                                {key}
                              </th>
                            ))}
                          </tr>
                        </thead>
                        <tbody>
                          {previewData.slice(0, 3).map((row, index) => (
                            <tr key={index} className="border-t">
                              {Object.values(row).map((value: any, cellIndex) => (
                                <td key={cellIndex} className="px-3 py-2">
                                  {value}
                                </td>
                              ))}
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                    <p className="text-xs text-muted-foreground">
                      Mostrando 3 de {previewData.length} registros
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Field Mapping */}
            {fieldMappings.length > 0 && (
              <Card className="shadow-card">
                <CardHeader>
                  <CardTitle className="flex items-center">
                    <Settings className="w-5 h-5 mr-2" />
                    Mapeo de Campos
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  {fieldMappings.map((mapping) => (
                    <div key={mapping.target_field} className="space-y-2">
                      <div className="flex items-center justify-between">
                        <Label className="text-sm font-medium">
                          {requiredFields.ambassadors.find(f => f.key === mapping.target_field)?.label}
                          {mapping.required && <span className="text-destructive ml-1">*</span>}
                        </Label>
                        {mapping.validated ? (
                          <CheckCircle className="w-4 h-4 text-success" />
                        ) : mapping.required ? (
                          <XCircle className="w-4 h-4 text-destructive" />
                        ) : (
                          <AlertCircle className="w-4 h-4 text-warning" />
                        )}
                      </div>
                      <Select
                        value={mapping.source_field}
                        onValueChange={(value) => updateFieldMapping(mapping.target_field, value)}
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Seleccionar campo del archivo" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="none">Sin mapear</SelectItem>
                          {Object.keys(previewData[0] || {}).map(field => (
                            <SelectItem key={field} value={field}>
                              {field}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>
                  ))}

                  {isProcessing && (
                    <div className="space-y-2">
                      <Label>Progreso de importaci√≥n</Label>
                      <Progress value={importProgress} className="w-full" />
                      <p className="text-sm text-muted-foreground">{importProgress}%</p>
                    </div>
                  )}

                  <Button 
                    onClick={processImport} 
                    disabled={isProcessing || fieldMappings.some(m => m.required && !m.validated)}
                    className="w-full"
                  >
                    {isProcessing ? (
                      <>
                        <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
                        Procesando...
                      </>
                    ) : (
                      <>
                        <Upload className="w-4 h-4 mr-2" />
                        Iniciar Importaci√≥n
                      </>
                    )}
                  </Button>
                </CardContent>
              </Card>
            )}
          </div>
        </TabsContent>

        {/* Export Tab */}
        <TabsContent value="export" className="space-y-6">
          <Card className="shadow-card">
            <CardHeader>
              <CardTitle className="flex items-center">
                <Download className="w-5 h-5 mr-2" />
                Configurar Exportaci√≥n
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div className="space-y-2">
                  <Label>Tipo de datos</Label>
                  <Select 
                    value={exportConfig.entity} 
                    onValueChange={(value) => setExportConfig(prev => ({ ...prev, entity: value }))}
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="ambassadors">Embajadores</SelectItem>
                      <SelectItem value="events">Eventos</SelectItem>
                      <SelectItem value="tasks">Tareas</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-2">
                  <Label>Formato</Label>
                  <Select 
                    value={exportConfig.format} 
                    onValueChange={(value) => setExportConfig(prev => ({ ...prev, format: value }))}
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="excel">Excel (.xlsx)</SelectItem>
                      <SelectItem value="csv">CSV</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-2">
                  <Label>Per√≠odo</Label>
                  <Select 
                    value={exportConfig.period} 
                    onValueChange={(value) => setExportConfig(prev => ({ ...prev, period: value }))}
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">Todos los registros</SelectItem>
                      <SelectItem value="month">√öltimo mes</SelectItem>
                      <SelectItem value="quarter">√öltimo trimestre</SelectItem>
                      <SelectItem value="year">√öltimo a√±o</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div className="flex items-end">
                  <Button onClick={processExport} disabled={isProcessing} className="w-full">
                    {isProcessing ? (
                      <>
                        <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
                        Exportando...
                      </>
                    ) : (
                      <>
                        <Download className="w-4 h-4 mr-2" />
                        Exportar
                      </>
                    )}
                  </Button>
                </div>
              </div>

              <div className="space-y-4">
                <Label>Campos a incluir</Label>
                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
                  {exportFields[exportConfig.entity as keyof typeof exportFields]?.map(field => (
                    <div key={field} className="flex items-center space-x-2">
                      <Checkbox
                        id={field}
                        checked={exportConfig.fields.includes(field)}
                        onCheckedChange={(checked) => {
                          if (checked) {
                            setExportConfig(prev => ({
                              ...prev,
                              fields: [...prev.fields, field]
                            }));
                          } else {
                            setExportConfig(prev => ({
                              ...prev,
                              fields: prev.fields.filter(f => f !== field)
                            }));
                          }
                        }}
                      />
                      <Label htmlFor={field} className="text-sm">
                        {field.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}
                      </Label>
                    </div>
                  ))}
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        {/* History Tab */}
        <TabsContent value="history" className="space-y-6">
          <Card className="shadow-card">
            <CardHeader>
              <CardTitle className="flex items-center">
                <History className="w-5 h-5 mr-2" />
                Historial de Operaciones
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {importLogs.length === 0 ? (
                  <div className="text-center py-8">
                    <FileText className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
                    <h3 className="text-lg font-medium mb-2">No hay operaciones registradas</h3>
                    <p className="text-muted-foreground">
                      Las importaciones y exportaciones aparecer√°n aqu√≠
                    </p>
                  </div>
                ) : (
                  importLogs.map((log) => (
                    <div key={log.id} className="flex items-center justify-between p-4 border rounded-lg">
                      <div className="flex items-center space-x-3">
                        <div className="flex-shrink-0">
                          {log.type === "import" ? (
                            <Upload className="w-5 h-5 text-primary" />
                          ) : (
                            <Download className="w-5 h-5 text-success" />
                          )}
                        </div>
                        <div>
                          <h4 className="font-medium">{log.file_name}</h4>
                          <div className="flex items-center space-x-4 text-sm text-muted-foreground">
                            <span>{log.type === "import" ? "Importaci√≥n" : "Exportaci√≥n"}</span>
                            <span>{new Date(log.created_at).toLocaleDateString()}</span>
                            <span>{log.result_json.total_records} registros</span>
                          </div>
                        </div>
                      </div>
                      <div className="flex items-center space-x-3">
                        <Badge 
                          variant={
                            log.status === "completed" ? "secondary" :
                            log.status === "failed" ? "destructive" : "outline"
                          }
                        >
                          {log.status === "completed" ? "Completado" :
                           log.status === "failed" ? "Fallido" : "Pendiente"}
                        </Badge>
                        <Button variant="ghost" size="sm">
                          <Eye className="w-4 h-4" />
                        </Button>
                      </div>
                    </div>
                  ))
                )}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/components/ImportExport/ImportExportReal.tsx">
import { useState, useRef } from "react";
import { GlassPanel } from "@/components/Layout/GlassPanel";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Upload, Download, FileSpreadsheet, AlertCircle } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";

interface ImportExportRealProps {}

export default function ImportExportReal({}: ImportExportRealProps) {
  const { organization } = useCurrentOrganization();
  const [activeTab, setActiveTab] = useState("import");
  const [importFile, setImportFile] = useState<File | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [exportConfig, setExportConfig] = useState({
    entity: "ambassadors",
    format: "excel",
    fields: [] as string[]
  });

  const fileInputRef = useRef<HTMLInputElement>(null);

  const exportFields = {
    ambassadors: [
      { key: "first_name", label: "Nombre" },
      { key: "last_name", label: "Apellido" },
      { key: "email", label: "Email" },
      { key: "instagram_user", label: "Usuario Instagram" },
      { key: "status", label: "Estado" }
    ],
    events: [
      { key: "name", label: "Nombre" },
      { key: "description", label: "Descripci√≥n" },
      { key: "event_date", label: "Fecha" },
      { key: "location", label: "Ubicaci√≥n" },
      { key: "active", label: "Activo" }
    ]
  };

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setImportFile(file);
    }
  };

  const processImport = async () => {
    if (!importFile) {
      toast.error('Selecciona un archivo para importar');
      return;
    }

    try {
      setIsProcessing(true);

      // Simulamos el proceso de importaci√≥n
      await new Promise(resolve => setTimeout(resolve, 2000));

      const { data: user } = await supabase.auth.getUser();
      if (!user.user) throw new Error('Usuario no autenticado');

      toast.success('Importaci√≥n completada exitosamente (simulada)');
      setImportFile(null);
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    } catch (error) {
      console.error('Error during import:', error);
      toast.error('Error durante la importaci√≥n');
    } finally {
      setIsProcessing(false);
    }
  };

  const processExport = async () => {
    if (!organization) {
      toast.error('No se encontr√≥ la organizaci√≥n');
      return;
    }

    try {
      setIsProcessing(true);

      const { data: user } = await supabase.auth.getUser();
      if (!user.user) throw new Error('Usuario no autenticado');

      // Simulamos exportaci√≥n sin consultas complejas de Supabase por ahora
      const data: any[] = [];

      if (exportConfig.entity === 'ambassadors') {
        // Datos simulados para evitar tipos complejos de Supabase
        data.push({
          id: '1',
          first_name: 'Juan',
          last_name: 'P√©rez',
          email: 'juan@ejemplo.com',
          instagram_user: 'juan_p',
          status: 'active'
        });
      } else if (exportConfig.entity === 'events') {
        data.push({
          id: '1',
          name: 'Evento de Prueba',
          description: 'Descripci√≥n del evento',
          event_date: '2024-12-01',
          location: 'Santiago',
          active: true
        });
      } else {
        throw new Error('Tipo de entidad no soportado');
      }

      // Simular descarga del archivo
      const jsonData = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonData], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${exportConfig.entity}_export.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      toast.success(`Exportaci√≥n completada: ${data.length} registros`);
    } catch (error) {
      console.error('Error during export:', error);
      toast.error('Error durante la exportaci√≥n');
    } finally {
      setIsProcessing(false);
    }
  };

  const handleFieldToggle = (field: string, checked: boolean) => {
    setExportConfig(prev => ({
      ...prev,
      fields: checked 
        ? [...prev.fields, field]
        : prev.fields.filter(f => f !== field)
    }));
  };

  const downloadTemplate = () => {
    // Crear plantilla de ejemplo para embajadores
    const template = [
      {
        first_name: "Mar√≠a",
        last_name: "Gonz√°lez",
        email: "maria@ejemplo.com",
        instagram_user: "maria_g"
      }
    ];

    const csv = [
      Object.keys(template[0]).join(','),
      ...template.map(row => Object.values(row).join(','))
    ].join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'plantilla_embajadores.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    toast.success('Plantilla descargada');
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h3 className="text-xl font-semibold">Importaci√≥n y Exportaci√≥n</h3>
        <Button variant="outline" onClick={downloadTemplate}>
          <Download className="w-4 h-4 mr-2" />
          Descargar Plantilla
        </Button>
      </div>

      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <TabsList className="grid w-full grid-cols-2">
          <TabsTrigger value="import">Importar</TabsTrigger>
          <TabsTrigger value="export">Exportar</TabsTrigger>
        </TabsList>

        <TabsContent value="import" className="space-y-6">
          <GlassPanel>
            <div className="flex items-center gap-2 mb-6">
              <Upload className="w-5 h-5" />
              <h4 className="font-semibold">Importar Embajadores</h4>
            </div>
            
            <div className="border-2 border-dashed border-primary/30 rounded-lg p-6 text-center bg-white/20">
              <input
                ref={fileInputRef}
                type="file"
                accept=".csv,.xlsx,.xls"
                onChange={handleFileUpload}
                className="hidden"
              />
              
              {importFile ? (
                <div className="space-y-2">
                  <FileSpreadsheet className="w-12 h-12 text-primary mx-auto" />
                  <p className="font-medium">{importFile.name}</p>
                  <p className="text-sm text-muted-foreground">
                    {(importFile.size / 1024).toFixed(1)} KB
                  </p>
                  <div className="flex gap-2 justify-center">
                    <Button
                      variant="outline"
                      onClick={() => fileInputRef.current?.click()}
                    >
                      Cambiar archivo
                    </Button>
                    <Button onClick={processImport} disabled={isProcessing}>
                      {isProcessing ? 'Procesando...' : 'Importar'}
                    </Button>
                  </div>
                </div>
              ) : (
                <div className="space-y-2">
                  <Upload className="w-12 h-12 text-muted-foreground mx-auto" />
                  <p className="text-lg font-medium">Arrastra tu archivo aqu√≠</p>
                  <p className="text-sm text-muted-foreground">
                    Soporta archivos Excel (.xlsx, .xls) y CSV
                  </p>
                  <Button onClick={() => fileInputRef.current?.click()}>
                    Seleccionar archivo
                  </Button>
                </div>
              )}
            </div>

            <div className="bg-info/10 border border-info/20 rounded-lg p-4">
              <div className="flex items-start gap-2">
                <AlertCircle className="w-5 h-5 text-info mt-0.5" />
                <div>
                  <h4 className="font-medium">Campos requeridos</h4>
                  <p className="text-sm text-muted-foreground mt-1">
                    Nombre, Apellido, Email, Usuario de Instagram
                  </p>
                </div>
              </div>
            </div>
          </GlassPanel>
        </TabsContent>

        <TabsContent value="export" className="space-y-6">
          <GlassPanel>
            <div className="flex items-center gap-2 mb-6">
              <Download className="w-5 h-5" />
              <h4 className="font-semibold">Configurar Exportaci√≥n</h4>
            </div>
            
            <div className="space-y-6">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label>Tipo de datos</Label>
                  <Select 
                    value={exportConfig.entity} 
                    onValueChange={(value) => setExportConfig(prev => ({ ...prev, entity: value, fields: [] }))}
                  >
                    <SelectTrigger className="bg-white/50">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="ambassadors">Embajadores</SelectItem>
                      <SelectItem value="events">Eventos</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Label>Formato</Label>
                  <Select 
                    value={exportConfig.format} 
                    onValueChange={(value) => setExportConfig(prev => ({ ...prev, format: value }))}
                  >
                    <SelectTrigger className="bg-white/50">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="excel">Excel (.xlsx)</SelectItem>
                      <SelectItem value="csv">CSV</SelectItem>
                      <SelectItem value="json">JSON</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>

              <div>
                <Label>Campos a exportar (dejar vac√≠o para todos)</Label>
                <div className="grid grid-cols-2 gap-2 mt-2 max-h-40 overflow-y-auto bg-white/30 rounded-lg p-3">
                  {exportFields[exportConfig.entity as keyof typeof exportFields]?.map((field) => (
                    <div key={field.key} className="flex items-center space-x-2">
                      <Checkbox
                        id={field.key}
                        checked={exportConfig.fields.includes(field.key)}
                        onCheckedChange={(checked) => handleFieldToggle(field.key, checked as boolean)}
                      />
                      <Label htmlFor={field.key} className="text-sm font-normal">
                        {field.label}
                      </Label>
                    </div>
                  ))}
                </div>
              </div>

              <Button onClick={processExport} disabled={isProcessing} className="w-full">
                {isProcessing ? 'Exportando...' : 'Exportar Datos'}
              </Button>
            </div>
          </GlassPanel>
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/components/Instagram/InstagramBusinessDashboard.tsx">
import { useEffect, useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Instagram, Users, Image, Tag, RefreshCw, ExternalLink } from "lucide-react";
import { useInstagramSync } from "@/hooks/useInstagramSync";
import { toast } from "sonner";

interface InstagramProfile {
  user_id: string;
  username: string;
  name: string;
  account_type: string;
  profile_picture_url: string;
  followers_count: number;
  follows_count: number;
  media_count: number;
}

interface InstagramMedia {
  id: string;
  caption: string;
  comments_count: number;
  like_count: number;
  media_type: string;
  media_url: string;
  permalink: string;
  username: string;
}

interface InstagramTag {
  id: string;
  caption: string;
  comments_count: number;
  like_count: number;
  media_type: string;
  media_url: string;
  permalink: string;
  username: string;
}

export function InstagramBusinessDashboard() {
  const { isSyncing, getInstagramProfile, getInstagramMedia, getInstagramTags } = useInstagramSync();
  const [profile, setProfile] = useState<InstagramProfile | null>(null);
  const [media, setMedia] = useState<InstagramMedia[]>([]);
  const [tags, setTags] = useState<InstagramTag[]>([]);
  const [loading, setLoading] = useState(true);

  const loadData = async () => {
    try {
      setLoading(true);
      
      // Cargar perfil
      const profileData = await getInstagramProfile();
      if (profileData?.success && profileData.profile) {
        setProfile(profileData.profile);
      }

      // Cargar media
      const mediaData = await getInstagramMedia();
      if (mediaData?.success && mediaData.media) {
        setMedia(mediaData.media);
      }

      // Cargar tags/menciones
      const tagsData = await getInstagramTags();
      if (tagsData?.success && tagsData.tags) {
        setTags(tagsData.tags);
      }
    } catch (error) {
      console.error('Error loading Instagram data:', error);
      toast.error('Error al cargar datos de Instagram');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadData();
  }, []);

  const handleRefresh = () => {
    loadData();
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-8">
        <RefreshCw className="w-6 h-6 animate-spin mr-2" />
        Cargando datos de Instagram...
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header con perfil */}
      {profile && (
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-4">
                <img
                  src={profile.profile_picture_url}
                  alt={profile.username}
                  className="w-16 h-16 rounded-full"
                />
                <div>
                  <CardTitle className="flex items-center gap-2">
                    <Instagram className="w-5 h-5" />
                    @{profile.username}
                  </CardTitle>
                  <CardDescription>{profile.name}</CardDescription>
                  <Badge variant="outline" className="mt-1">
                    {profile.account_type}
                  </Badge>
                </div>
              </div>
              <Button onClick={handleRefresh} disabled={isSyncing} size="sm" variant="outline">
                <RefreshCw className={`w-4 h-4 mr-2 ${isSyncing ? 'animate-spin' : ''}`} />
                Actualizar
              </Button>
            </div>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-3 gap-4">
              <div className="text-center">
                <div className="text-2xl font-bold">{profile.followers_count.toLocaleString()}</div>
                <div className="text-sm text-muted-foreground">Seguidores</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold">{profile.follows_count.toLocaleString()}</div>
                <div className="text-sm text-muted-foreground">Siguiendo</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold">{profile.media_count.toLocaleString()}</div>
                <div className="text-sm text-muted-foreground">Publicaciones</div>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Tabs para contenido */}
      <Tabs defaultValue="media" className="space-y-4">
        <TabsList>
          <TabsTrigger value="media" className="flex items-center gap-2">
            <Image className="w-4 h-4" />
            Feed ({media.length})
          </TabsTrigger>
          <TabsTrigger value="tags" className="flex items-center gap-2">
            <Tag className="w-4 h-4" />
            Menciones ({tags.length})
          </TabsTrigger>
        </TabsList>

        <TabsContent value="media">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {media.map((item) => (
              <Card key={item.id} className="overflow-hidden">
                <div className="aspect-square bg-muted">
                  {item.media_type === 'IMAGE' || item.media_type === 'CAROUSEL_ALBUM' ? (
                    <img
                      src={item.media_url}
                      alt={item.caption?.substring(0, 50) || 'Instagram post'}
                      className="w-full h-full object-cover"
                    />
                  ) : (
                    <div className="w-full h-full flex items-center justify-center">
                      <Image className="w-12 h-12 text-muted-foreground" />
                    </div>
                  )}
                </div>
                <CardContent className="p-4">
                  <p className="text-sm text-muted-foreground line-clamp-3">
                    {item.caption || 'Sin descripci√≥n'}
                  </p>
                  <div className="flex items-center justify-between mt-2">
                    <div className="flex items-center gap-4 text-sm text-muted-foreground">
                      <span>‚ù§Ô∏è {item.like_count}</span>
                      <span>üí¨ {item.comments_count}</span>
                    </div>
                    <Button asChild size="sm" variant="ghost">
                      <a href={item.permalink} target="_blank" rel="noopener noreferrer">
                        <ExternalLink className="w-4 h-4" />
                      </a>
                    </Button>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
          {media.length === 0 && (
            <Card>
              <CardContent className="p-8 text-center">
                <Image className="w-12 h-12 mx-auto mb-4 text-muted-foreground" />
                <p className="text-muted-foreground">No hay publicaciones disponibles</p>
              </CardContent>
            </Card>
          )}
        </TabsContent>

        <TabsContent value="tags">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {tags.map((item) => (
              <Card key={item.id} className="overflow-hidden">
                <div className="aspect-square bg-muted">
                  {item.media_type === 'IMAGE' || item.media_type === 'CAROUSEL_ALBUM' ? (
                    <img
                      src={item.media_url}
                      alt={item.caption?.substring(0, 50) || 'Instagram mention'}
                      className="w-full h-full object-cover"
                    />
                  ) : (
                    <div className="w-full h-full flex items-center justify-center">
                      <Tag className="w-12 h-12 text-muted-foreground" />
                    </div>
                  )}
                </div>
                <CardContent className="p-4">
                  <p className="text-sm font-medium mb-1">@{item.username}</p>
                  <p className="text-sm text-muted-foreground line-clamp-3">
                    {item.caption || 'Sin descripci√≥n'}
                  </p>
                  <div className="flex items-center justify-between mt-2">
                    <div className="flex items-center gap-4 text-sm text-muted-foreground">
                      <span>‚ù§Ô∏è {item.like_count}</span>
                      <span>üí¨ {item.comments_count}</span>
                    </div>
                    <Button asChild size="sm" variant="ghost">
                      <a href={item.permalink} target="_blank" rel="noopener noreferrer">
                        <ExternalLink className="w-4 h-4" />
                      </a>
                    </Button>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
          {tags.length === 0 && (
            <Card>
              <CardContent className="p-8 text-center">
                <Tag className="w-12 h-12 mx-auto mb-4 text-muted-foreground" />
                <p className="text-muted-foreground">No hay menciones disponibles</p>
              </CardContent>
            </Card>
          )}
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/components/Instagram/InstagramDashboard.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Instagram, RefreshCw, Settings, AlertTriangle, CheckCircle, Clock, Zap } from "lucide-react";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { useInstagramSync } from "@/hooks/useInstagramSync";
import { useInstagramConnection } from "@/hooks/useInstagramConnection";
import { InstagramConnect } from "./InstagramConnect";
import { InstagramSyncStatus } from "./InstagramSyncStatus";
import { toast } from "sonner";

export function InstagramDashboard() {
  const { organization } = useCurrentOrganization();
  const { isSyncing, syncInstagramData, refreshToken } = useInstagramSync();
  const { isConnected, isTokenExpired, lastSync } = useInstagramConnection();
  const [webhookStatus, setWebhookStatus] = useState<'active' | 'inactive' | 'checking'>('checking');

  useEffect(() => {
    // Simulate webhook status check
    const checkWebhookStatus = () => {
      setWebhookStatus(isConnected ? 'active' : 'inactive');
    };
    
    checkWebhookStatus();
  }, [isConnected]);

  const handleSync = async () => {
    const success = await syncInstagramData();
    if (success) {
      toast.success('Datos sincronizados correctamente');
    }
  };

  const handleRefreshToken = async () => {
    const success = await refreshToken();
    if (success) {
      toast.success('Token renovado correctamente');
    }
  };

  const getConnectionStatus = () => {
    if (!isConnected) return { status: 'disconnected', color: 'destructive', icon: AlertTriangle };
    if (isTokenExpired) return { status: 'expired', color: 'warning', icon: Clock };
    return { status: 'connected', color: 'success', icon: CheckCircle };
  };

  const connectionStatus = getConnectionStatus();

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold">Instagram Dashboard</h2>
          <p className="text-muted-foreground">
            Gestiona la conexi√≥n e integraci√≥n con Instagram (Sync autom√°tico cada 5 minutos)
          </p>
        </div>
        <div className="flex items-center gap-2">
          {isConnected && (
            <>
              <Button 
                variant="outline" 
                size="sm" 
                onClick={handleRefreshToken}
                disabled={isSyncing}
              >
                <RefreshCw className={`w-4 h-4 ${isSyncing ? 'animate-spin' : ''}`} />
                Renovar Token
              </Button>
              <Button 
                onClick={handleSync}
                disabled={isSyncing}
                size="sm"
              >
                <Zap className={`w-4 h-4 ${isSyncing ? 'animate-spin' : ''}`} />
                {isSyncing ? 'Sincronizando...' : 'Sincronizar'}
              </Button>
            </>
          )}
        </div>
      </div>

      {/* Sync Status Cards */}
      {isConnected && <InstagramSyncStatus />}

      {/* Status Cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Estado de Conexi√≥n</CardTitle>
            <connectionStatus.icon className={`h-4 w-4 ${
              connectionStatus.color === 'success' ? 'text-green-600' :
              connectionStatus.color === 'warning' ? 'text-yellow-600' :
              'text-red-600'
            }`} />
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <Badge variant={connectionStatus.color === 'success' ? 'default' : 'destructive'}>
                {connectionStatus.status === 'connected' ? 'Conectado' :
                 connectionStatus.status === 'expired' ? 'Token Expirado' :
                 'Desconectado'}
              </Badge>
            </div>
            {lastSync && (
              <p className="text-xs text-muted-foreground mt-1">
                √öltima sync: {new Date(lastSync).toLocaleDateString()}
              </p>
            )}
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Webhooks</CardTitle>
            <Settings className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <Badge variant={webhookStatus === 'active' ? 'default' : 'secondary'}>
                {webhookStatus === 'active' ? 'Activos' : 
                 webhookStatus === 'inactive' ? 'Inactivos' : 'Verificando...'}
              </Badge>
            </div>
            <p className="text-xs text-muted-foreground mt-1">
              Estado de notificaciones en tiempo real
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">API Status</CardTitle>
            <Instagram className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <Badge variant="default">
                Operacional
              </Badge>
            </div>
            <p className="text-xs text-muted-foreground mt-1">
              Instagram Graph API v18.0 + Cron (5 min)
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Main Content */}
      <Tabs defaultValue="connection" className="space-y-4">
        <TabsList>
          <TabsTrigger value="connection">Conexi√≥n</TabsTrigger>
          <TabsTrigger value="webhooks">Webhooks</TabsTrigger>
          <TabsTrigger value="logs">Logs</TabsTrigger>
        </TabsList>

        <TabsContent value="connection" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Configuraci√≥n de Instagram</CardTitle>
              <CardDescription>
                Conecta tu cuenta business de Instagram para habilitar la sincronizaci√≥n autom√°tica cada 5 minutos
              </CardDescription>
            </CardHeader>
            <CardContent>
              <InstagramConnect
                type="organization"
                entityId={organization?.id || ''}
                organizationId={organization?.id}
                currentStatus={{
                  isConnected,
                  lastSync
                }}
                onConnectionChange={() => window.location.reload()}
              />
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="webhooks" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Configuraci√≥n de Webhooks</CardTitle>
              <CardDescription>
                Los webhooks est√°n configurados para recibir notificaciones en tiempo real de Instagram. 
                Adem√°s, el sistema sincroniza autom√°ticamente cada 5 minutos.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="p-4 border rounded-lg bg-muted/50">
                  <h4 className="font-medium mb-2">URL del Webhook</h4>
                  <code className="text-sm bg-background p-2 rounded block">
                    https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-webhook
                  </code>
                </div>
                
                <div className="p-4 border rounded-lg bg-muted/50">
                  <h4 className="font-medium mb-2">Sincronizaci√≥n Autom√°tica</h4>
                  <div className="flex items-center gap-2 mb-2">
                    <Badge variant="default">Activa - Cada 5 minutos</Badge>
                  </div>
                  <p className="text-sm text-muted-foreground">
                    El sistema ejecuta autom√°ticamente la sincronizaci√≥n de menciones y etiquetas cada 5 minutos
                  </p>
                </div>

                <div className="p-4 border rounded-lg bg-muted/50">
                  <h4 className="font-medium mb-2">Eventos Suscritos</h4>
                  <div className="flex flex-wrap gap-2">
                    {['comments', 'messages', 'messaging_postbacks', 'messaging_referral'].map((event) => (
                      <Badge key={event} variant="secondary">{event}</Badge>
                    ))}
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="logs" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Logs de Actividad</CardTitle>
              <CardDescription>
                Monitorea la actividad de webhooks e integraciones autom√°ticas
              </CardDescription>
            </CardHeader>
            <CardContent>
              {isTokenExpired ? (
                <div className="text-center py-8">
                  <AlertTriangle className="w-12 h-12 mx-auto mb-4 text-yellow-500" />
                  <p className="font-medium text-yellow-700">Token de Instagram Expirado</p>
                  <p className="text-sm text-muted-foreground mt-2">
                    Renueva tu token para continuar recibiendo datos de Instagram
                  </p>
                  <Button 
                    className="mt-4" 
                    variant="outline"
                    onClick={handleRefreshToken}
                    disabled={isSyncing}
                  >
                    <RefreshCw className={`w-4 h-4 mr-2 ${isSyncing ? 'animate-spin' : ''}`} />
                    Renovar Token Ahora
                  </Button>
                </div>
              ) : !isConnected ? (
                <div className="text-center py-8">
                  <Instagram className="w-12 h-12 mx-auto mb-4 text-muted-foreground" />
                  <p className="font-medium">Instagram No Conectado</p>
                  <p className="text-sm text-muted-foreground mt-2">
                    Conecta tu cuenta de Instagram para ver los logs de actividad
                  </p>
                </div>
              ) : (
                <div className="text-center py-8 text-muted-foreground">
                  <Instagram className="w-12 h-12 mx-auto mb-4 opacity-50" />
                  <p>Los logs aparecer√°n aqu√≠ cuando haya actividad de webhooks o sincronizaci√≥n autom√°tica</p>
                  <p className="text-sm mt-2">Pr√≥xima sincronizaci√≥n autom√°tica en menos de 5 minutos</p>
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/components/Instagram/InstagramSyncStatus.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Clock, Zap, RefreshCw, CheckCircle, AlertTriangle } from "lucide-react";
import { useInstagramSync } from "@/hooks/useInstagramSync";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { supabase } from "@/integrations/supabase/client";

export function InstagramSyncStatus() {
  const { organization } = useCurrentOrganization();
  const { isSyncing, syncInstagramData } = useInstagramSync();
  const [lastSync, setLastSync] = useState<string>('');
  const [syncStats, setSyncStats] = useState({
    todayMentions: 0,
    todayTags: 0,
    weeklyMentions: 0,
    isAutoSyncActive: true
  });

  useEffect(() => {
    if (!organization?.id) return;

    // Load last sync time
    if (organization.last_instagram_sync) {
      setLastSync(organization.last_instagram_sync);
    }

    // Load today's stats
    loadSyncStats();
  }, [organization]);

  const loadSyncStats = async () => {
    if (!organization?.id) return;

    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const weekAgo = new Date();
      weekAgo.setDate(weekAgo.getDate() - 7);

      // Get today's mentions and tags
      const { data: todayData } = await supabase
        .from('social_mentions')
        .select('mention_type')
        .eq('organization_id', organization.id)
        .gte('created_at', today.toISOString());

      // Get weekly mentions
      const { data: weeklyData } = await supabase
        .from('social_mentions')
        .select('id')
        .eq('organization_id', organization.id)
        .gte('created_at', weekAgo.toISOString());

      const todayMentions = todayData?.filter(m => m.mention_type === 'mention').length || 0;
      const todayTags = todayData?.filter(m => m.mention_type === 'tag').length || 0;
      const weeklyMentions = weeklyData?.length || 0;

      setSyncStats({
        todayMentions,
        todayTags,
        weeklyMentions,
        isAutoSyncActive: true
      });
    } catch (error) {
      console.error('Error loading sync stats:', error);
    }
  };

  const handleManualSync = async () => {
    const success = await syncInstagramData();
    if (success) {
      loadSyncStats();
    }
  };

  const getTimeSinceLastSync = () => {
    if (!lastSync) return 'Nunca';
    
    const now = new Date();
    const syncTime = new Date(lastSync);
    const diffMinutes = Math.floor((now.getTime() - syncTime.getTime()) / (1000 * 60));
    
    if (diffMinutes < 1) return 'Hace menos de 1 minuto';
    if (diffMinutes < 60) return `Hace ${diffMinutes} minutos`;
    if (diffMinutes < 1440) return `Hace ${Math.floor(diffMinutes / 60)} horas`;
    return `Hace ${Math.floor(diffMinutes / 1440)} d√≠as`;
  };

  const getSyncStatusColor = () => {
    if (!lastSync) return 'destructive';
    
    const now = new Date();
    const syncTime = new Date(lastSync);
    const diffMinutes = Math.floor((now.getTime() - syncTime.getTime()) / (1000 * 60));
    
    if (diffMinutes <= 10) return 'success';
    if (diffMinutes <= 60) return 'default';
    return 'warning';
  };

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Estado de Sync</CardTitle>
          {syncStats.isAutoSyncActive ? (
            <CheckCircle className="h-4 w-4 text-green-600" />
          ) : (
            <AlertTriangle className="h-4 w-4 text-yellow-600" />
          )}
        </CardHeader>
        <CardContent>
          <div className="flex items-center gap-2 mb-2">
            <Badge variant={getSyncStatusColor()}>
              {syncStats.isAutoSyncActive ? 'Activo (cada 5 min)' : 'Inactivo'}
            </Badge>
          </div>
          <p className="text-xs text-muted-foreground">
            √öltima sync: {getTimeSinceLastSync()}
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Hoy</CardTitle>
          <Clock className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {syncStats.todayMentions + syncStats.todayTags}
          </div>
          <p className="text-xs text-muted-foreground">
            {syncStats.todayMentions} menciones, {syncStats.todayTags} etiquetas
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Esta Semana</CardTitle>
          <Zap className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{syncStats.weeklyMentions}</div>
          <p className="text-xs text-muted-foreground">
            Total de interacciones
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Sync Manual</CardTitle>
          <RefreshCw className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <Button 
            onClick={handleManualSync}
            disabled={isSyncing}
            size="sm"
            className="w-full"
          >
            {isSyncing ? (
              <>
                <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
                Sincronizando...
              </>
            ) : (
              'Sincronizar Ahora'
            )}
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/Layout/AppBackground.tsx">
import { ReactNode } from "react";

interface AppBackgroundProps {
  children: ReactNode;
  variant?: "default" | "subtle";
}

export function AppBackground({ children, variant = "default" }: AppBackgroundProps) {
  const backgroundClass = variant === "subtle" 
    ? "min-h-screen bg-gradient-to-br from-gray-50/50 via-gray-100/30 to-gray-200/50"
    : "min-h-screen bg-gradient-to-br from-gray-50 via-gray-100 to-gray-200";

  return (
    <div className={backgroundClass}>
      {children}
      
      {/* Floating Elements for Futuristic Feel */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-1/4 left-1/4 w-2 h-2 bg-purple-400 rounded-full animate-pulse opacity-40"></div>
        <div className="absolute top-3/4 right-1/3 w-1 h-1 bg-blue-400 rounded-full animate-pulse opacity-30 delay-1000"></div>
        <div className="absolute bottom-1/3 left-1/5 w-1.5 h-1.5 bg-pink-400 rounded-full animate-pulse opacity-20 delay-500"></div>
        <div className="absolute top-1/2 right-1/4 w-1 h-1 bg-emerald-400 rounded-full animate-pulse opacity-25 delay-700"></div>
        <div className="absolute bottom-1/4 right-1/5 w-1.5 h-1.5 bg-cyan-400 rounded-full animate-pulse opacity-35 delay-300"></div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/Layout/GlassPanel.tsx">
import { ReactNode } from "react";
import { cn } from "@/lib/utils";

interface GlassPanelProps {
  children: ReactNode;
  className?: string;
  size?: "sm" | "md" | "lg" | "xl";
  variant?: "glass" | "solid";
}

export function GlassPanel({ children, className, size = "md", variant = "solid" }: GlassPanelProps) {
  const sizeClasses = {
    sm: "p-4 rounded-xl",
    md: "p-6 rounded-2xl", 
    lg: "p-8 rounded-3xl",
    xl: "p-10 rounded-3xl"
  };

  const variantClasses = {
    glass: "backdrop-blur-md bg-white/80 border-gray-200/50",
    solid: "bg-background border-border"
  };

  return (
    <div className={cn(
      "shadow-2xl animate-fade-in",
      sizeClasses[size],
      variantClasses[variant],
      className
    )}>
      {children}
    </div>
  );
}
</file>

<file path="src/components/Layout/LanguageSwitcher.tsx">
import { useState, useEffect } from 'react';
import { Globe } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { useTranslation } from 'react-i18next';

export function LanguageSwitcher({ className }: { className?: string }) {
  const { i18n } = useTranslation();
  const [currentLanguage, setCurrentLanguage] = useState(i18n.language);

  useEffect(() => {
    setCurrentLanguage(i18n.language);
  }, [i18n.language]);

  const changeLanguage = (lng: string) => {
    i18n.changeLanguage(lng);
    localStorage.setItem('eva-language', lng);
    // Force a page refresh to ensure all components pick up the new language
    setTimeout(() => window.location.reload(), 100);
  };

  const languages = [
    { code: 'es', name: 'Espa√±ol', flag: 'üá™üá∏' },
    { code: 'en', name: 'English', flag: 'üá∫üá∏' },
  ];

  const currentLang = languages.find(lang => lang.code === currentLanguage) || languages[0];

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="ghost"
          size="sm"
          className={`h-8 w-8 p-0 ${className}`}
        >
          <Globe className="h-4 w-4" />
          <span className="sr-only">Change language</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-40">
        {languages.map((language) => (
          <DropdownMenuItem
            key={language.code}
            onClick={() => changeLanguage(language.code)}
            className={`flex items-center gap-2 ${
              currentLanguage === language.code ? 'bg-accent' : ''
            }`}
          >
            <span className="text-sm">{language.flag}</span>
            <span className="text-sm">{language.name}</span>
          </DropdownMenuItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/Layout/MainLayout.tsx">
import { ReactNode } from "react";
import { Sidebar } from "./Sidebar";
import { FiestaSelector } from "@/components/Fiestas/FiestaSelector";
import { LanguageSwitcher } from "./LanguageSwitcher";
import { AppBackground } from "./AppBackground";
import { Button } from "@/components/ui/button";
import { Menu } from "lucide-react";
import { ModernLogo } from "@/components/Logo/ModernLogo";
import { NotificationDropdown } from "./NotificationDropdown";
import { useIsMobile } from "@/hooks/use-mobile";

interface MainLayoutProps {
  children: ReactNode;
}

export function MainLayout({ children }: MainLayoutProps) {
  const isMobile = useIsMobile();
  
  return (
    <AppBackground variant="subtle">
      <div className="flex min-h-screen w-full relative">
        <Sidebar />
        <main className="flex-1 flex flex-col overflow-hidden">
          {/* Top Header with Menu, Logo, Fiesta Selector, and Notifications */}
          <div className="border-b border-gray-200/50 bg-white/80 backdrop-blur-md supports-[backdrop-filter]:bg-white/60 shadow-sm">
            <div className="flex h-12 sm:h-14 items-center justify-between px-3 sm:px-4 md:px-6 gap-2 sm:gap-4">
              <div className="flex items-center gap-2 sm:gap-3 flex-1 min-w-0">
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => window.dispatchEvent(new CustomEvent('eva:sidebar-toggle'))}
                  className="h-8 w-8 shrink-0"
                  title="Alternar men√∫ lateral"
                >
                  <Menu className="h-4 w-4" />
                </Button>
                {isMobile && (
                  <div className="shrink-0">
                    <ModernLogo size="sm" />
                  </div>
                )}
                <div className="flex-1 min-w-0">
                  <FiestaSelector className="w-full" />
                </div>
              </div>
              <div className="flex items-center gap-2 shrink-0">
                <NotificationDropdown />
                <LanguageSwitcher />
              </div>
            </div>
          </div>
          
          <div className="flex-1 overflow-y-auto p-3 sm:p-4 md:p-6 lg:p-8">
            {children}
          </div>
        </main>
      </div>
    </AppBackground>
  );
}
</file>

<file path="src/components/Layout/NotificationDropdown.tsx">
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Bell, Check, AlertCircle, Info, Calendar, Users } from "lucide-react";
import { useRealNotifications } from "@/hooks/useRealNotifications";
import { cn } from "@/lib/utils";
import { toast } from "sonner";

export function NotificationDropdown() {
  const { notifications, unreadCount, markAsRead, markAllAsRead, loading } = useRealNotifications();

  const handleMarkAsRead = async (notificationId: string) => {
    await markAsRead(notificationId);
    toast.success("Notificaci√≥n marcada como le√≠da");
  };

  const handleMarkAllAsRead = async () => {
    await markAllAsRead();
    toast.success("Todas las notificaciones marcadas como le√≠das");
  };

  const getNotificationIcon = (type: string) => {
    const icons: Record<string, any> = {
      info: Info,
      warning: AlertCircle,
      event: Calendar,
      ambassador: Users,
      system: Bell,
    };
    const Icon = icons[type] || Info;
    return <Icon className="w-4 h-4" />;
  };

  const getPriorityColor = (priority: string) => {
    const colors: Record<string, string> = {
      high: "text-destructive",
      normal: "text-foreground",
      low: "text-muted-foreground",
    };
    return colors[priority] || colors.normal;
  };

  const formatTimeAgo = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffInMinutes = Math.floor((now.getTime() - date.getTime()) / (1000 * 60));

    if (diffInMinutes < 1) return 'Ahora';
    if (diffInMinutes < 60) return `${diffInMinutes}m`;
    if (diffInMinutes < 1440) return `${Math.floor(diffInMinutes / 60)}h`;
    return `${Math.floor(diffInMinutes / 1440)}d`;
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="sm" className="relative">
          <Bell className="w-5 h-5" />
          {unreadCount > 0 && (
            <Badge 
              variant="destructive" 
              className="absolute -top-1 -right-1 w-5 h-5 p-0 text-xs flex items-center justify-center"
            >
              {unreadCount > 9 ? '9+' : unreadCount}
            </Badge>
          )}
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownMenuContent align="end" className="w-80 z-50 bg-background border">
        <div className="px-3 py-2 border-b">
          <div className="flex items-center justify-between">
            <h3 className="font-semibold">Notificaciones</h3>
            {unreadCount > 0 && (
              <div className="flex items-center gap-2">
                <Badge variant="secondary">{unreadCount} nuevas</Badge>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={handleMarkAllAsRead}
                  className="text-xs h-auto p-1"
                >
                  <Check className="w-3 h-3 mr-1" />
                  Marcar todas
                </Button>
              </div>
            )}
          </div>
        </div>
        
        <ScrollArea className="h-96">
          {loading ? (
            <div className="p-4 text-center text-muted-foreground">
              Cargando...
            </div>
          ) : notifications.length === 0 ? (
            <div className="p-4 text-center text-muted-foreground">
              No hay notificaciones
            </div>
          ) : (
            <div className="space-y-1 p-1">
              {notifications.map((notification) => (
                <div
                  key={notification.id}
                  className={cn(
                    "flex items-start gap-3 p-3 rounded-lg cursor-pointer transition-colors hover:bg-accent",
                    !notification.read_status && "bg-primary/5"
                  )}
                  onClick={() => {
                    if (!notification.read_status) {
                      handleMarkAsRead(notification.id);
                    }
                  }}
                >
                  <div className={cn("mt-0.5", getPriorityColor(notification.priority))}>
                    {getNotificationIcon(notification.type)}
                  </div>
                  
                  <div className="flex-1 space-y-1">
                    <p className="text-sm leading-tight">
                      {notification.message}
                    </p>
                    <div className="flex items-center justify-between">
                      <span className="text-xs text-muted-foreground">
                        {formatTimeAgo(notification.created_at)}
                      </span>
                      {!notification.read_status && (
                        <Badge variant="secondary" className="text-xs px-1 py-0">
                          Nueva
                        </Badge>
                      )}
                    </div>
                  </div>
                  
                  {!notification.read_status && (
                    <Button
                      variant="ghost"
                      size="sm"
                      className="p-1 h-auto"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleMarkAsRead(notification.id);
                      }}
                    >
                      <Check className="w-3 h-3" />
                    </Button>
                  )}
                </div>
              ))}
            </div>
          )}
        </ScrollArea>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/Layout/PageHeader.tsx">
import { ReactNode } from "react";
import { cn } from "@/lib/utils";

interface PageHeaderProps {
  title: string;
  description?: string;
  children?: ReactNode;
  className?: string;
}

export function PageHeader({ title, description, children, className }: PageHeaderProps) {
  return (
    <div className={cn("mb-8", className)}>
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div className="space-y-2">
          <h1 className="text-3xl lg:text-4xl font-bold bg-gradient-to-r from-gray-900 via-gray-700 to-gray-600 bg-clip-text text-transparent animate-fade-in">
            {title}
          </h1>
          {description && (
            <p className="text-gray-600 text-lg animate-fade-in">
              {description}
            </p>
          )}
        </div>
        {children && (
          <div className="animate-fade-in">
            {children}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/Layout/Sidebar.tsx">
import { useState, useEffect } from "react";
import { Link, useLocation } from "react-router-dom";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import {
  LayoutDashboard,
  Instagram,
  Hash,
  BarChart3,
  Calendar,
  Users,
  Settings,
  ChevronLeft,
  ChevronRight,
  Download,
  Menu,
  Building2,
  MessageCircle,
  Activity
} from "lucide-react";
import { ModernLogo } from "@/components/Logo/ModernLogo";
import { UserProfileDropdown } from "./UserProfileDropdown";
import { OrganizationSwitcher } from "@/components/Organizations/OrganizationSwitcher";
import { useIsMobile } from "@/hooks/use-mobile";
import { useTranslation } from "react-i18next";

const navigation = [
  { name: "dashboard", href: "/", icon: LayoutDashboard },
  { name: "stories", href: "/stories", icon: Instagram },
  { name: "mentions", href: "/mentions", icon: Hash },
  { name: "storyMentions", href: "/story-mentions", icon: MessageCircle },
  { name: "analytics", href: "/analytics", icon: BarChart3 },
  { name: "events", href: "/events", icon: Calendar },
  { name: "ambassadors", href: "/ambassadors", icon: Users },
];

const secondaryNavigation = [
  { name: "settings", href: "/settings", icon: Settings },
  { name: "importExport", href: "/import-export", icon: Download },
  { name: "diagnostics", href: "/instagram-diagnostics", icon: Activity },
];

interface SidebarProps {
  className?: string;
}

function SidebarContent({ collapsed, onNavigate, showHeader = true }: { collapsed?: boolean; onNavigate?: () => void; showHeader?: boolean }) {
  const location = useLocation();
  const { t } = useTranslation('common');

  return (
    <>
      {/* Header - only show if showHeader is true */}
      {showHeader && (
        <div className="flex h-16 items-center justify-center px-4 border-b">
          <ModernLogo size={collapsed ? "sm" : "md"} />
        </div>
      )}

      {/* Organization Switcher - only show if not collapsed */}
      {!collapsed && (
        <div className="px-4 py-3 border-b">
          <OrganizationSwitcher />
        </div>
      )}

      {/* Navigation */}
      <div className="flex-1 overflow-y-auto py-4">
        <nav className="px-2 space-y-1">
          {navigation.map((item) => {
            const Icon = item.icon;
            const isActive = location.pathname === item.href;
            
            return (
              <Link
                key={item.name}
                to={item.href}
                onClick={onNavigate}
                className={cn(
                  "flex items-center px-3 py-2 text-sm font-medium rounded-lg transition-all duration-200",
                  isActive
                    ? "sidebar-item-active"
                    : "text-muted-foreground hover:text-foreground sidebar-item-hover"
                )}
              >
                <Icon className={cn("flex-shrink-0", collapsed ? "w-5 h-5" : "mr-3 w-5 h-5")} />
                {!collapsed && <span>{t(item.name)}</span>}
              </Link>
            );
          })}
        </nav>

        {/* Divider */}
        <div className="my-4 mx-2">
          <div className="h-px bg-border" />
        </div>

        {/* Secondary Navigation */}
        <nav className="px-2 space-y-1">
          {secondaryNavigation.map((item) => {
            const Icon = item.icon;
            const isActive = location.pathname === item.href;
            
            return (
              <Link
                key={item.name}
                to={item.href}
                onClick={onNavigate}
                className={cn(
                  "flex items-center px-3 py-2 text-sm font-medium rounded-lg transition-all duration-200",
                  isActive
                    ? "sidebar-item-active"
                    : "text-muted-foreground hover:text-foreground sidebar-item-hover"
                )}
              >
                <Icon className={cn("flex-shrink-0", collapsed ? "w-5 h-5" : "mr-3 w-5 h-5")} />
                {!collapsed && <span>{t(item.name)}</span>}
              </Link>
            );
          })}
        </nav>
      </div>

      {/* Footer */}
      <div className="p-4 border-t space-y-3">
        {/* User Profile */}
        {!collapsed && <UserProfileDropdown />}
        
        {/* Instagram Status */}
        {!collapsed && (
          <div className="bg-gradient-card rounded-lg p-3 border border-primary/20">
            <div className="text-sm font-medium">Conectado a Instagram</div>
            <div className="text-xs text-muted-foreground mt-1">
              Token v√°lido hasta: 30 d√≠as
            </div>
            <div className="w-full bg-secondary rounded-full h-2 mt-2">
              <div className="bg-gradient-primary h-2 rounded-full w-4/5" />
            </div>
          </div>
        )}
      </div>
    </>
  );
}

export function Sidebar({ className }: SidebarProps) {
  const [collapsed, setCollapsed] = useState(() => {
    const saved = localStorage.getItem('eva-sidebar-collapsed');
    return saved ? JSON.parse(saved) : false;
  });
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const isMobile = useIsMobile();

  // Save collapsed state to localStorage
  useEffect(() => {
    localStorage.setItem('eva-sidebar-collapsed', JSON.stringify(collapsed));
  }, [collapsed]);

  // Close mobile menu when route changes and prefetch routes
  useEffect(() => {
    setMobileMenuOpen(false);
    
    // Prefetch critical routes on idle
    const prefetchRoutes = () => {
      const routes = ['/mentions', '/ambassadors', '/events', '/analytics'];
      routes.forEach(route => {
        if (location.pathname !== route) {
          // Prefetch route by creating a temporary link element
          const link = document.createElement('link');
          link.rel = 'prefetch';
          link.href = route;
          document.head.appendChild(link);
          setTimeout(() => document.head.removeChild(link), 100);
        }
      });
    };

    // Prefetch after a short delay to not interfere with current navigation
    const timeout = setTimeout(prefetchRoutes, 1000);
    return () => clearTimeout(timeout);
  }, [location.pathname]);

  // Keyboard shortcut and toggle event handler
  useEffect(() => {
    const handleToggle = () => {
      if (isMobile) {
        setMobileMenuOpen(prev => !prev);
      } else {
        setCollapsed(prev => {
          const newValue = !prev;
          localStorage.setItem('eva-sidebar-collapsed', JSON.stringify(newValue));
          return newValue;
        });
      }
    };

    const handleKeyboard = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
        e.preventDefault();
        handleToggle();
      }
    };

    const handleCustomToggle = () => {
      handleToggle();
    };

    document.addEventListener('keydown', handleKeyboard);
    window.addEventListener('eva:sidebar-toggle', handleCustomToggle);

    return () => {
      document.removeEventListener('keydown', handleKeyboard);
      window.removeEventListener('eva:sidebar-toggle', handleCustomToggle);
    };
  }, [collapsed, isMobile]);

  // Listen for storage changes to sync sidebar state
  useEffect(() => {
    const handleStorageChange = (event: StorageEvent) => {
      if (event.key === 'eva-sidebar-collapsed' && event.newValue) {
        setCollapsed(JSON.parse(event.newValue));
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, []);

  if (isMobile) {
    return (
      <>
        {/* Mobile menu */}
        <Sheet open={mobileMenuOpen} onOpenChange={setMobileMenuOpen}>
          <SheetContent side="left" className="p-0 w-64">
            <SidebarContent 
              collapsed={false} 
              onNavigate={() => setMobileMenuOpen(false)} 
              showHeader={true}
            />
          </SheetContent>
        </Sheet>
      </>
    );
  }

  return (
    <div
      className={cn(
        "hidden lg:flex lg:flex-col border-r bg-background transition-all duration-300",
        collapsed ? "w-16" : "w-64",
        className
      )}
    >
      {/* Header */}
      <div className="flex h-16 items-center justify-between px-4 border-b">
        <div className="flex items-center justify-center w-full">
          <ModernLogo size={collapsed ? "sm" : "md"} />
        </div>
        <div className="flex items-center gap-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setCollapsed(!collapsed)}
            className="h-8 w-8"
          >
            {collapsed ? (
              <ChevronRight className="h-4 w-4" />
            ) : (
              <ChevronLeft className="h-4 w-4" />
            )}
          </Button>
        </div>
      </div>

      <SidebarContent collapsed={collapsed} showHeader={false} />
    </div>
  );
}
</file>

<file path="src/components/Layout/UserProfileDropdown.tsx">
import { useState, useEffect } from "react";
import { Link } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { User, Settings, LogOut, Shield } from "lucide-react";
import { useAuth } from "@/hooks/useAuth";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

interface UserData {
  id: string;
  name: string;
  email: string;
  organization_id: string;
}

export function UserProfileDropdown() {
  const { user, signOut } = useAuth();
  const [userData, setUserData] = useState<UserData | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (user) {
      fetchUserData();
    } else {
      setLoading(false);
    }
  }, [user]);

  const fetchUserData = async () => {
    try {
      if (!user) return;

      const { data: userRecord, error } = await supabase
        .from('users')
        .select('id, name, email, organization_id')
        .eq('auth_user_id', user.id)
        .maybeSingle();

      if (error) throw error;
      if (userRecord) {
        setUserData(userRecord);
      }
    } catch (error) {
      console.error('Error fetching user data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSignOut = async () => {
    try {
      // Don't call signOut here, just use the hook's signOut which handles everything
      await signOut();
    } catch (error) {
      console.error('Error signing out:', error);
      toast.error('Error al cerrar sesi√≥n');
    }
  };

  if (loading || !user || !userData) {
    return null;
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          className="flex items-center gap-2 p-2 h-auto hover:bg-accent rounded-lg"
        >
          <Avatar className="w-8 h-8">
            <AvatarImage src="" />
            <AvatarFallback className="text-xs">
              {userData.name.split(' ').map(n => n[0]).join('').toUpperCase()}
            </AvatarFallback>
          </Avatar>
          <div className="flex flex-col items-start text-left">
            <span className="text-sm font-medium">{userData.name}</span>
            <div className="flex items-center gap-1">
              <Badge variant="secondary" className="text-xs px-1 py-0">
                Usuario
              </Badge>
            </div>
          </div>
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownMenuContent align="start" className="w-56 z-50 bg-background border">
        <div className="px-2 py-1.5">
          <p className="text-sm font-medium">{userData.name}</p>
          <p className="text-xs text-muted-foreground">{userData.email}</p>
        </div>
        
        <DropdownMenuSeparator />
        
        <DropdownMenuItem asChild>
          <Link to="/profile" className="flex items-center gap-2">
            <User className="w-4 h-4" />
            Mi Perfil
          </Link>
        </DropdownMenuItem>
        
        <DropdownMenuItem asChild>
          <Link to="/settings" className="flex items-center gap-2">
            <Settings className="w-4 h-4" />
            Configuraciones
          </Link>
        </DropdownMenuItem>
        
        <DropdownMenuItem asChild>
          <Link to="/system-config" className="flex items-center gap-2">
            <Shield className="w-4 h-4" />
            Sistema
          </Link>
        </DropdownMenuItem>
        
        <DropdownMenuSeparator />
        
        <DropdownMenuItem onClick={handleSignOut} className="text-destructive">
          <LogOut className="w-4 h-4 mr-2" />
          Cerrar Sesi√≥n
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/Logo/ModernLogo.tsx">
import React from 'react';

interface ModernLogoProps {
  size?: 'sm' | 'md' | 'lg' | 'xl';
  className?: string;
}

export const ModernLogo: React.FC<ModernLogoProps> = ({ size = 'md', className = '' }) => {
  const sizeClasses = {
    sm: 'w-8 h-10',
    md: 'w-12 h-16',
    lg: 'w-20 h-24',
    xl: 'w-32 h-40'
  };

  return (
    <div className={`${sizeClasses[size]} ${className} relative`}>
      <svg
        viewBox="0 0 100 120"
        className="w-full h-full"
        xmlns="http://www.w3.org/2000/svg"
      >
        {/* Gradient definitions */}
        <defs>
          <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="hsl(269, 100%, 18%)" />
            <stop offset="50%" stopColor="hsl(269, 100%, 25%)" />
            <stop offset="100%" stopColor="hsl(269, 100%, 35%)" />
          </linearGradient>
          <linearGradient id="logoGradient2" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="hsl(269, 100%, 35%)" />
            <stop offset="50%" stopColor="hsl(269, 100%, 45%)" />
            <stop offset="100%" stopColor="hsl(269, 100%, 55%)" />
          </linearGradient>
        </defs>
        
        {/* Left triangle - darker */}
        <path
          d="M10 10 L10 110 L60 60 Z"
          fill="url(#logoGradient)"
          className="drop-shadow-lg"
        />
        
        {/* Right section - lighter */}
        <path
          d="M60 60 L60 110 L90 110 L90 10 Z"
          fill="url(#logoGradient2)"
          className="drop-shadow-lg"
        />
      </svg>
    </div>
  );
};
</file>

<file path="src/components/Mentions/MentionsManagement.tsx">
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { RefreshCw } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { useMentionsManagement } from "@/hooks/useMentionsManagement";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";

export function MentionsManagement() {
  const { mentions, stats, loading, error } = useMentionsManagement();
  const { organization } = useCurrentOrganization();
  const [isManualSync, setIsManualSync] = useState(false);

  const handleManualSync = async () => {
    if (!organization) {
      toast.error("No hay organizaci√≥n seleccionada");
      return;
    }

    setIsManualSync(true);
    try {
      const { data, error } = await supabase.functions.invoke('instagram-sync', {
        body: { organization_id: organization.id }
      });

      if (error) {
        throw error;
      }

      if (data?.success) {
        toast.success(`Sincronizaci√≥n completada: ${data.totalProcessed} organizaciones procesadas`);
        // The real-time hook should automatically refresh the data
      } else {
        toast.error("Error en la sincronizaci√≥n");
      }
    } catch (error: any) {
      console.error('Sync error:', error);
      toast.error(`Error: ${error.message || 'Error desconocido'}`);
    } finally {
      setIsManualSync(false);
    }
  };

  if (loading) {
    return (
      <div className="space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
          {[...Array(4)].map((_, i) => (
            <div key={i} className="p-4 bg-white/50 rounded-lg">
              <Skeleton className="h-16 w-full" />
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (!organization) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Menciones y Tags</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-center py-8">
            <p className="text-muted-foreground mb-4">
              Selecciona una organizaci√≥n para ver las menciones de Instagram
            </p>
          </div>
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Error</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-center py-8">
            <p className="text-destructive mb-4">{error}</p>
            <Button onClick={() => window.location.reload()}>
              Reintentar
            </Button>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="space-y-6">
      {/* Stats and Manual Sync */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Total Menciones</p>
                <p className="text-2xl font-bold">{stats.total.toLocaleString()}</p>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Alcance Total</p>
                <p className="text-2xl font-bold">
                  {stats.reach > 1000 ? 
                    `${(stats.reach / 1000).toFixed(1)}K` : 
                    stats.reach.toLocaleString()
                  }
                </p>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Sin Asignar</p>
                <p className="text-2xl font-bold">{stats.unassigned}</p>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Sincronizaci√≥n</p>
                <Button 
                  onClick={handleManualSync} 
                  disabled={isManualSync}
                  size="sm"
                  className="mt-1"
                >
                  {isManualSync ? (
                    <>
                      <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
                      Sincronizando...
                    </>
                  ) : (
                    <>
                      <RefreshCw className="w-4 h-4 mr-2" />
                      Sincronizar
                    </>
                  )}
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Mentions List */}
      <Card>
        <CardHeader>
          <CardTitle>Menciones Recientes de Instagram</CardTitle>
        </CardHeader>
        <CardContent>
          {mentions.length > 0 ? (
            <div className="space-y-4">
              {mentions.map((mention) => (
                <div key={mention.id} className="p-4 border rounded-lg hover:bg-muted/50 transition-colors">
                  <div className="flex items-start justify-between mb-3">
                    <div className="flex items-center space-x-3">
                      <div className="w-10 h-10 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full flex items-center justify-center">
                        <span className="text-white font-medium text-sm">
                          {mention.ambassador_name ? 
                            mention.ambassador_name.split(' ').map(n => n[0]).join('') :
                            mention.instagram_username.substring(0, 2).toUpperCase()
                          }
                        </span>
                      </div>
                      <div>
                        <h4 className="font-medium">
                          {mention.ambassador_name || `@${mention.instagram_username}`}
                        </h4>  
                        <p className="text-sm text-muted-foreground">@{mention.instagram_username}</p>
                      </div>
                    </div>
                    <div className="flex items-center space-x-2">
                      <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                        mention.mention_type === 'mention' 
                          ? 'bg-blue-100 text-blue-800' 
                          : 'bg-green-100 text-green-800'
                      }`}>
                        {mention.mention_type === 'mention' ? 'Menci√≥n' : 'Tag'}
                      </span>
                      <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                        mention.processed 
                          ? 'bg-green-100 text-green-800' 
                          : 'bg-yellow-100 text-yellow-800'
                      }`}>
                        {mention.processed ? 'Procesada' : 'Pendiente'}
                      </span>
                    </div>
                  </div>
                  
                  {mention.content && (
                    <p className="text-sm mb-3 bg-muted p-3 rounded-lg">
                      {mention.content}
                    </p>
                  )}
                  
                  <div className="flex items-center justify-between text-sm text-muted-foreground">
                    <div className="flex items-center space-x-4">
                      <span>Alcance: {mention.reach_count.toLocaleString()}</span>
                      <span>Engagement: {mention.engagement_score}%</span>
                    </div>
                    <span>{new Date(mention.created_at).toLocaleDateString('es-ES')}</span>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-8 text-muted-foreground">
              <p className="mb-4">No hay menciones registradas a√∫n</p>
              <p className="text-sm mb-4">
                Haz clic en "Sincronizar" para buscar nuevas menciones de Instagram
              </p>
              <Button 
                onClick={handleManualSync} 
                disabled={isManualSync}
                variant="outline"
              >
                {isManualSync ? (
                  <>
                    <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
                    Sincronizando...
                  </>
                ) : (
                  <>
                    <RefreshCw className="w-4 h-4 mr-2" />
                    Sincronizar Ahora
                  </>
                )}
              </Button>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/N8n/N8nIntegration.tsx">
import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { Webhook, Send, Link, CheckCircle, AlertCircle } from "lucide-react";
import { toast } from "sonner";

interface N8nEndpoint {
  id: string;
  name: string;
  description: string;
  url: string;
  method: 'POST' | 'GET' | 'PUT' | 'DELETE';
  active: boolean;
}

export default function N8nIntegration() {
  const [endpoints] = useState<N8nEndpoint[]>([
    {
      id: '1',
      name: 'Crear Evento',
      description: 'Webhook para crear eventos y asociar embajadores',
      url: 'https://n8n.your-domain.com/webhook/create-event',
      method: 'POST',
      active: true
    },
    {
      id: '2',
      name: 'Importar Embajadores',
      description: 'Webhook para importar embajadores desde archivos',
      url: 'https://n8n.your-domain.com/webhook/import-ambassadors',
      method: 'POST',
      active: true
    },
    {
      id: '3',
      name: 'Sincronizar Instagram',
      description: 'Webhook para sincronizar datos de Instagram',
      url: 'https://n8n.your-domain.com/webhook/sync-instagram',
      method: 'POST',
      active: false
    }
  ]);

  const [testData, setTestData] = useState('');
  const [selectedEndpoint, setSelectedEndpoint] = useState<N8nEndpoint | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const testWebhook = async (endpoint: N8nEndpoint) => {
    if (!testData.trim()) {
      toast.error('Ingresa datos de prueba en formato JSON');
      return;
    }

    try {
      setIsLoading(true);
      
      let parsedData;
      try {
        parsedData = JSON.parse(testData);
      } catch (error) {
        toast.error('Formato JSON inv√°lido');
        return;
      }

      const response = await fetch(endpoint.url, {
        method: endpoint.method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(parsedData),
      });

      if (response.ok) {
        const result = await response.json();
        toast.success(`Webhook ejecutado exitosamente: ${endpoint.name}`);
        console.log('Webhook response:', result);
      } else {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
    } catch (error) {
      console.error('Webhook test error:', error);
      toast.error(`Error al ejecutar webhook: ${error}`);
    } finally {
      setIsLoading(false);
    }
  };

  const copyWebhookUrl = (url: string) => {
    navigator.clipboard.writeText(url);
    toast.success('URL copiada al portapapeles');
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Webhook className="w-5 h-5" />
            Integraci√≥n n8n
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <p className="text-sm text-muted-foreground">
              Configura y prueba los webhooks de n8n para automatizar los flujos del sistema EVA.
            </p>
            
            <div className="grid gap-4">
              {endpoints.map((endpoint) => (
                <div key={endpoint.id} className="border rounded-lg p-4">
                  <div className="flex items-start justify-between mb-2">
                    <div>
                      <div className="flex items-center gap-2">
                        <h4 className="font-semibold">{endpoint.name}</h4>
                        <Badge variant={endpoint.active ? "default" : "secondary"}>
                          {endpoint.method}
                        </Badge>
                        {endpoint.active ? (
                          <CheckCircle className="w-4 h-4 text-green-500" />
                        ) : (
                          <AlertCircle className="w-4 h-4 text-yellow-500" />
                        )}
                      </div>
                      <p className="text-sm text-muted-foreground mt-1">
                        {endpoint.description}
                      </p>
                    </div>
                  </div>
                  
                  <div className="flex items-center gap-2 mt-3">
                    <code className="flex-1 text-xs bg-muted p-2 rounded">
                      {endpoint.url}
                    </code>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => copyWebhookUrl(endpoint.url)}
                    >
                      <Link className="w-4 h-4" />
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setSelectedEndpoint(endpoint)}
                      disabled={!endpoint.active}
                    >
                      Probar
                    </Button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </CardContent>
      </Card>

      {selectedEndpoint && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Send className="w-5 h-5" />
              Probar Webhook: {selectedEndpoint.name}
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <Label>Datos de prueba (JSON)</Label>
              <Textarea
                placeholder='{"title": "Evento de prueba", "description": "Descripci√≥n del evento"}'
                value={testData}
                onChange={(e) => setTestData(e.target.value)}
                className="mt-1 font-mono text-sm"
                rows={8}
              />
            </div>
            
            <div className="flex gap-2">
              <Button
                onClick={() => testWebhook(selectedEndpoint)}
                disabled={isLoading}
              >
                {isLoading ? 'Enviando...' : 'Enviar Webhook'}
              </Button>
              <Button
                variant="outline"
                onClick={() => setSelectedEndpoint(null)}
              >
                Cancelar
              </Button>
            </div>
            
            <Separator />
            
            <div className="text-sm text-muted-foreground">
              <h5 className="font-medium mb-2">Ejemplos de datos:</h5>
              
              {selectedEndpoint.name === 'Crear Evento' && (
                <pre className="bg-muted p-3 rounded text-xs overflow-x-auto">
{`{
  "title": "Lanzamiento Producto X",
  "description": "Evento de lanzamiento",
  "date": "2024-02-15",
  "location": "Centro de Convenciones",
  "embassadors": ["uuid1", "uuid2"],
  "user_id": "user-uuid"
}`}
                </pre>
              )}
              
              {selectedEndpoint.name === 'Importar Embajadores' && (
                <pre className="bg-muted p-3 rounded text-xs overflow-x-auto">
{`{
  "embassadors": [
    {
      "name": "Juan P√©rez",
      "email": "juan@email.com",
      "phone": "+56912345678",
      "events": ["event-uuid"]
    }
  ],
  "user_id": "user-uuid"
}`}
                </pre>
              )}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="src/components/Notifications/NotificationCenter.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import {
  Bell,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Instagram,
  Clock,
  User,
  Calendar,
  Filter,
  Check,
  Trash2,
  ExternalLink,
  Search
} from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";

interface Notification {
  id: string;
  type: "story_deleted" | "task_expired" | "token_expiring" | "performance_change" | "ambassador_pending" | "general";
  message: string;
  priority: "low" | "normal" | "high";
  read_status: boolean;
  created_at: string;
  target_type: "user" | "ambassador" | "event" | "organization";
  target_id?: string;
  metadata?: {
    ambassador_name?: string;
    event_name?: string;
    days_remaining?: number;
    old_performance?: string;
    new_performance?: string;
  };
}

export function NotificationCenter() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [filteredNotifications, setFilteredNotifications] = useState<Notification[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedTab, setSelectedTab] = useState("all");
  const [priorityFilter, setPriorityFilter] = useState("all");
  const [searchQuery, setSearchQuery] = useState("");
  const { toast } = useToast();

  useEffect(() => {
    loadNotifications();
  }, []);

  useEffect(() => {
    filterNotifications();
  }, [notifications, selectedTab, priorityFilter, searchQuery]);

  const loadNotifications = async () => {
    try {
      setLoading(true);
      
      // Mock data for demonstration - replace with real Supabase queries
      const mockNotifications: Notification[] = [
        {
          id: "1",
          type: "token_expiring",
          message: "Tu token de Instagram expira en 3 d√≠as",
          priority: "high",
          read_status: false,
          created_at: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
          target_type: "organization",
          metadata: { days_remaining: 3 }
        },
        {
          id: "2",
          type: "story_deleted",
          message: "Historia eliminada antes de 24h por Mar√≠a Gonz√°lez",
          priority: "normal",
          read_status: false,
          created_at: new Date(Date.now() - 4 * 60 * 60 * 1000).toISOString(),
          target_type: "ambassador",
          target_id: "amb1",
          metadata: { ambassador_name: "Mar√≠a Gonz√°lez", event_name: "Campa√±a Verano" }
        },
        {
          id: "3",
          type: "ambassador_pending",
          message: "Nuevo embajador detectado: Carlos Ruiz requiere aprobaci√≥n",
          priority: "normal",
          read_status: true,
          created_at: new Date(Date.now() - 6 * 60 * 60 * 1000).toISOString(),
          target_type: "ambassador",
          target_id: "amb2",
          metadata: { ambassador_name: "Carlos Ruiz" }
        },
        {
          id: "4",
          type: "task_expired",
          message: "Tareas vencidas en evento 'Black Friday'",
          priority: "high",
          read_status: false,
          created_at: new Date(Date.now() - 8 * 60 * 60 * 1000).toISOString(),
          target_type: "event",
          target_id: "event1",
          metadata: { event_name: "Black Friday" }
        },
        {
          id: "5",
          type: "performance_change",
          message: "Ana Silva cambi√≥ de 'cumple' a 'advertencia'",
          priority: "normal",
          read_status: true,
          created_at: new Date(Date.now() - 12 * 60 * 60 * 1000).toISOString(),
          target_type: "ambassador",
          target_id: "amb3",
          metadata: { 
            ambassador_name: "Ana Silva", 
            old_performance: "cumple", 
            new_performance: "advertencia" 
          }
        }
      ];

      setNotifications(mockNotifications);
    } catch (error) {
      console.error("Error loading notifications:", error);
      toast({
        title: "Error",
        description: "No se pudieron cargar las notificaciones",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  const filterNotifications = () => {
    let filtered = notifications;

    // Filter by tab
    if (selectedTab !== "all") {
      if (selectedTab === "unread") {
        filtered = filtered.filter(n => !n.read_status);
      } else {
        filtered = filtered.filter(n => n.type === selectedTab);
      }
    }

    // Filter by priority
    if (priorityFilter !== "all") {
      filtered = filtered.filter(n => n.priority === priorityFilter);
    }

    // Filter by search query
    if (searchQuery) {
      filtered = filtered.filter(n => 
        n.message.toLowerCase().includes(searchQuery.toLowerCase()) ||
        (n.metadata?.ambassador_name && n.metadata.ambassador_name.toLowerCase().includes(searchQuery.toLowerCase())) ||
        (n.metadata?.event_name && n.metadata.event_name.toLowerCase().includes(searchQuery.toLowerCase()))
      );
    }

    setFilteredNotifications(filtered);
  };

  const markAsRead = async (notificationId: string) => {
    try {
      setNotifications(prev => 
        prev.map(n => 
          n.id === notificationId 
            ? { ...n, read_status: true }
            : n
        )
      );

      toast({
        title: "Notificaci√≥n marcada como le√≠da",
        description: "La notificaci√≥n ha sido marcada como le√≠da"
      });
    } catch (error) {
      console.error("Error marking notification as read:", error);
    }
  };

  const markAllAsRead = async () => {
    try {
      setNotifications(prev => 
        prev.map(n => ({ ...n, read_status: true }))
      );

      toast({
        title: "Todas las notificaciones marcadas como le√≠das",
        description: "Se han marcado todas las notificaciones como le√≠das"
      });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
    }
  };

  const deleteNotification = async (notificationId: string) => {
    try {
      setNotifications(prev => 
        prev.filter(n => n.id !== notificationId)
      );

      toast({
        title: "Notificaci√≥n eliminada",
        description: "La notificaci√≥n ha sido eliminada"
      });
    } catch (error) {
      console.error("Error deleting notification:", error);
    }
  };

  const getNotificationIcon = (type: string, priority: string) => {
    const iconClass = priority === "high" ? "text-destructive" : 
                     priority === "normal" ? "text-warning" : "text-muted-foreground";

    switch (type) {
      case "story_deleted":
        return <Instagram className={`w-4 h-4 ${iconClass}`} />;
      case "task_expired":
        return <Clock className={`w-4 h-4 ${iconClass}`} />;
      case "token_expiring":
        return <AlertTriangle className={`w-4 h-4 ${iconClass}`} />;
      case "performance_change":
        return <User className={`w-4 h-4 ${iconClass}`} />;
      case "ambassador_pending":
        return <User className={`w-4 h-4 ${iconClass}`} />;
      default:
        return <Bell className={`w-4 h-4 ${iconClass}`} />;
    }
  };

  const getPriorityBadge = (priority: string) => {
    switch (priority) {
      case "high":
        return <Badge variant="destructive" className="text-xs">Alta</Badge>;
      case "normal":
        return <Badge variant="secondary" className="text-xs">Normal</Badge>;
      case "low":
        return <Badge variant="outline" className="text-xs">Baja</Badge>;
    }
  };

  const getTimeAgo = (dateString: string) => {
    const now = new Date();
    const date = new Date(dateString);
    const diffInHours = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60));
    
    if (diffInHours < 1) return "Hace menos de 1 hora";
    if (diffInHours < 24) return `Hace ${diffInHours} horas`;
    const diffInDays = Math.floor(diffInHours / 24);
    return `Hace ${diffInDays} d√≠as`;
  };

  const unreadCount = notifications.filter(n => !n.read_status).length;

  if (loading) {
    return (
      <div className="p-6">
        <div className="animate-pulse space-y-6">
          <div className="h-8 bg-muted rounded w-64" />
          <div className="space-y-4">
            {[...Array(5)].map((_, i) => (
              <div key={i} className="h-20 bg-muted rounded-lg" />
            ))}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold bg-gradient-primary bg-clip-text text-transparent">
            Centro de Notificaciones
          </h1>
          <p className="text-muted-foreground">
            Gestiona todas tus alertas y notificaciones
            {unreadCount > 0 && (
              <Badge variant="destructive" className="ml-2">
                {unreadCount} sin leer
              </Badge>
            )}
          </p>
        </div>
        <div className="flex items-center space-x-3">
          <Button variant="outline" size="sm" onClick={markAllAsRead}>
            <CheckCircle className="w-4 h-4 mr-2" />
            Marcar todas como le√≠das
          </Button>
        </div>
      </div>

      {/* Filters */}
      <div className="flex items-center justify-between gap-4">
        <div className="flex items-center space-x-3 flex-1">
          <div className="relative flex-1 max-w-sm">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4" />
            <Input
              placeholder="Buscar notificaciones..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10"
            />
          </div>
          
          <Select value={priorityFilter} onValueChange={setPriorityFilter}>
            <SelectTrigger className="w-36">
              <Filter className="w-4 h-4 mr-2" />
              <SelectValue placeholder="Prioridad" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">Todas</SelectItem>
              <SelectItem value="high">Alta</SelectItem>
              <SelectItem value="normal">Normal</SelectItem>
              <SelectItem value="low">Baja</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Notifications */}
      <Tabs value={selectedTab} onValueChange={setSelectedTab} className="space-y-6">
        <TabsList className="grid w-full grid-cols-6">
          <TabsTrigger value="all">Todas</TabsTrigger>
          <TabsTrigger value="unread">Sin Leer</TabsTrigger>
          <TabsTrigger value="token_expiring">Tokens</TabsTrigger>
          <TabsTrigger value="story_deleted">Historias</TabsTrigger>
          <TabsTrigger value="ambassador_pending">Embajadores</TabsTrigger>
          <TabsTrigger value="task_expired">Tareas</TabsTrigger>
        </TabsList>

        <div className="space-y-4">
          {filteredNotifications.length === 0 ? (
            <Card className="shadow-card">
              <CardContent className="p-8 text-center">
                <Bell className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
                <h3 className="text-lg font-medium mb-2">No hay notificaciones</h3>
                <p className="text-muted-foreground">
                  {searchQuery ? "No se encontraron notificaciones que coincidan con tu b√∫squeda" : 
                   selectedTab === "unread" ? "¬°Genial! No tienes notificaciones sin leer" :
                   "No hay notificaciones disponibles en esta categor√≠a"}
                </p>
              </CardContent>
            </Card>
          ) : (
            filteredNotifications.map((notification) => (
              <Card 
                key={notification.id} 
                className={`shadow-card transition-all hover:shadow-elegant ${
                  !notification.read_status ? 'border-primary/50 bg-gradient-card' : ''
                }`}
              >
                <CardContent className="p-4">
                  <div className="flex items-start justify-between">
                    <div className="flex items-start space-x-3 flex-1">
                      <div className="flex-shrink-0 mt-1">
                        {getNotificationIcon(notification.type, notification.priority)}
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center space-x-2 mb-1">
                          {getPriorityBadge(notification.priority)}
                          {!notification.read_status && (
                            <Badge variant="default" className="text-xs">
                              Nuevo
                            </Badge>
                          )}
                        </div>
                        <p className="text-sm font-medium text-foreground mb-1">
                          {notification.message}
                        </p>
                        <div className="flex items-center space-x-4 text-xs text-muted-foreground">
                          <span>{getTimeAgo(notification.created_at)}</span>
                          {notification.metadata?.event_name && (
                            <span>Evento: {notification.metadata.event_name}</span>
                          )}
                        </div>
                      </div>
                    </div>
                    
                    <div className="flex items-center space-x-2 ml-4">
                      {notification.target_id && (
                        <Button variant="ghost" size="sm">
                          <ExternalLink className="w-4 h-4" />
                        </Button>
                      )}
                      {!notification.read_status && (
                        <Button 
                          variant="ghost" 
                          size="sm"
                          onClick={() => markAsRead(notification.id)}
                        >
                          <CheckCircle className="w-4 h-4" />
                        </Button>
                      )}
                      <Button 
                        variant="ghost" 
                        size="sm"
                        onClick={() => deleteNotification(notification.id)}
                      >
                        <Trash2 className="w-4 h-4" />
                      </Button>
                    </div>
                  </div>
                </CardContent>
              </Card>
            ))
          )}
        </div>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/components/Onboarding/OnboardingWizard.tsx">
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { CheckCircle, Circle, Building2, Instagram, Calendar, Users, ArrowRight, Home } from "lucide-react";
import { useNavigate } from "react-router-dom";
import { useOnboardingStatus } from "@/hooks/useOnboardingStatus";
import EditOrganizationModal from "@/components/Organizations/EditOrganizationModal";
import { CreateFiestaModal } from "@/components/Fiestas/CreateFiestaModal";
import AddAmbassadorModal from "@/components/Ambassadors/AddAmbassadorModal";
import { MetaAppCredentialsForm } from "@/components/Settings/MetaAppCredentialsForm";
import { InstagramConfigGuide } from "@/components/Settings/InstagramConfigGuide";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";

const stepIcons = {
  organization: Building2,
  instagram: Instagram,
  fiesta: Calendar,
  ambassadors: Users,
};

export function OnboardingWizard() {
  const navigate = useNavigate();
  const { steps, overallProgress, canAccessDashboard, refreshOnboardingStatus } = useOnboardingStatus();
  const { organization, refreshOrganization } = useCurrentOrganization();
  
  const [showEditOrganization, setShowEditOrganization] = useState(false);
  const [showCreateFiesta, setShowCreateFiesta] = useState(false);
  const [showAddAmbassador, setShowAddAmbassador] = useState(false);
  const [showInstagramConfig, setShowInstagramConfig] = useState(false);
  const [showInstagramGuide, setShowInstagramGuide] = useState(false);

  const handleStepAction = (stepId: string) => {
    switch (stepId) {
      case "organization":
        setShowEditOrganization(true);
        break;
      case "instagram":
        setShowInstagramConfig(true);
        break;
      case "fiesta":
        setShowCreateFiesta(true);
        break;
      case "ambassadors":
        setShowAddAmbassador(true);
        break;
    }
  };

  const handleGoToDashboard = () => {
    navigate('/');
  };

  const handleModalClose = () => {
    setShowEditOrganization(false);
    setShowCreateFiesta(false);
    setShowAddAmbassador(false);
    setShowInstagramConfig(false);
    setShowInstagramGuide(false);
    refreshOnboardingStatus();
    refreshOrganization();
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-50 via-pink-50 to-orange-50 dark:from-gray-900 dark:via-purple-900/20 dark:to-pink-900/20">
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-4xl mx-auto">
          {/* Header */}
          <div className="text-center mb-8">
            <h1 className="text-4xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent mb-4">
              ¬°Bienvenido a EVA System! üéâ
            </h1>
            <p className="text-lg text-muted-foreground mb-6">
              Configura tu sistema de gesti√≥n de embajadores en pocos pasos
            </p>
            
            {/* Progress Bar */}
            <div className="mb-6">
              <div className="flex justify-between items-center mb-2">
                <span className="text-sm font-medium">Progreso General</span>
                <span className="text-sm text-muted-foreground">{Math.round(overallProgress)}%</span>
              </div>
              <Progress value={overallProgress} className="h-2" />
            </div>

            {/* Dashboard Access Button - Show when can access */}
            {canAccessDashboard && (
              <div className="mb-6">
                <Card className="border-green-200 bg-green-50 dark:bg-green-900/20">
                  <CardContent className="p-4">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        <CheckCircle className="h-5 w-5 text-green-600" />
                        <div className="text-left">
                          <p className="font-medium text-green-800 dark:text-green-400">
                            ¬°Tu organizaci√≥n est√° lista!
                          </p>
                          <p className="text-sm text-green-600 dark:text-green-500">
                            Ya puedes acceder al dashboard y explorar todas las funcionalidades
                          </p>
                        </div>
                      </div>
                      <Button onClick={handleGoToDashboard} className="gap-2">
                        <Home className="h-4 w-4" />
                        Ir al Dashboard
                      </Button>
                    </div>
                  </CardContent>
                </Card>
              </div>
            )}
          </div>

          {/* Steps */}
          <div className="space-y-4">
            {steps.map((step, index) => {
              const Icon = stepIcons[step.id as keyof typeof stepIcons];
              const isCompleted = step.completed;
              const isRequired = step.required;

              return (
                <Card key={step.id} className={`transition-all ${
                  isCompleted ? 'border-green-200 bg-green-50/50 dark:bg-green-900/10' : 
                  isRequired ? 'border-orange-200 bg-orange-50/50 dark:bg-orange-900/10' :
                  'border-blue-200 bg-blue-50/50 dark:bg-blue-900/10'
                }`}>
                  <CardHeader className="pb-3">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        <div className={`p-2 rounded-lg ${
                          isCompleted ? 'bg-green-100 text-green-600 dark:bg-green-900 dark:text-green-400' :
                          isRequired ? 'bg-orange-100 text-orange-600 dark:bg-orange-900 dark:text-orange-400' :
                          'bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-400'
                        }`}>
                          <Icon className="h-5 w-5" />
                        </div>
                        <div>
                          <div className="flex items-center gap-2">
                            <CardTitle className="text-lg">{step.title}</CardTitle>
                            {!isRequired && (
                              <Badge variant="secondary" className="text-xs">
                                Opcional
                              </Badge>
                            )}
                            {isCompleted && (
                              <CheckCircle className="h-4 w-4 text-green-600" />
                            )}
                          </div>
                          <CardDescription>{step.description}</CardDescription>
                        </div>
                      </div>
                      
                      <div className="flex items-center gap-2">
                        {step.id === "instagram" && !isCompleted && (
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => setShowInstagramGuide(true)}
                          >
                            Ver Gu√≠a
                          </Button>
                        )}
                        <Button
                          onClick={() => handleStepAction(step.id)}
                          variant={isCompleted ? "outline" : "default"}
                          size="sm"
                          className="gap-2"
                        >
                          {isCompleted ? "Modificar" : "Configurar"}
                          <ArrowRight className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>
                  </CardHeader>
                </Card>
              );
            })}
          </div>

          {/* Footer */}
          <div className="text-center mt-8">
            <p className="text-sm text-muted-foreground">
              Los pasos marcados como "Opcional" pueden completarse m√°s tarde desde el dashboard
            </p>
          </div>
        </div>
      </div>

      {/* Modals */}
      <EditOrganizationModal
        isOpen={showEditOrganization}
        onClose={handleModalClose}
        onOrganizationUpdated={handleModalClose}
        organization={organization ? {
          ...organization,
          description: organization.description || ''
        } : undefined}
      />

      <CreateFiestaModal
        isOpen={showCreateFiesta}
        onClose={handleModalClose}
        onFiestaCreated={handleModalClose}
      />

      <AddAmbassadorModal
        isOpen={showAddAmbassador}
        onClose={handleModalClose}
        onAmbassadorAdded={handleModalClose}
      />

      <MetaAppCredentialsForm
        isOpen={showInstagramConfig}
        onClose={handleModalClose}
        onCredentialsSaved={handleModalClose}
      />

      <InstagramConfigGuide
        isOpen={showInstagramGuide}
        onClose={() => setShowInstagramGuide(false)}
      />
    </div>
  );
}
</file>

<file path="src/components/Organizations/DeleteOrganizationModal.tsx">
import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertTriangle, Loader2 } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

interface DeleteOrganizationModalProps {
  isOpen: boolean;
  onClose: () => void;
  onOrganizationDeleted: () => void;
  organization: {
    id: string;
    name: string;
  };
}

export function DeleteOrganizationModal({
  isOpen,
  onClose,
  onOrganizationDeleted,
  organization
}: DeleteOrganizationModalProps) {
  const [confirmationText, setConfirmationText] = useState("");
  const [isDeleting, setIsDeleting] = useState(false);

  const handleDelete = async () => {
    if (confirmationText !== organization.name) {
      toast.error("El nombre de la organizaci√≥n no coincide");
      return;
    }

    try {
      setIsDeleting(true);

      const { error } = await supabase
        .from('organizations')
        .delete()
        .eq('id', organization.id);

      if (error) {
        console.error('Error deleting organization:', error);
        toast.error('Error al eliminar organizaci√≥n: ' + error.message);
        return;
      }

      toast.success('Organizaci√≥n eliminada exitosamente');
      handleClose();
      onOrganizationDeleted();
    } catch (error) {
      console.error('Error deleting organization:', error);
      toast.error('Error inesperado al eliminar organizaci√≥n');
    } finally {
      setIsDeleting(false);
    }
  };

  const handleClose = () => {
    setConfirmationText("");
    onClose();
  };

  const isDeleteEnabled = confirmationText === organization.name && !isDeleting;

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2 text-destructive">
            <AlertTriangle className="w-5 h-5" />
            Eliminar Organizaci√≥n
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              <strong>¬°Advertencia!</strong> Esta acci√≥n no se puede deshacer. 
              Se eliminar√°n todos los datos asociados incluyendo embajadores, 
              eventos y tareas.
            </AlertDescription>
          </Alert>

          <div className="space-y-2">
            <Label htmlFor="confirmation">
              Para confirmar, escribe el nombre de la organizaci√≥n: <strong>{organization.name}</strong>
            </Label>
            <Input
              id="confirmation"
              value={confirmationText}
              onChange={(e) => setConfirmationText(e.target.value)}
              placeholder="Nombre de la organizaci√≥n"
              className="w-full"
            />
          </div>

          <div className="flex gap-2 justify-end">
            <Button
              variant="outline"
              onClick={handleClose}
              disabled={isDeleting}
            >
              Cancelar
            </Button>
            <Button
              variant="destructive"
              onClick={handleDelete}
              disabled={!isDeleteEnabled}
            >
              {isDeleting ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin mr-2" />
                  Eliminando...
                </>
              ) : (
                "Eliminar Organizaci√≥n"
              )}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Organizations/EditOrganizationModal.tsx">
import { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Building2 } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { InstagramConnect } from "@/components/Instagram/InstagramConnect";

interface EditOrganizationModalProps {
  isOpen: boolean;
  onClose: () => void;
  onOrganizationUpdated: () => void;
  organization: {
    id: string;
    name: string;
    description: string | null;
  } | null;
}

interface OrganizationFormData {
  name: string;
  description: string;
}

export default function EditOrganizationModal({
  isOpen,
  onClose,
  onOrganizationUpdated,
  organization,
}: EditOrganizationModalProps) {
  const [formData, setFormData] = useState<OrganizationFormData>({
    name: "",
    description: "",
  });
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (organization && isOpen) {
      setFormData({
        name: organization.name,
        description: organization.description || "",
      });
    }
  }, [organization, isOpen]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!organization) return;
    
    setIsLoading(true);

    try {
      // Validaci√≥n b√°sica
      if (!formData.name.trim()) {
        toast.error('El nombre de la organizaci√≥n es obligatorio');
        return;
      }

      console.log('Updating organization:', organization.id);

      // Actualizar la organizaci√≥n
      const { error: updateError } = await supabase
        .from('organizations')
        .update({
          name: formData.name.trim(),
          description: formData.description.trim() || null,
        })
        .eq('id', organization.id);

      if (updateError) {
        console.error('Error updating organization:', updateError);
        toast.error('Error al actualizar organizaci√≥n: ' + updateError.message);
        return;
      }

      console.log('Organization updated successfully');

      toast.success(`¬°Organizaci√≥n "${formData.name}" actualizada exitosamente!`);
      onOrganizationUpdated();
      onClose();
    } catch (error) {
      console.error('Error updating organization:', error);
      toast.error('Error al actualizar organizaci√≥n');
    } finally {
      setIsLoading(false);
    }
  };

  const resetForm = () => {
    setFormData({
      name: "",
      description: "",
    });
  };

  const handleClose = () => {
    resetForm();
    onClose();
  };

  if (!organization) return null;

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Building2 className="w-5 h-5" />
            Editar Organizaci√≥n
          </DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-4">
          {/* Nombre */}
          <div>
            <Label htmlFor="name">Nombre de la Organizaci√≥n/Productora *</Label>
            <Input
              id="name"
              value={formData.name}
              onChange={(e) => setFormData({ ...formData, name: e.target.value })}
              placeholder="Ej: Productora de Eventos XYZ"
              required
              maxLength={100}
            />
          </div>

          {/* Descripci√≥n */}
          <div>
            <Label htmlFor="description">Descripci√≥n</Label>
            <Textarea
              id="description"
              value={formData.description}
              onChange={(e) => setFormData({ ...formData, description: e.target.value })}
              placeholder="Describe brevemente tu productora de eventos..."
              rows={3}
              maxLength={500}
            />
          </div>

          {/* Instagram Business Connection */}
          <div>
            <Label>Conexi√≥n Instagram Business</Label>
            <p className="text-sm text-muted-foreground mb-2">
              Conecta tu cuenta business de Instagram para gestionar contenido autom√°ticamente
            </p>
            <InstagramConnect
              type="organization"
              entityId={organization.id}
              organizationId={organization.id}
              currentStatus={{ isConnected: false }} // TODO: Get actual status from organization data
              onConnectionChange={onOrganizationUpdated}
            />
          </div>

          {/* Botones */}
          <div className="flex justify-end gap-2 pt-4">
            <Button 
              type="button" 
              variant="outline" 
              onClick={handleClose} 
              disabled={isLoading}
            >
              Cancelar
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? 'Actualizando...' : 'Actualizar Organizaci√≥n'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Organizations/MembersManagement.tsx">
import { useState, useEffect } from 'react';
import { useCurrentOrganization } from '@/hooks/useCurrentOrganization';
import { supabase } from '@/integrations/supabase/client';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle, 
  DialogTrigger 
} from '@/components/ui/dialog';
import { 
  Table, 
  TableBody, 
  TableCell, 
  TableHead, 
  TableHeader, 
  TableRow 
} from '@/components/ui/table';
import { 
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { toast } from 'sonner';
import { UserPlus, MoreHorizontal, Trash2 } from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';

interface OrganizationMember {
  id: string;
  user_id: string;
  role: string;
  status: string;
  joined_at: string;
  permissions: any;
  user?: {
    email: string;
    name: string;
  };
}

export const MembersManagement = () => {
  const { currentOrganization } = useCurrentOrganization();
  const [members, setMembers] = useState<OrganizationMember[]>([]);
  const [loading, setLoading] = useState(false);
  const [inviteEmail, setInviteEmail] = useState('');
  const [inviteRole, setInviteRole] = useState('member');
  const [inviteDialogOpen, setInviteDialogOpen] = useState(false);

  const fetchMembers = async () => {
    if (!currentOrganization?.organization_id) return;

    setLoading(true);
    try {
      const { data, error } = await supabase
        .from('organization_members')
        .select('*')
        .eq('organization_id', currentOrganization.organization_id)
        .eq('status', 'active');

      if (error) throw error;

      // Get user details from auth.users for each member
      const membersWithUsers = await Promise.all(
        (data || []).map(async (member) => {
          // Use the service to get user info
          const { data: authUser } = await supabase.auth.admin.getUserById(member.user_id);
          
          return {
            ...member,
            user: {
              email: authUser?.user?.email || '',
              name: authUser?.user?.user_metadata?.name || authUser?.user?.email || 'Usuario'
            }
          };
        })
      );

      setMembers(membersWithUsers);
    } catch (error) {
      console.error('Error fetching members:', error);
      toast.error('Error al cargar miembros');
    } finally {
      setLoading(false);
    }
  };

  const handleInviteMember = async () => {
    if (!currentOrganization?.organization_id || !inviteEmail.trim()) return;

    try {
      // Check if user exists
      const { data: userQuery, error: userError } = await supabase
        .from('users')
        .select('auth_user_id')
        .eq('email', inviteEmail)
        .single();
      
      if (userError || !userQuery) {
        toast.error('Usuario no encontrado. El usuario debe registrarse primero.');
        return;
      }

      const existingUserId = userQuery.auth_user_id;

      // Check if already a member
      const { data: existingMember } = await supabase
        .from('organization_members')
        .select('id')
        .eq('organization_id', currentOrganization.organization_id)
        .eq('user_id', existingUserId)
        .single();

      if (existingMember) {
        toast.error('El usuario ya es miembro de esta organizaci√≥n');
        return;
      }

      // Add member
      const { error: memberError } = await supabase
        .from('organization_members')
        .insert({
          organization_id: currentOrganization.organization_id,
          user_id: existingUserId,
          role: inviteRole,
          status: 'active',
          permissions: {
            manage_ambassadors: true,
            manage_events: true,
            manage_instagram: inviteRole === 'owner',
            view_analytics: true,
            manage_members: inviteRole === 'owner'
          }
        });

      if (memberError) throw memberError;

      toast.success('Miembro invitado exitosamente');
      setInviteEmail('');
      setInviteRole('member');
      setInviteDialogOpen(false);
      fetchMembers();
    } catch (error) {
      console.error('Error inviting member:', error);
      toast.error('Error al invitar miembro');
    }
  };

  const handleRemoveMember = async (memberId: string) => {
    try {
      const { error } = await supabase
        .from('organization_members')
        .delete()
        .eq('id', memberId);

      if (error) throw error;

      toast.success('Miembro removido exitosamente');
      fetchMembers();
    } catch (error) {
      console.error('Error removing member:', error);
      toast.error('Error al remover miembro');
    }
  };

  useEffect(() => {
    fetchMembers();
  }, [currentOrganization?.organization_id]);

  if (!currentOrganization?.is_owner) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Gesti√≥n de Miembros</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-muted-foreground">
            Solo los propietarios pueden gestionar miembros de la organizaci√≥n.
          </p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-4">
        <CardTitle>Miembros de la Organizaci√≥n</CardTitle>
        
        <Dialog open={inviteDialogOpen} onOpenChange={setInviteDialogOpen}>
          <DialogTrigger asChild>
            <Button>
              <UserPlus className="w-4 h-4 mr-2" />
              Invitar Miembro
            </Button>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Invitar Nuevo Miembro</DialogTitle>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <Label htmlFor="invite-email">Email del Usuario</Label>
                <Input
                  id="invite-email"
                  type="email"
                  value={inviteEmail}
                  onChange={(e) => setInviteEmail(e.target.value)}
                  placeholder="usuario@ejemplo.com"
                />
              </div>
              <div>
                <Label htmlFor="invite-role">Rol</Label>
                <Select value={inviteRole} onValueChange={setInviteRole}>
                  <SelectTrigger>
                    <SelectValue placeholder="Seleccionar rol" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="member">Miembro</SelectItem>
                    <SelectItem value="admin">Administrador</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <Button onClick={handleInviteMember} className="w-full">
                Enviar Invitaci√≥n
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      </CardHeader>
      
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Usuario</TableHead>
              <TableHead>Rol</TableHead>
              <TableHead>Fecha de Ingreso</TableHead>
              <TableHead>Estado</TableHead>
              <TableHead className="w-[50px]"></TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {members.map((member) => (
              <TableRow key={member.id}>
                <TableCell>
                  <div>
                    <div className="font-medium">{member.user?.name}</div>
                    <div className="text-sm text-muted-foreground">
                      {member.user?.email}
                    </div>
                  </div>
                </TableCell>
                <TableCell>
                  <Badge variant={member.role === 'owner' ? 'default' : 'secondary'}>
                    {member.role === 'owner' ? 'Propietario' : 
                     member.role === 'admin' ? 'Administrador' : 'Miembro'}
                  </Badge>
                </TableCell>
                <TableCell>
                  {new Date(member.joined_at).toLocaleDateString()}
                </TableCell>
                <TableCell>
                  <Badge variant="outline">
                    {member.status === 'active' ? 'Activo' : member.status}
                  </Badge>
                </TableCell>
                <TableCell>
                  {member.role !== 'owner' && (
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="sm">
                          <MoreHorizontal className="w-4 h-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem
                          onClick={() => handleRemoveMember(member.id)}
                          className="text-destructive"
                        >
                          <Trash2 className="w-4 h-4 mr-2" />
                          Remover Miembro
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  )}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
        
        {members.length === 0 && !loading && (
          <div className="text-center py-8 text-muted-foreground">
            No hay miembros en esta organizaci√≥n
          </div>
        )}
      </CardContent>
    </Card>
  );
};
</file>

<file path="src/components/Organizations/OrganizationAmbassadorsList.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Users, Award, Target } from "lucide-react";

interface TopAmbassador {
  id: string;
  name: string;
  instagram_user: string;
  points: number;
  tasks_completed: number;
  performance_status: string;
}

interface OrganizationAmbassadorsListProps {
  ambassadors: TopAmbassador[];
}

export function OrganizationAmbassadorsList({ ambassadors }: OrganizationAmbassadorsListProps) {
  const getPerformanceBadge = (status: string) => {
    const styles = {
      'cumple': { variant: "default" as const, label: 'Cumple' },
      'advertencia': { variant: "secondary" as const, label: 'Advertencia' },
      'no_cumple': { variant: "destructive" as const, label: 'No Cumple' },
      'exclusivo': { variant: "outline" as const, label: 'Exclusivo' }
    };
    return styles[status as keyof typeof styles] || styles.cumple;
  };

  const getRankIcon = (index: number) => {
    const icons = ['ü•á', 'ü•à', 'ü•â'];
    return icons[index] || 'üèÖ';
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Users className="w-5 h-5" />
          Top Embajadores
        </CardTitle>
      </CardHeader>
      <CardContent>
        {ambassadors.length === 0 ? (
          <div className="text-center py-6 text-muted-foreground">
            <Users className="w-12 h-12 mx-auto mb-3 opacity-50" />
            <p>No hay embajadores registrados</p>
          </div>
        ) : (
          <div className="space-y-4">
            {ambassadors.map((ambassador, index) => {
              const performanceBadge = getPerformanceBadge(ambassador.performance_status);
              
              return (
                <div key={ambassador.id} className="flex items-center justify-between p-4 border rounded-lg">
                  <div className="flex items-center gap-3">
                    {/* Ranking Badge */}
                    <div className="flex items-center justify-center w-8 h-8 text-lg">
                      {getRankIcon(index)}
                    </div>

                    {/* Avatar and Info */}
                    <div className="flex items-center gap-3">
                      <Avatar>
                        <AvatarFallback>
                          {ambassador.name.split(' ').map(n => n[0]).join('')}
                        </AvatarFallback>
                      </Avatar>
                      <div>
                        <h3 className="font-medium">{ambassador.name}</h3>
                        <p className="text-sm text-muted-foreground">@{ambassador.instagram_user}</p>
                      </div>
                    </div>
                  </div>

                  <div className="flex items-center gap-4">
                    {/* Points */}
                    <div className="text-right">
                      <div className="flex items-center gap-1 text-sm">
                        <Award className="w-3 h-3" />
                        <span className="font-bold">{ambassador.points}</span>
                      </div>
                      <p className="text-xs text-muted-foreground">puntos</p>
                    </div>

                    {/* Tasks Completed */}
                    <div className="text-right">
                      <div className="flex items-center gap-1 text-sm">
                        <Target className="w-3 h-3" />
                        <span className="font-medium">{ambassador.tasks_completed}</span>
                      </div>
                      <p className="text-xs text-muted-foreground">tareas</p>
                    </div>

                    {/* Performance Status */}
                    <Badge variant={performanceBadge.variant} className="text-xs">
                      {performanceBadge.label}
                    </Badge>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Organizations/OrganizationDashboard.tsx">
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { ArrowLeft, Edit, Building2 } from "lucide-react";
import { useOrganizationMetrics } from "@/hooks/useOrganizationMetrics";
import { OrganizationMetricsCards } from "./OrganizationMetricsCards";
import { OrganizationPerformanceChart } from "./OrganizationPerformanceChart";
import { OrganizationEventsList } from "./OrganizationEventsList";
import { OrganizationAmbassadorsList } from "./OrganizationAmbassadorsList";
import EditOrganizationModal from "./EditOrganizationModal";
import { InstagramConnect } from "@/components/Instagram/InstagramConnect";

interface OrganizationDashboardProps {
  organizationId: string;
  onBack: () => void;
}

export function OrganizationDashboard({ organizationId, onBack }: OrganizationDashboardProps) {
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const { metrics, loading, error, refreshMetrics } = useOrganizationMetrics(organizationId);

  const handleOrganizationUpdated = () => {
    refreshMetrics();
    setIsEditModalOpen(false);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2 text-sm text-muted-foreground">Cargando m√©tricas de la organizaci√≥n...</p>
        </div>
      </div>
    );
  }

  if (error || !metrics) {
    return (
      <div className="text-center py-8">
        <Building2 className="w-16 h-16 mx-auto mb-4 text-muted-foreground" />
        <h3 className="text-lg font-semibold mb-2">Error al cargar datos</h3>
        <p className="text-muted-foreground mb-4">
          {error || 'No se pudieron cargar las m√©tricas de la organizaci√≥n'}
        </p>
        <Button onClick={refreshMetrics}>Intentar de nuevo</Button>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <Button variant="ghost" onClick={onBack}>
            <ArrowLeft className="w-4 h-4 mr-2" />
            Volver
          </Button>
          <div>
            <h1 className="text-2xl font-bold tracking-tight">{metrics.name}</h1>
            {metrics.description && (
              <p className="text-muted-foreground">{metrics.description}</p>
            )}
          </div>
        </div>
        <Button onClick={() => setIsEditModalOpen(true)}>
          <Edit className="w-4 h-4 mr-2" />
          Editar Organizaci√≥n
        </Button>
      </div>

      {/* Instagram Connection */}
      <div className="bg-card rounded-lg p-6 border">
        <h3 className="text-lg font-semibold mb-4">Conexi√≥n Instagram Business</h3>
        <InstagramConnect 
          type="organization"
          entityId={metrics.id}
          organizationId={metrics.id}
          currentStatus={{
            isConnected: !!metrics.instagram_username,
            lastSync: metrics.last_instagram_sync
          }}
        />
      </div>

      {/* Metrics Cards */}
      <OrganizationMetricsCards metrics={metrics} />

      {/* Performance Charts */}
      <OrganizationPerformanceChart monthlyData={metrics.monthly_performance} />

      {/* Events and Ambassadors Lists */}
      <div className="grid gap-6 md:grid-cols-2">
        <OrganizationEventsList events={metrics.recent_events} />
        <OrganizationAmbassadorsList ambassadors={metrics.top_ambassadors} />
      </div>

      {/* Edit Organization Modal */}
      <EditOrganizationModal
        isOpen={isEditModalOpen}
        onClose={() => setIsEditModalOpen(false)}
        onOrganizationUpdated={handleOrganizationUpdated}
        organization={metrics ? {
          id: metrics.id,
          name: metrics.name,
          description: metrics.description
        } : null}
      />
    </div>
  );
}
</file>

<file path="src/components/Organizations/OrganizationEventsList.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Calendar, Target, TrendingUp } from "lucide-react";

interface Event {
  id: string;
  name: string;
  event_date: string;
  total_tasks: number;
  completed_tasks: number;
  total_reach: number;
}

interface OrganizationEventsListProps {
  events: Event[];
}

export function OrganizationEventsList({ events }: OrganizationEventsListProps) {
  const formatNumber = (num: number) => {
    if (num >= 1000000) {
      return (num / 1000000).toFixed(1) + 'M';
    }
    if (num >= 1000) {
      return (num / 1000).toFixed(1) + 'K';
    }
    return num.toString();
  };

  const getCompletionBadgeVariant = (completed: number, total: number) => {
    if (total === 0) return "secondary";
    const rate = (completed / total) * 100;
    if (rate >= 80) return "default";
    if (rate >= 60) return "secondary";
    return "destructive";
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Calendar className="w-5 h-5" />
          Eventos Recientes
        </CardTitle>
      </CardHeader>
      <CardContent>
        {events.length === 0 ? (
          <div className="text-center py-6 text-muted-foreground">
            <Calendar className="w-12 h-12 mx-auto mb-3 opacity-50" />
            <p>No hay eventos registrados</p>
          </div>
        ) : (
          <div className="space-y-4">
            {events.map((event) => {
              const completionRate = event.total_tasks > 0 
                ? Math.round((event.completed_tasks / event.total_tasks) * 100)
                : 0;

              return (
                <div key={event.id} className="flex items-center justify-between p-4 border rounded-lg">
                  <div className="flex-1">
                    <h3 className="font-medium">{event.name}</h3>
                    <p className="text-sm text-muted-foreground">
                      {new Date(event.event_date).toLocaleDateString('es-ES', {
                        day: 'numeric',
                        month: 'short',
                        year: 'numeric'
                      })}
                    </p>
                  </div>
                  
                  <div className="flex items-center gap-4">
                    {/* Tareas */}
                    <div className="text-right">
                      <div className="flex items-center gap-1 text-sm">
                        <Target className="w-3 h-3" />
                        <span className="font-medium">{event.completed_tasks}/{event.total_tasks}</span>
                      </div>
                      <Badge 
                        variant={getCompletionBadgeVariant(event.completed_tasks, event.total_tasks)}
                        className="text-xs mt-1"
                      >
                        {completionRate}% completado
                      </Badge>
                    </div>

                    {/* Alcance */}
                    <div className="text-right">
                      <div className="flex items-center gap-1 text-sm">
                        <TrendingUp className="w-3 h-3" />
                        <span className="font-medium">{formatNumber(event.total_reach)}</span>
                      </div>
                      <p className="text-xs text-muted-foreground">alcance</p>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Organizations/OrganizationMetricsCards.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Building2, Calendar, Users, Target, TrendingUp, Award } from "lucide-react";

interface OrganizationMetrics {
  id: string;
  name: string;
  description: string | null;
  created_at: string;
  total_events: number;
  active_events: number;
  total_ambassadors: number;
  active_ambassadors: number;
  total_tasks: number;
  completed_tasks: number;
  total_reach: number;
  avg_engagement: number;
  completion_rate: number;
}

interface OrganizationMetricsCardsProps {
  metrics: OrganizationMetrics;
}

export function OrganizationMetricsCards({ metrics }: OrganizationMetricsCardsProps) {
  const formatNumber = (num: number) => {
    if (num >= 1000000) {
      return (num / 1000000).toFixed(1) + 'M';
    }
    if (num >= 1000) {
      return (num / 1000).toFixed(1) + 'K';
    }
    return num.toString();
  };

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {/* Eventos */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Eventos</CardTitle>
          <Calendar className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{metrics.total_events}</div>
          <div className="flex items-center gap-2 mt-1">
            <Badge variant="secondary" className="text-xs">
              {metrics.active_events} activos
            </Badge>
          </div>
          <p className="text-xs text-muted-foreground mt-2">
            Total de eventos creados
          </p>
        </CardContent>
      </Card>

      {/* Embajadores */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Embajadores</CardTitle>
          <Users className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{metrics.total_ambassadors}</div>
          <div className="flex items-center gap-2 mt-1">
            <Badge variant="secondary" className="text-xs">
              {metrics.active_ambassadors} activos
            </Badge>
          </div>
          <p className="text-xs text-muted-foreground mt-2">
            Embajadores registrados
          </p>
        </CardContent>
      </Card>

      {/* Tareas */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Tareas</CardTitle>
          <Target className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{metrics.total_tasks}</div>
          <div className="flex items-center gap-2 mt-1">
            <Badge 
              variant={metrics.completion_rate >= 80 ? "default" : metrics.completion_rate >= 60 ? "secondary" : "destructive"}
              className="text-xs"
            >
              {metrics.completion_rate.toFixed(0)}% completadas
            </Badge>
          </div>
          <p className="text-xs text-muted-foreground mt-2">
            {metrics.completed_tasks} de {metrics.total_tasks} completadas
          </p>
        </CardContent>
      </Card>

      {/* Alcance Total */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Alcance Total</CardTitle>
          <TrendingUp className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{formatNumber(metrics.total_reach)}</div>
          <p className="text-xs text-muted-foreground mt-2">
            Impresiones totales generadas
          </p>
        </CardContent>
      </Card>

      {/* Engagement Promedio */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Engagement Promedio</CardTitle>
          <Award className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{metrics.avg_engagement.toFixed(1)}%</div>
          <p className="text-xs text-muted-foreground mt-2">
            Engagement promedio de contenido
          </p>
        </CardContent>
      </Card>

      {/* Informaci√≥n General */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Organizaci√≥n</CardTitle>
          <Building2 className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-lg font-semibold truncate">{metrics.name}</div>
          <p className="text-xs text-muted-foreground mt-2">
            Creado: {new Date(metrics.created_at).toLocaleDateString()}
          </p>
          {metrics.description && (
            <p className="text-xs text-muted-foreground mt-1 line-clamp-2">
              {metrics.description}
            </p>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/Organizations/OrganizationPerformanceChart.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ChartContainer, ChartTooltip, ChartTooltipContent } from "@/components/ui/chart";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, ResponsiveContainer, BarChart, Bar } from "recharts";

interface MonthlyData {
  month: string;
  events: number;
  tasks: number;
  reach: number;
  ambassadors: number;
}

interface OrganizationPerformanceChartProps {
  monthlyData: MonthlyData[];
}

export function OrganizationPerformanceChart({ monthlyData }: OrganizationPerformanceChartProps) {
  const chartConfig = {
    events: {
      label: "Eventos",
      color: "hsl(var(--primary))",
    },
    tasks: {
      label: "Tareas",
      color: "hsl(var(--secondary))",
    },
    reach: {
      label: "Alcance",
      color: "hsl(var(--accent))",
    },
    ambassadors: {
      label: "Embajadores",
      color: "hsl(var(--muted-foreground))",
    },
  };

  const formatReachData = monthlyData.map(item => ({
    ...item,
    reachFormatted: item.reach > 1000 ? `${(item.reach / 1000).toFixed(1)}K` : item.reach.toString()
  }));

  return (
    <div className="grid gap-6 md:grid-cols-2">
      {/* Eventos y Tareas por Mes */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Actividad Mensual</CardTitle>
        </CardHeader>
        <CardContent>
          <ChartContainer config={chartConfig}>
            <ResponsiveContainer width="100%" height={300}>
              <BarChart data={monthlyData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <ChartTooltip content={<ChartTooltipContent />} />
                <Bar dataKey="events" fill="var(--color-events)" name="Eventos" />
                <Bar dataKey="tasks" fill="var(--color-tasks)" name="Tareas" />
              </BarChart>
            </ResponsiveContainer>
          </ChartContainer>
        </CardContent>
      </Card>

      {/* Alcance y Embajadores Activos */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Crecimiento y Alcance</CardTitle>
        </CardHeader>
        <CardContent>
          <ChartContainer config={chartConfig}>
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={monthlyData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis yAxisId="left" />
                <YAxis yAxisId="right" orientation="right" />
                <ChartTooltip 
                  content={<ChartTooltipContent />}
                  formatter={(value, name) => {
                    if (name === 'Alcance') {
                      const numValue = Number(value);
                      return numValue > 1000 ? `${(numValue / 1000).toFixed(1)}K` : value;
                    }
                    return value;
                  }}
                />
                <Line 
                  yAxisId="left"
                  type="monotone" 
                  dataKey="reach" 
                  stroke="var(--color-reach)" 
                  name="Alcance"
                  strokeWidth={2}
                />
                <Line 
                  yAxisId="right"
                  type="monotone" 
                  dataKey="ambassadors" 
                  stroke="var(--color-ambassadors)" 
                  name="Embajadores Activos"
                  strokeWidth={2}
                />
              </LineChart>
            </ResponsiveContainer>
          </ChartContainer>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/Organizations/OrganizationSwitcher.tsx">
import { useState } from 'react';
import { Check, ChevronDown, Building2, Plus } from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { useCurrentOrganization } from '@/hooks/useCurrentOrganization';
import { toast } from 'sonner';

export const OrganizationSwitcher = () => {
  const { 
    currentOrganization, 
    userOrganizations, 
    switchOrganization 
  } = useCurrentOrganization();
  const [switching, setSwitching] = useState(false);

  const handleSwitchOrganization = async (organizationId: string) => {
    if (switching || currentOrganization?.organization_id === organizationId) return;
    
    setSwitching(true);
    try {
      await switchOrganization(organizationId);
      toast.success('Organizaci√≥n cambiada exitosamente');
      // Force page reload to refresh all data
      window.location.reload();
    } catch (error) {
      console.error('Error switching organization:', error);
      toast.error('Error al cambiar de organizaci√≥n');
    } finally {
      setSwitching(false);
    }
  };

  if (!currentOrganization) {
    return null;
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="outline" 
          className="w-full justify-between gap-2 h-10"
          disabled={switching}
        >
          <div className="flex items-center gap-2 truncate">
            <Building2 className="w-4 h-4 shrink-0" />
            <span className="truncate">{currentOrganization.organization.name}</span>
            {currentOrganization.is_owner && (
              <Badge variant="secondary" className="text-xs">Owner</Badge>
            )}
          </div>
          <ChevronDown className="w-4 h-4 shrink-0" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-80">
        <DropdownMenuLabel>Cambiar Organizaci√≥n</DropdownMenuLabel>
        <DropdownMenuSeparator />
        
        {userOrganizations.map((org) => (
          <DropdownMenuItem
            key={org.organization_id}
            onClick={() => handleSwitchOrganization(org.organization_id)}
            className="flex items-center gap-2 cursor-pointer"
          >
            <div className="flex items-center gap-2 flex-1">
              <Building2 className="w-4 h-4" />
              <div className="flex-1">
                <div className="font-medium">{org.organization.name}</div>
                <div className="text-sm text-muted-foreground">
                  {org.is_owner ? 'Propietario' : `Rol: ${org.role}`}
                </div>
              </div>
            </div>
            {currentOrganization.organization_id === org.organization_id && (
              <Check className="w-4 h-4" />
            )}
          </DropdownMenuItem>
        ))}
        
        <DropdownMenuSeparator />
        
        <DropdownMenuItem
          onClick={() => {
            // Navigate to create organization or settings
            window.location.href = '/profile';
          }}
          className="flex items-center gap-2 cursor-pointer"
        >
          <Plus className="w-4 h-4" />
          <span>Crear Nueva Organizaci√≥n</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};
</file>

<file path="src/components/Profile/UserProfile.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { User, Mail, Building2, Calendar, Save, Edit } from "lucide-react";
import { useAuth } from "@/hooks/useAuth";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { formatDistanceToNow } from "date-fns";
import { es } from "date-fns/locale";

interface UserData {
  id: string;
  name: string;
  email: string;
  organization_id: string;
  created_at: string;
  organization?: {
    name: string;
  };
}

export default function UserProfile() {
  const { user } = useAuth();
  const [userData, setUserData] = useState<UserData | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [formData, setFormData] = useState({
    name: "",
    email: "",
  });

  useEffect(() => {
    if (user) {
      fetchUserData();
    }
  }, [user]);

  const fetchUserData = async () => {
    try {
      if (!user) return;

      // First, get user data without nested organization query
      const { data: userRecord, error } = await supabase
        .from('users')
        .select(`
          id,
          name,
          email,
          organization_id,
          created_at
        `)
        .eq('auth_user_id', user.id)
        .maybeSingle();

      if (error) throw error;
      
      if (userRecord) {
        // Fetch organization info separately if user has organization_id
        let organizationData = null;
        if (userRecord.organization_id) {
          const { data: orgInfo } = await supabase
            .rpc('get_organization_safe_info', { org_id: userRecord.organization_id });
          organizationData = orgInfo?.[0] || null;
        }

        const userData = {
          ...userRecord,
          organization: organizationData ? { name: organizationData.name } : null
        };

        setUserData(userData);
        setFormData({
          name: userRecord.name,
          email: userRecord.email,
        });
      }
    } catch (error) {
      console.error('Error fetching user data:', error);
      toast.error('Error al cargar datos del usuario');
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    if (!userData) return;

    try {
      setSaving(true);

      const { error } = await supabase
        .from('users')
        .update({
          name: formData.name,
          email: formData.email,
        })
        .eq('id', userData.id);

      if (error) throw error;

      setUserData(prev => prev ? { ...prev, ...formData } : null);
      setIsEditing(false);
      toast.success('Perfil actualizado correctamente');
    } catch (error) {
      console.error('Error updating profile:', error);
      toast.error('Error al actualizar perfil');
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <div className="max-w-4xl mx-auto space-y-6">
        <div className="flex items-center justify-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
        </div>
      </div>
    );
  }

  if (!userData) {
    return (
      <div className="max-w-4xl mx-auto space-y-6">
        <Card>
          <CardContent className="p-6">
            <div className="text-center text-muted-foreground">
              <User className="h-8 w-8 mx-auto mb-2 opacity-50" />
              <p>No se pudo cargar la informaci√≥n del usuario</p>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold text-gradient">Mi Perfil</h1>
        {!isEditing ? (
          <Button onClick={() => setIsEditing(true)}>
            <Edit className="w-4 h-4 mr-2" />
            Editar Perfil
          </Button>
        ) : (
          <div className="flex gap-2">
            <Button variant="outline" onClick={() => setIsEditing(false)}>
              Cancelar
            </Button>
            <Button onClick={handleSave} disabled={saving}>
              <Save className="w-4 h-4 mr-2" />
              {saving ? "Guardando..." : "Guardar"}
            </Button>
          </div>
        )}
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <User className="h-5 w-5" />
              Informaci√≥n Personal
            </CardTitle>
            <CardDescription>
              Gestiona tu informaci√≥n personal y de contacto
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center space-x-4">
              <Avatar className="w-16 h-16">
                <AvatarImage src="" />
                <AvatarFallback className="text-lg">
                  {userData.name.split(' ').map(n => n[0]).join('').toUpperCase()}
                </AvatarFallback>
              </Avatar>
              <div>
                <h3 className="text-lg font-medium">{userData.name}</h3>
                <p className="text-muted-foreground">{userData.email}</p>
              </div>
            </div>

            <Separator />

            <div className="space-y-4">
              <div>
                <Label htmlFor="name">Nombre Completo</Label>
                {isEditing ? (
                  <Input
                    id="name"
                    value={formData.name}
                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  />
                ) : (
                  <p className="mt-1 text-sm">{userData.name}</p>
                )}
              </div>

              <div>
                <Label htmlFor="email">Email</Label>
                {isEditing ? (
                  <Input
                    id="email"
                    type="email"
                    value={formData.email}
                    onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                  />
                ) : (
                  <p className="mt-1 text-sm flex items-center gap-2">
                    <Mail className="h-4 w-4" />
                    {userData.email}
                  </p>
                )}
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Building2 className="h-5 w-5" />
              Informaci√≥n de Organizaci√≥n
            </CardTitle>
            <CardDescription>
              Detalles de tu organizaci√≥n y cuenta
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <Label>Organizaci√≥n</Label>
              <p className="mt-1 text-sm flex items-center gap-2">
                <Building2 className="h-4 w-4" />
                {userData.organization?.name || "Sin organizaci√≥n"}
              </p>
            </div>

            <div>
              <Label>Estado de la Cuenta</Label>
              <div className="mt-1">
                <Badge variant="default">Activa</Badge>
              </div>
            </div>

            <div>
              <Label>Miembro desde</Label>
              <p className="mt-1 text-sm flex items-center gap-2">
                <Calendar className="h-4 w-4" />
                {formatDistanceToNow(new Date(userData.created_at), { 
                  locale: es, 
                  addSuffix: true 
                })}
              </p>
            </div>

            <Separator />

            <div className="text-sm text-muted-foreground">
              <p>Tu informaci√≥n est√° protegida y solo es visible para tu organizaci√≥n.</p>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="src/components/Reports/ReportsCenter.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  FileText,
  Download,
  Calendar,
  Clock,
  MoreVertical,
  Plus,
  Send,
  Settings,
  ExternalLink,
  FileSpreadsheet,
  Mail,
  Archive
} from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";

interface ScheduledReport {
  id: string;
  name: string;
  type: "weekly" | "monthly" | "custom";
  frequency: string;
  format: "pdf" | "excel" | "csv";
  recipients: string[];
  last_generated?: string;
  next_generation: string;
  active: boolean;
  template: string;
  filters: any;
}

interface GeneratedReport {
  id: string;
  name: string;
  type: string;
  format: string;
  size: string;
  generated_at: string;
  download_url: string;
  generated_by: string;
}

export function ReportsCenter() {
  const [scheduledReports, setScheduledReports] = useState<ScheduledReport[]>([]);
  const [generatedReports, setGeneratedReports] = useState<GeneratedReport[]>([]);
  const [loading, setLoading] = useState(true);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [activeTab, setActiveTab] = useState("scheduled");
  const { toast } = useToast();

  useEffect(() => {
    loadReports();
  }, []);

  const loadReports = async () => {
    try {
      setLoading(true);
      
      // Mock data for demonstration
      const mockScheduled: ScheduledReport[] = [
        {
          id: "1",
          name: "Reporte Semanal de Performance",
          type: "weekly",
          frequency: "Lunes 09:00",
          format: "pdf",
          recipients: ["admin@empresa.com", "rrpp@empresa.com"],
          last_generated: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
          next_generation: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
          active: true,
          template: "performance_summary",
          filters: { events: "all", period: "last_week" }
        },
        {
          id: "2",
          name: "Resumen Mensual Ejecutivo",
          type: "monthly",
          frequency: "1er d√≠a del mes",
          format: "excel",
          recipients: ["director@empresa.com"],
          last_generated: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
          next_generation: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000).toISOString(),
          active: true,
          template: "executive_summary",
          filters: { events: "all", period: "last_month" }
        }
      ];

      const mockGenerated: GeneratedReport[] = [
        {
          id: "1",
          name: "Reporte Semanal - Semana 3",
          type: "performance_summary",
          format: "PDF",
          size: "2.4 MB",
          generated_at: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
          download_url: "#",
          generated_by: "Sistema Autom√°tico"
        },
        {
          id: "2",
          name: "Exportaci√≥n Embajadores Enero",
          type: "ambassadors_export",
          format: "Excel",
          size: "1.8 MB",
          generated_at: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
          download_url: "#",
          generated_by: "Mar√≠a Garc√≠a"
        },
        {
          id: "3",
          name: "An√°lisis de Eventos Q1",
          type: "events_analysis",
          format: "PDF",
          size: "3.2 MB",
          generated_at: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(),
          download_url: "#",
          generated_by: "Carlos Ruiz"
        }
      ];

      setScheduledReports(mockScheduled);
      setGeneratedReports(mockGenerated);
    } catch (error) {
      console.error("Error loading reports:", error);
      toast({
        title: "Error",
        description: "No se pudieron cargar los reportes",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  const generateReport = async (reportId: string) => {
    try {
      toast({
        title: "Generando reporte",
        description: "El reporte se est√° generando. Te notificaremos cuando est√© listo."
      });
    } catch (error) {
      console.error("Error generating report:", error);
    }
  };

  const toggleReportStatus = async (reportId: string) => {
    try {
      setScheduledReports(prev => prev.map(report => 
        report.id === reportId 
          ? { ...report, active: !report.active }
          : report
      ));

      toast({
        title: "Reporte actualizado",
        description: "El estado del reporte programado ha sido cambiado"
      });
    } catch (error) {
      console.error("Error toggling report:", error);
    }
  };

  const downloadReport = async (reportId: string) => {
    try {
      toast({
        title: "Descargando reporte",
        description: "La descarga comenzar√° en unos segundos"
      });
    } catch (error) {
      console.error("Error downloading report:", error);
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString("es-ES", {
      day: "numeric",
      month: "short",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  };

  const getFormatIcon = (format: string) => {
    switch (format.toLowerCase()) {
      case "pdf":
        return <FileText className="w-4 h-4 text-red-500" />;
      case "excel":
      case "xlsx":
        return <FileSpreadsheet className="w-4 h-4 text-green-500" />;
      case "csv":
        return <FileSpreadsheet className="w-4 h-4 text-blue-500" />;
      default:
        return <FileText className="w-4 h-4" />;
    }
  };

  if (loading) {
    return (
      <div className="p-6">
        <div className="animate-pulse space-y-6">
          <div className="h-8 bg-muted rounded w-64" />
          <div className="grid gap-4">
            {[...Array(3)].map((_, i) => (
              <div key={i} className="h-32 bg-muted rounded-lg" />
            ))}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold bg-gradient-primary bg-clip-text text-transparent">
            Centro de Reportes
          </h1>
          <p className="text-muted-foreground">
            Gestiona reportes autom√°ticos y exportaciones programadas
          </p>
        </div>
        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
          <DialogTrigger asChild>
            <Button>
              <Plus className="w-4 h-4 mr-2" />
              Nuevo Reporte
            </Button>
          </DialogTrigger>
          <DialogContent className="max-w-2xl">
            <DialogHeader>
              <DialogTitle>Configurar Reporte Autom√°tico</DialogTitle>
              <DialogDescription>
                Configura un reporte programado que se genere autom√°ticamente
              </DialogDescription>
            </DialogHeader>
            <ReportForm onSave={() => setDialogOpen(false)} />
          </DialogContent>
        </Dialog>
      </div>

      {/* Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-blue-500/10 rounded-lg">
                <Calendar className="w-5 h-5 text-blue-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Reportes Programados</p>
                <p className="text-2xl font-bold">{scheduledReports.length}</p>
              </div>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-green-500/10 rounded-lg">
                <FileText className="w-5 h-5 text-green-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Generados Este Mes</p>
                <p className="text-2xl font-bold">{generatedReports.length}</p>
              </div>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-yellow-500/10 rounded-lg">
                <Clock className="w-5 h-5 text-yellow-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Pr√≥ximo Reporte</p>
                <p className="text-sm font-bold">En 1 d√≠a</p>
              </div>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-purple-500/10 rounded-lg">
                <Download className="w-5 h-5 text-purple-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Descargas Total</p>
                <p className="text-2xl font-bold">128</p>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Reports Tabs */}
      <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-6">
        <TabsList className="grid w-full grid-cols-3">
          <TabsTrigger value="scheduled">Programados</TabsTrigger>
          <TabsTrigger value="generated">Generados</TabsTrigger>
          <TabsTrigger value="templates">Plantillas</TabsTrigger>
        </TabsList>

        <TabsContent value="scheduled" className="space-y-4">
          {scheduledReports.length === 0 ? (
            <Card className="shadow-card">
              <CardContent className="p-8 text-center">
                <Calendar className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
                <h3 className="text-lg font-medium mb-2">No hay reportes programados</h3>
                <p className="text-muted-foreground mb-4">
                  Configura reportes autom√°ticos para recibir informaci√≥n peri√≥dicamente
                </p>
                <Button onClick={() => setDialogOpen(true)}>
                  <Plus className="w-4 h-4 mr-2" />
                  Programar Primer Reporte
                </Button>
              </CardContent>
            </Card>
          ) : (
            scheduledReports.map((report) => (
              <Card key={report.id} className="shadow-card">
                <CardContent className="p-6">
                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <div className="flex items-center space-x-3 mb-2">
                        <h3 className="text-lg font-semibold">{report.name}</h3>
                        <Badge variant={report.active ? "default" : "secondary"}>
                          {report.active ? "Activo" : "Pausado"}
                        </Badge>
                        <Badge variant="outline">
                          {report.format.toUpperCase()}
                        </Badge>
                      </div>
                      
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
                        <div>
                          <p className="text-sm text-muted-foreground">Frecuencia</p>
                          <p className="font-medium">{report.frequency}</p>
                        </div>
                        <div>
                          <p className="text-sm text-muted-foreground">Pr√≥xima generaci√≥n</p>
                          <p className="font-medium">{formatDate(report.next_generation)}</p>
                        </div>
                        <div>
                          <p className="text-sm text-muted-foreground">Destinatarios</p>
                          <p className="font-medium">{report.recipients.length} personas</p>
                        </div>
                      </div>
                      
                      {report.last_generated && (
                        <p className="text-xs text-muted-foreground mt-2">
                          √öltimo generado: {formatDate(report.last_generated)}
                        </p>
                      )}
                    </div>
                    
                    <div className="flex items-center space-x-2 ml-4">
                      <Switch
                        checked={report.active}
                        onCheckedChange={() => toggleReportStatus(report.id)}
                      />
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => generateReport(report.id)}
                      >
                        <Send className="w-4 h-4" />
                      </Button>
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" size="sm">
                            <MoreVertical className="w-4 h-4" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent>
                          <DropdownMenuItem>
                            <Settings className="w-4 h-4 mr-2" />
                            Configurar
                          </DropdownMenuItem>
                          <DropdownMenuItem>
                            <Mail className="w-4 h-4 mr-2" />
                            Enviar Ahora
                          </DropdownMenuItem>
                          <DropdownMenuItem>
                            <Archive className="w-4 h-4 mr-2" />
                            Archivar
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </div>
                </CardContent>
              </Card>
            ))
          )}
        </TabsContent>

        <TabsContent value="generated" className="space-y-4">
          {generatedReports.length === 0 ? (
            <Card className="shadow-card">
              <CardContent className="p-8 text-center">
                <FileText className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
                <h3 className="text-lg font-medium mb-2">No hay reportes generados</h3>
                <p className="text-muted-foreground">
                  Los reportes generados aparecer√°n aqu√≠ para su descarga
                </p>
              </CardContent>
            </Card>
          ) : (
            generatedReports.map((report) => (
              <Card key={report.id} className="shadow-card">
                <CardContent className="p-4">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center space-x-3">
                      {getFormatIcon(report.format)}
                      <div>
                        <h4 className="font-medium">{report.name}</h4>
                        <div className="flex items-center space-x-4 text-sm text-muted-foreground">
                          <span>{report.size}</span>
                          <span>{formatDate(report.generated_at)}</span>
                          <span>por {report.generated_by}</span>
                        </div>
                      </div>
                    </div>
                    
                    <div className="flex items-center space-x-2">
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => downloadReport(report.id)}
                      >
                        <Download className="w-4 h-4" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="sm"
                      >
                        <ExternalLink className="w-4 h-4" />
                      </Button>
                    </div>
                  </div>
                </CardContent>
              </Card>
            ))
          )}
        </TabsContent>

        <TabsContent value="templates" className="space-y-4">
          <Card className="shadow-card">
            <CardContent className="p-8 text-center">
              <FileText className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
              <h3 className="text-lg font-medium mb-2">Plantillas de Reportes</h3>
              <p className="text-muted-foreground">
                Pr√≥ximamente: editor de plantillas personalizadas
              </p>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}

function ReportForm({ onSave }: { onSave: () => void }) {
  const [formData, setFormData] = useState({
    name: "",
    type: "weekly",
    format: "pdf",
    recipients: "",
    active: true
  });

  const handleSave = () => {
    // Mock save - implement real logic
    onSave();
  };

  return (
    <div className="space-y-6">
      <div className="space-y-4">
        <div className="space-y-2">
          <Label htmlFor="report-name">Nombre del Reporte</Label>
          <Input
            id="report-name"
            value={formData.name}
            onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
            placeholder="Ej: Reporte Semanal de Performance"
          />
        </div>
        
        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label>Tipo de Reporte</Label>
            <Select
              value={formData.type}
              onValueChange={(value) => setFormData(prev => ({ ...prev, type: value }))}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="weekly">Semanal</SelectItem>
                <SelectItem value="monthly">Mensual</SelectItem>
                <SelectItem value="custom">Personalizado</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          <div className="space-y-2">
            <Label>Formato</Label>
            <Select
              value={formData.format}
              onValueChange={(value) => setFormData(prev => ({ ...prev, format: value }))}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="pdf">PDF</SelectItem>
                <SelectItem value="excel">Excel</SelectItem>
                <SelectItem value="csv">CSV</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>
        
        <div className="space-y-2">
          <Label htmlFor="recipients">Destinatarios (emails separados por coma)</Label>
          <Input
            id="recipients"
            value={formData.recipients}
            onChange={(e) => setFormData(prev => ({ ...prev, recipients: e.target.value }))}
            placeholder="admin@empresa.com, rrpp@empresa.com"
          />
        </div>
        
        <div className="flex items-center space-x-2">
          <Switch
            id="report-active"
            checked={formData.active}
            onCheckedChange={(checked) => setFormData(prev => ({ ...prev, active: checked }))}
          />
          <Label htmlFor="report-active">Activar reporte inmediatamente</Label>
        </div>
      </div>
      
      <div className="flex justify-end space-x-2">
        <Button variant="outline">
          Cancelar
        </Button>
        <Button onClick={handleSave} disabled={!formData.name}>
          Crear Reporte
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/Security/SecurityCenter.tsx">
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Shield,
  Key,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Clock,
  MapPin,
  Smartphone,
  Monitor,
  LogOut,
  Settings,
  Eye,
  Download
} from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";

interface SecurityEvent {
  id: string;
  type: "login" | "failed_login" | "password_change" | "suspicious_activity";
  description: string;
  user_email: string;
  ip_address: string;
  location: string;
  device: string;
  timestamp: string;
  risk_level: "low" | "medium" | "high";
}

interface ActiveSession {
  id: string;
  user_email: string;
  device: string;
  location: string;
  ip_address: string;
  last_activity: string;
  is_current: boolean;
}

interface SecurityPolicy {
  id: string;
  name: string;
  description: string;
  enabled: boolean;
  value: any;
}

export function SecurityCenter() {
  const [securityEvents, setSecurityEvents] = useState<SecurityEvent[]>([]);
  const [activeSessions, setActiveSessions] = useState<ActiveSession[]>([]);
  const [securityPolicies, setSecurityPolicies] = useState<SecurityPolicy[]>([]);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState("events");
  const { toast } = useToast();

  useEffect(() => {
    loadSecurityData();
  }, []);

  const loadSecurityData = async () => {
    try {
      setLoading(true);
      
      // Mock data for demonstration
      const mockEvents: SecurityEvent[] = [
        {
          id: "1",
          type: "login",
          description: "Inicio de sesi√≥n exitoso",
          user_email: "admin@empresa.com",
          ip_address: "192.168.1.100",
          location: "Santiago, Chile",
          device: "Chrome - Windows",
          timestamp: new Date().toISOString(),
          risk_level: "low"
        },
        {
          id: "2",
          type: "failed_login",
          description: "Intento de acceso fallido",
          user_email: "admin@empresa.com",
          ip_address: "203.0.113.1",
          location: "Ubicaci√≥n desconocida",
          device: "Chrome - Linux",
          timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
          risk_level: "medium"
        },
        {
          id: "3",
          type: "suspicious_activity",
          description: "M√∫ltiples intentos de acceso desde IP diferente",
          user_email: "rrpp@empresa.com",
          ip_address: "198.51.100.1",
          location: "Buenos Aires, Argentina",
          device: "Firefox - macOS",
          timestamp: new Date(Date.now() - 4 * 60 * 60 * 1000).toISOString(),
          risk_level: "high"
        }
      ];

      const mockSessions: ActiveSession[] = [
        {
          id: "1",
          user_email: "admin@empresa.com",
          device: "Chrome - Windows",
          location: "Santiago, Chile",
          ip_address: "192.168.1.100",
          last_activity: new Date(Date.now() - 10 * 60 * 1000).toISOString(),
          is_current: true
        },
        {
          id: "2",
          user_email: "admin@empresa.com",
          device: "Safari - iPhone",
          location: "Santiago, Chile",
          ip_address: "192.168.1.101",
          last_activity: new Date(Date.now() - 60 * 60 * 1000).toISOString(),
          is_current: false
        }
      ];

      const mockPolicies: SecurityPolicy[] = [
        {
          id: "1",
          name: "Contrase√±a Fuerte",
          description: "Requerir contrase√±as con al menos 8 caracteres, may√∫sculas, min√∫sculas y n√∫meros",
          enabled: true,
          value: { min_length: 8, require_uppercase: true, require_numbers: true }
        },
        {
          id: "2",
          name: "Autenticaci√≥n de Dos Factores",
          description: "Habilitar 2FA obligatorio para administradores",
          enabled: false,
          value: { required_for_admins: true }
        },
        {
          id: "3",
          name: "Expiraci√≥n de Sesi√≥n",
          description: "Cerrar sesiones autom√°ticamente despu√©s de inactividad",
          enabled: true,
          value: { timeout_minutes: 60 }
        },
        {
          id: "4",
          name: "Alertas de Ubicaci√≥n",
          description: "Notificar cuando se detecte acceso desde nueva ubicaci√≥n",
          enabled: true,
          value: { notify_new_location: true }
        }
      ];

      setSecurityEvents(mockEvents);
      setActiveSessions(mockSessions);
      setSecurityPolicies(mockPolicies);
    } catch (error) {
      console.error("Error loading security data:", error);
      toast({
        title: "Error",
        description: "No se pudieron cargar los datos de seguridad",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  const terminateSession = async (sessionId: string) => {
    try {
      setActiveSessions(prev => prev.filter(session => session.id !== sessionId));
      
      toast({
        title: "Sesi√≥n terminada",
        description: "La sesi√≥n ha sido cerrada exitosamente"
      });
    } catch (error) {
      console.error("Error terminating session:", error);
    }
  };

  const togglePolicy = async (policyId: string) => {
    try {
      setSecurityPolicies(prev => prev.map(policy => 
        policy.id === policyId 
          ? { ...policy, enabled: !policy.enabled }
          : policy
      ));

      toast({
        title: "Pol√≠tica actualizada",
        description: "La configuraci√≥n de seguridad ha sido actualizada"
      });
    } catch (error) {
      console.error("Error updating policy:", error);
    }
  };

  const exportSecurityLog = async () => {
    try {
      toast({
        title: "Exportando log",
        description: "El log de seguridad se est√° generando para descarga"
      });
    } catch (error) {
      console.error("Error exporting log:", error);
    }
  };

  const getRiskLevelBadge = (level: string) => {
    switch (level) {
      case "high":
        return <Badge variant="destructive">Alto Riesgo</Badge>;
      case "medium":
        return <Badge variant="secondary">Riesgo Medio</Badge>;
      case "low":
        return <Badge variant="outline">Bajo Riesgo</Badge>;
      default:
        return null;
    }
  };

  const getEventIcon = (type: string) => {
    switch (type) {
      case "login":
        return <CheckCircle className="w-4 h-4 text-green-500" />;
      case "failed_login":
        return <XCircle className="w-4 h-4 text-red-500" />;
      case "suspicious_activity":
        return <AlertTriangle className="w-4 h-4 text-yellow-500" />;
      default:
        return <Shield className="w-4 h-4" />;
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleString("es-ES", {
      day: "numeric",
      month: "short",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  };

  const getTimeAgo = (dateString: string) => {
    const now = new Date();
    const date = new Date(dateString);
    const diffInMinutes = Math.floor((now.getTime() - date.getTime()) / (1000 * 60));
    
    if (diffInMinutes < 60) return `Hace ${diffInMinutes} min`;
    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) return `Hace ${diffInHours}h`;
    const diffInDays = Math.floor(diffInHours / 24);
    return `Hace ${diffInDays}d`;
  };

  if (loading) {
    return (
      <div className="p-6">
        <div className="animate-pulse space-y-6">
          <div className="h-8 bg-muted rounded w-64" />
          <div className="grid gap-4">
            {[...Array(4)].map((_, i) => (
              <div key={i} className="h-32 bg-muted rounded-lg" />
            ))}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold bg-gradient-primary bg-clip-text text-transparent">
            Centro de Seguridad
          </h1>
          <p className="text-muted-foreground">
            Monitorea y gestiona la seguridad de tu organizaci√≥n
          </p>
        </div>
        <Button onClick={exportSecurityLog}>
          <Download className="w-4 h-4 mr-2" />
          Exportar Log
        </Button>
      </div>

      {/* Security Status */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-green-500/10 rounded-lg">
                <Shield className="w-5 h-5 text-green-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Estado de Seguridad</p>
                <p className="text-lg font-bold text-green-500">Seguro</p>
              </div>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-blue-500/10 rounded-lg">
                <Monitor className="w-5 h-5 text-blue-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Sesiones Activas</p>
                <p className="text-2xl font-bold">{activeSessions.length}</p>
              </div>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-yellow-500/10 rounded-lg">
                <AlertTriangle className="w-5 h-5 text-yellow-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Eventos de Riesgo</p>
                <p className="text-2xl font-bold">
                  {securityEvents.filter(e => e.risk_level === "high").length}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-3">
              <div className="p-2 bg-purple-500/10 rounded-lg">
                <Key className="w-5 h-5 text-purple-500" />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">Pol√≠ticas Activas</p>
                <p className="text-2xl font-bold">
                  {securityPolicies.filter(p => p.enabled).length}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Security Tabs */}
      <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-6">
        <TabsList className="grid w-full grid-cols-3">
          <TabsTrigger value="events">Eventos de Seguridad</TabsTrigger>
          <TabsTrigger value="sessions">Sesiones Activas</TabsTrigger>
          <TabsTrigger value="policies">Pol√≠ticas</TabsTrigger>
        </TabsList>

        <TabsContent value="events" className="space-y-4">
          {securityEvents.length === 0 ? (
            <Card className="shadow-card">
              <CardContent className="p-8 text-center">
                <Shield className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
                <h3 className="text-lg font-medium mb-2">No hay eventos de seguridad</h3>
                <p className="text-muted-foreground">
                  Los eventos de seguridad aparecer√°n aqu√≠ para su monitoreo
                </p>
              </CardContent>
            </Card>
          ) : (
            securityEvents.map((event) => (
              <Card key={event.id} className="shadow-card">
                <CardContent className="p-4">
                  <div className="flex items-start justify-between">
                    <div className="flex items-start space-x-3">
                      {getEventIcon(event.type)}
                      <div className="flex-1">
                        <div className="flex items-center space-x-2 mb-1">
                          <h4 className="font-medium">{event.description}</h4>
                          {getRiskLevelBadge(event.risk_level)}
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-2 text-sm text-muted-foreground">
                          <div className="flex items-center space-x-1">
                            <MapPin className="w-3 h-3" />
                            <span>{event.location}</span>
                          </div>
                          <div className="flex items-center space-x-1">
                            <Monitor className="w-3 h-3" />
                            <span>{event.device}</span>
                          </div>
                          <div>Usuario: {event.user_email}</div>
                          <div>IP: {event.ip_address}</div>
                        </div>
                      </div>
                    </div>
                    <div className="text-right text-sm text-muted-foreground">
                      <div>{formatDate(event.timestamp)}</div>
                      <div>{getTimeAgo(event.timestamp)}</div>
                    </div>
                  </div>
                </CardContent>
              </Card>
            ))
          )}
        </TabsContent>

        <TabsContent value="sessions" className="space-y-4">
          {activeSessions.length === 0 ? (
            <Card className="shadow-card">
              <CardContent className="p-8 text-center">
                <Monitor className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
                <h3 className="text-lg font-medium mb-2">No hay sesiones activas</h3>
                <p className="text-muted-foreground">
                  Las sesiones activas de usuarios aparecer√°n aqu√≠
                </p>
              </CardContent>
            </Card>
          ) : (
            activeSessions.map((session) => (
              <Card key={session.id} className={`shadow-card ${session.is_current ? 'border-primary' : ''}`}>
                <CardContent className="p-4">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center space-x-3">
                      <div className="p-2 bg-blue-500/10 rounded-lg">
                        {session.device.includes('iPhone') || session.device.includes('Android') ? 
                          <Smartphone className="w-5 h-5 text-blue-500" /> : 
                          <Monitor className="w-5 h-5 text-blue-500" />
                        }
                      </div>
                      <div>
                        <div className="flex items-center space-x-2 mb-1">
                          <h4 className="font-medium">{session.user_email}</h4>
                          {session.is_current && (
                            <Badge variant="default">Sesi√≥n Actual</Badge>
                          )}
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-2 text-sm text-muted-foreground">
                          <div className="flex items-center space-x-1">
                            <Monitor className="w-3 h-3" />
                            <span>{session.device}</span>
                          </div>
                          <div className="flex items-center space-x-1">
                            <MapPin className="w-3 h-3" />
                            <span>{session.location}</span>
                          </div>
                          <div className="flex items-center space-x-1">
                            <Clock className="w-3 h-3" />
                            <span>Activa {getTimeAgo(session.last_activity)}</span>
                          </div>
                        </div>
                        <div className="text-xs text-muted-foreground mt-1">
                          IP: {session.ip_address}
                        </div>
                      </div>
                    </div>
                    
                    {!session.is_current && (
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => terminateSession(session.id)}
                      >
                        <LogOut className="w-4 h-4" />
                      </Button>
                    )}
                  </div>
                </CardContent>
              </Card>
            ))
          )}
        </TabsContent>

        <TabsContent value="policies" className="space-y-4">
          {securityPolicies.map((policy) => (
            <Card key={policy.id} className="shadow-card">
              <CardContent className="p-6">
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="flex items-center space-x-3 mb-2">
                      <h3 className="text-lg font-semibold">{policy.name}</h3>
                      <Badge variant={policy.enabled ? "default" : "secondary"}>
                        {policy.enabled ? "Activa" : "Inactiva"}
                      </Badge>
                    </div>
                    <p className="text-muted-foreground">{policy.description}</p>
                  </div>
                  
                  <div className="flex items-center space-x-2 ml-4">
                    <Switch
                      checked={policy.enabled}
                      onCheckedChange={() => togglePolicy(policy.id)}
                    />
                    <Button variant="ghost" size="sm">
                      <Settings className="w-4 h-4" />
                    </Button>
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/components/Settings/InstagramConfigChecklist.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Separator } from "@/components/ui/separator";
import { 
  CheckCircle, 
  AlertCircle, 
  ExternalLink,
  Settings,
  Link2,
  Users,
  Info
} from "lucide-react";
import { useState, useEffect } from "react";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { useInstagramConnection } from "@/hooks/useInstagramConnection";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

interface InstagramConfigChecklistProps {
  onOpenCredentials?: () => void;
}

export function InstagramConfigChecklist({ onOpenCredentials }: InstagramConfigChecklistProps) {
  const { organization } = useCurrentOrganization();
  const { isConnected } = useInstagramConnection();
  const [hasCredentials, setHasCredentials] = useState(false);
  
  // Safe data access
  const instagramUsername = organization?.instagram_username || null;
  
  const currentDomain = window.location.origin;
  const redirectUri = `${currentDomain}/api/meta-oauth?action=callback`;

  useEffect(() => {
    if (organization) {
      checkCredentialsStatus();
    }
  }, [organization]);

  const checkCredentialsStatus = async () => {
    if (!organization?.id) return;

    try {
      const { data, error } = await supabase.rpc('get_org_meta_credentials_status', {
        p_organization_id: organization.id
      });

      if (error) {
        console.error('Error checking credentials status:', error);
        // Show only unexpected server errors, not permission issues
        if (!error.message?.includes('permission') && !error.message?.includes('unauthorized')) {
          toast.error('Error al verificar credenciales', {
            description: 'Error del servidor al verificar credenciales'
          });
        }
        setHasCredentials(false);
        return;
      }

      if (data && data.length > 0) {
        setHasCredentials(data[0].has_credentials || false);
      } else {
        setHasCredentials(false);
      }
    } catch (error) {
      console.error('Error checking credentials status:', error);
      setHasCredentials(false);
      // Only show toast for unexpected errors
      toast.error('Error de conexi√≥n', {
        description: 'No se pudo conectar con el servidor'
      });
    }
  };
  
  const getCheckStatus = (condition: boolean) => {
    return condition ? (
      <CheckCircle className="h-4 w-4 text-success" />
    ) : (
      <AlertCircle className="h-4 w-4 text-destructive" />
    );
  };

  const checklist = [
    {
      title: "Credenciales de Meta App",
      description: "App ID, App Secret y Webhook Verify Token",
      status: hasCredentials,
      action: hasCredentials ? "Verificar credenciales" : "Configurar credenciales",
      link: hasCredentials ? "https://developers.facebook.com/apps" : undefined,
      onClick: hasCredentials ? undefined : onOpenCredentials
    },
    {
      title: "URL de Redirecci√≥n OAuth",
      description: `Agregar ${redirectUri} a las URIs v√°lidas`,
      status: !!instagramUsername,
      action: "Configurar en Meta Developer Console",
      link: "https://developers.facebook.com/apps"
    },
    {
      title: "Webhook Configurado", 
      description: "URL del webhook y token de verificaci√≥n",
      status: false, // We'll check this via webhook status later
      action: "Configurar webhook endpoint",
      link: "https://developers.facebook.com/apps"
    },
    {
      title: "Suscripciones de Instagram",
      description: "Eventos: mentions, story_insights, live_comments",
      status: false,
      action: "Activar suscripciones",
      link: "https://developers.facebook.com/apps"
    },
    {
      title: "Usuario como Tester",
      description: "Tu cuenta debe estar en la lista de testers",
      status: !!instagramUsername,
      action: "Agregar en App Roles",
      link: "https://developers.facebook.com/apps"
    }
  ];

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Settings className="h-5 w-5" />
          Configuraci√≥n Meta Developer App
        </CardTitle>
        <CardDescription>
          Verifica que tu app de Meta est√© configurada correctamente para la integraci√≥n
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Current Domain Info */}
        <div className="p-3 bg-muted rounded-md">
          <div className="flex items-center gap-2 mb-2">
            <Link2 className="h-4 w-4" />
            <span className="font-medium text-sm">Dominio Actual</span>
          </div>
          <code className="text-sm bg-background px-2 py-1 rounded border break-all">
            {currentDomain}
          </code>
        </div>

        <Separator />

        {/* Checklist Items */}
        <div className="space-y-3">
          {checklist.map((item, index) => (
            <div key={index} className="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-3 p-3 border rounded-md">
              <div className="flex items-start gap-3 flex-1">
                {getCheckStatus(item.status)}
                <div className="space-y-1 break-words">
                  <div className="font-medium text-sm">{item.title}</div>
                  <div className="text-sm text-muted-foreground break-words">{item.description}</div>
                </div>
              </div>
              <Button
                variant="outline"
                size="sm"
                className="w-full sm:w-auto shrink-0"
                onClick={() => {
                  if (item.onClick) {
                    item.onClick();
                  } else if (item.link) {
                    window.open(item.link, '_blank');
                  }
                }}
              >
                {item.link && <ExternalLink className="h-3 w-3 mr-1" />}
                {!item.link && <Settings className="h-3 w-3 mr-1" />}
                <span className="truncate">{item.action}</span>
              </Button>
            </div>
          ))}
        </div>

        <Separator />

        {/* Webhook URL Info */}
        <div className="space-y-3">
          <div className="flex items-center gap-2">
            <Link2 className="h-4 w-4" />
            <span className="font-medium text-sm">URL del Webhook</span>
          </div>
          <code className="block text-sm bg-background px-3 py-2 rounded border break-all">
            {currentDomain}/api/meta-oauth?action=webhook
          </code>
        </div>

        {/* Important Notes */}
        <div className="flex items-start gap-2 p-3 bg-blue-50 rounded-md">
          <Info className="h-4 w-4 text-blue-600 mt-0.5" />
          <div className="text-sm text-blue-700">
            <p className="font-medium mb-1">Notas Importantes</p>
            <ul className="space-y-1 text-sm">
              <li>‚Ä¢ La app debe estar en modo "Desarrollo" para testing</li>
              <li>‚Ä¢ Agrega tu cuenta de Instagram como tester</li>
              <li>‚Ä¢ Vincular una p√°gina de Facebook con cuenta business de Instagram</li>
              <li>‚Ä¢ Los permisos requeridos: instagram_basic, pages_show_list, pages_read_engagement</li>
            </ul>
          </div>
        </div>

        {/* Connection Status */}
        {isConnected && (
          <div className="p-3 bg-green-50 rounded-md">
            <div className="flex items-center gap-2 mb-2">
              <CheckCircle className="h-4 w-4 text-green-600" />
              <span className="font-medium text-sm text-green-800">Instagram Conectado</span>
            </div>
            <div className="text-sm text-green-700">
              {instagramUsername && (
                <div>Usuario: @{instagramUsername}</div>
              )}
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Settings/InstagramConfigGuide.tsx">
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { CheckCircle, ExternalLink, Copy, AlertTriangle } from "lucide-react";
import { toast } from "sonner";

interface InstagramConfigGuideProps {
  isOpen: boolean;
  onClose: () => void;
}

export function InstagramConfigGuide({ isOpen, onClose }: InstagramConfigGuideProps) {
  const redirectUri = `${window.location.origin}/api/meta-oauth?action=callback`;
  const webhookUrl = `https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-webhook`;

  const copyToClipboard = (text: string, label: string) => {
    navigator.clipboard.writeText(text);
    toast.success(`${label} copiado al portapapeles`);
  };

  const steps = [
    {
      title: "1. Crear App en Meta Developers",
      description: "Crea una nueva aplicaci√≥n para tu organizaci√≥n",
      action: "Ir a Meta Developers",
      url: "https://developers.facebook.com/apps/",
      details: [
        "Haz clic en 'Crear app'",
        "Selecciona tipo 'Empresa' o 'Consumidor'",
        "Completa el nombre de tu app y email de contacto",
        "Guarda el App ID que se genera"
      ]
    },
    {
      title: "2. Configurar Productos",
      description: "A√±ade los productos necesarios para Instagram",
      details: [
        "A√±adir 'Instagram Basic Display' (para cuentas personales)",
        "A√±adir 'Instagram Graph API' (para cuentas business)",
        "A√±adir 'Webhooks' para notificaciones en tiempo real"
      ]
    },
    {
      title: "3. Configurar Instagram Basic Display",
      description: "Configura el acceso b√°sico a Instagram",
      details: [
        "Ve a Instagram Basic Display > Basic Display",
        "A√±ade la Redirect URI:",
        redirectUri,
        "Guarda los cambios"
      ]
    },
    {
      title: "4. Configurar Webhooks",
      description: "Configura las notificaciones autom√°ticas",
      details: [
        "Ve a Webhooks en el men√∫ lateral",
        "Crea un nuevo webhook con esta URL:",
        webhookUrl,
        "Usa un Verify Token personalizado (lo necesitar√°s despu√©s)",
        "Selecciona los campos: feed, messages"
      ]
    },
    {
      title: "5. Obtener Credenciales",
      description: "Copia las credenciales de tu app",
      details: [
        "Ve a Configuraci√≥n > B√°sica",
        "Copia el 'ID de la app'",
        "Copia el 'Secreto de la app' (haz clic en 'Mostrar')",
        "Tambi√©n necesitar√°s el Verify Token que usaste en el paso 4"
      ]
    }
  ];

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <svg className="h-5 w-5" viewBox="0 0 24 24" fill="currentColor">
              <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
            </svg>
            Gu√≠a: Configurar Meta Developers App
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {/* Advertencia importante */}
          <Card className="border-amber-200 bg-amber-50 dark:bg-amber-900/20">
            <CardHeader className="pb-3">
              <CardTitle className="flex items-center gap-2 text-amber-800 dark:text-amber-400">
                <AlertTriangle className="h-5 w-5" />
                Importante
              </CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-amber-700 dark:text-amber-300">
                Cada organizaci√≥n debe tener su propia aplicaci√≥n en Meta Developers. 
                No compartas credenciales entre diferentes organizaciones o clientes.
              </p>
            </CardContent>
          </Card>

          {/* URLs de referencia */}
          <Card>
            <CardHeader>
              <CardTitle>URLs que necesitar√°s</CardTitle>
              <CardDescription>
                Guarda estas URLs, las necesitar√°s durante la configuraci√≥n
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <div className="flex items-center justify-between mb-2">
                  <Badge variant="outline">Redirect URI</Badge>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => copyToClipboard(redirectUri, "Redirect URI")}
                  >
                    <Copy className="h-4 w-4 mr-2" />
                    Copiar
                  </Button>
                </div>
                <code className="block p-2 bg-muted rounded text-sm font-mono break-all">
                  {redirectUri}
                </code>
              </div>

              <div>
                <div className="flex items-center justify-between mb-2">
                  <Badge variant="outline">Webhook URL</Badge>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => copyToClipboard(webhookUrl, "Webhook URL")}
                  >
                    <Copy className="h-4 w-4 mr-2" />
                    Copiar
                  </Button>
                </div>
                <code className="block p-2 bg-muted rounded text-sm font-mono break-all">
                  {webhookUrl}
                </code>
              </div>
            </CardContent>
          </Card>

          {/* Pasos detallados */}
          <div className="space-y-4">
            {steps.map((step, index) => (
              <Card key={index}>
                <CardHeader className="pb-3">
                  <div className="flex items-center justify-between">
                    <CardTitle className="text-lg">{step.title}</CardTitle>
                    {step.url && (
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => window.open(step.url, '_blank')}
                        className="gap-2"
                      >
                        <ExternalLink className="h-4 w-4" />
                        {step.action}
                      </Button>
                    )}
                  </div>
                  <CardDescription>{step.description}</CardDescription>
                </CardHeader>
                <CardContent>
                  <ul className="space-y-2">
                    {step.details.map((detail, detailIndex) => (
                      <li key={detailIndex} className="flex items-start gap-2">
                        <CheckCircle className="h-4 w-4 text-green-600 mt-0.5 flex-shrink-0" />
                        <span className="text-sm">
                          {detail.startsWith('http') ? (
                            <code className="bg-muted px-1 py-0.5 rounded text-xs font-mono break-all">
                              {detail}
                            </code>
                          ) : (
                            detail
                          )}
                        </span>
                      </li>
                    ))}
                  </ul>
                </CardContent>
              </Card>
            ))}
          </div>

          {/* Siguiente paso */}
          <Card className="border-blue-200 bg-blue-50 dark:bg-blue-900/20">
            <CardContent className="p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="font-medium text-blue-800 dark:text-blue-400">
                    ¬øYa configuraste tu Meta App?
                  </p>
                  <p className="text-sm text-blue-600 dark:text-blue-500">
                    Regresa al onboarding para ingresar tus credenciales y conectar Instagram
                  </p>
                </div>
                <Button onClick={onClose} className="gap-2">
                  Continuar Configuraci√≥n
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Settings/InstagramDiagnosticsPanel.tsx">
import React from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { 
  CheckCircle, 
  XCircle, 
  Clock, 
  AlertCircle, 
  Play,
  Zap,
  Globe,
  Shield,
  Activity,
  Settings,
  Copy,
  AlertTriangle
} from "lucide-react";
import { Label } from "@/components/ui/label";
import { useInstagramDiagnostics } from "@/hooks/useInstagramDiagnostics";

interface DiagnosticsResult {
  name: string;
  status: 'success' | 'error' | 'pending';
  message: string;
  details?: any;
}

export const InstagramDiagnosticsPanel: React.FC = () => {
  const {
    isRunning,
    connectionTests,
    webhookStatus,
    runConnectionTests,
    testWebhookDelivery
  } = useInstagramDiagnostics();

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'success':
        return <CheckCircle className="w-4 h-4 text-success" />;
      case 'error':
        return <XCircle className="w-4 h-4 text-destructive" />;
      case 'pending':
        return <Clock className="w-4 h-4 text-warning animate-pulse" />;
      default:
        return <AlertCircle className="w-4 h-4 text-muted-foreground" />;
    }
  };

  const getStatusVariant = (status: string): "default" | "secondary" | "destructive" | "outline" => {
    switch (status) {
      case 'success':
        return 'default';
      case 'error':
        return 'destructive';
      case 'pending':
        return 'secondary';
      default:
        return 'outline';
    }
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Activity className="w-5 h-5" />
            Diagn√≥sticos de Instagram
          </CardTitle>
          <CardDescription>
            Ejecuta pruebas completas para verificar la conectividad y funcionalidad de Instagram
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex gap-2">
            <Button 
              onClick={runConnectionTests}
              disabled={isRunning}
              className="flex items-center gap-2"
            >
              {isRunning ? (
                <>
                  <Clock className="w-4 h-4 animate-spin" />
                  Ejecutando...
                </>
              ) : (
                <>
                  <Play className="w-4 h-4" />
                  Ejecutar Diagn√≥sticos
                </>
              )}
            </Button>
            
            <Button 
              onClick={testWebhookDelivery}
              variant="outline"
              className="flex items-center gap-2"
            >
              <Zap className="w-4 h-4" />
              Probar Webhook
            </Button>
          </div>

          {connectionTests.length > 0 && (
            <div className="space-y-3">
              <h4 className="font-medium">Resultados de las Pruebas:</h4>
              <div className="space-y-2">
                {connectionTests.map((test, index) => (
                  <div 
                    key={index}
                    className="flex items-center justify-between p-3 border rounded-lg bg-background/50"
                  >
                    <div className="flex items-center gap-3">
                      {getStatusIcon(test.status)}
                      <div>
                        <p className="font-medium">{test.name}</p>
                        <p className="text-sm text-muted-foreground">{test.message}</p>
                      </div>
                    </div>
                    <Badge variant={getStatusVariant(test.status)}>
                      {test.status === 'success' ? 'Exitoso' : 
                       test.status === 'error' ? 'Error' : 'Pendiente'}
                    </Badge>
                  </div>
                ))}
              </div>
            </div>
          )}

          {webhookStatus && (
            <Alert>
              <Globe className="w-4 h-4" />
              <AlertDescription>
                <strong>Estado del Webhook:</strong>{' '}
                {webhookStatus.configured && webhookStatus.reachable 
                  ? 'Configurado y funcionando correctamente'
                  : webhookStatus.configured 
                    ? 'Configurado pero puede tener problemas de conectividad'
                    : 'No configurado correctamente'
                }
                {webhookStatus.lastEvent && (
                  <div className="mt-1 text-xs text-muted-foreground">
                    √öltimo evento: {webhookStatus.lastEvent}
                  </div>
                )}
              </AlertDescription>
            </Alert>
          )}
        </CardContent>
      </Card>

      <Card className="bg-card/50 backdrop-blur-sm border-border/50">
        <CardHeader>
          <CardTitle className="flex items-center gap-2 text-primary">
            <Settings className="h-5 w-5" />
            Estado del Webhook
          </CardTitle>
          <CardDescription>
            Estado de configuraci√≥n y conectividad del webhook
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {webhookStatus && (
            <div className="space-y-3">
              <div className="flex items-center justify-between p-3 bg-muted rounded-lg">
                <span className="text-sm font-medium">Credenciales Configuradas</span>
                <Badge variant={webhookStatus.credentials_configured ? "default" : "destructive"}>
                  {webhookStatus.credentials_configured ? 'S√≠' : 'No'}
                </Badge>
              </div>
              
              {webhookStatus.app_id && (
                <div className="flex items-center justify-between p-3 bg-muted rounded-lg">
                  <span className="text-sm font-medium">App ID</span>
                  <code className="text-sm font-mono">{webhookStatus.app_id}</code>
                </div>
              )}
              
              <div className="flex items-center justify-between p-3 bg-muted rounded-lg">
                <span className="text-sm font-medium">Webhook Alcanzable</span>
                <Badge variant={webhookStatus.reachable ? "default" : "secondary"}>
                  {webhookStatus.reachable ? 'Activo' : 'Sin actividad reciente'}
                </Badge>
              </div>
              
              {webhookStatus.recent_activity && webhookStatus.recent_activity.length > 0 && (
                <div className="space-y-2">
                  <Label className="text-sm font-medium">Actividad Reciente</Label>
                  <div className="space-y-1">
                    {webhookStatus.recent_activity.slice(0, 3).map((activity, index) => (
                      <div key={index} className="flex items-center justify-between text-xs p-2 bg-muted/50 rounded">
                        <span>{activity.type}</span>
                        <span className="text-muted-foreground">
                          {new Date(activity.created_at).toLocaleString()}
                        </span>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}
          
          <div className="space-y-2">
            <Label className="text-sm font-medium">URL del Webhook</Label>
            <div className="flex items-center gap-2 p-3 bg-muted rounded-lg">
              <code className="flex-1 text-sm font-mono">
                https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-webhook
              </code>
              <Button
                variant="outline"
                size="sm"
                onClick={() => copyToClipboard('https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-webhook')}
              >
                <Copy className="h-4 w-4" />
              </Button>
            </div>
          </div>
          
          <div className="space-y-2">
            <Label className="text-sm font-medium">Suscripciones Requeridas</Label>
            <div className="grid grid-cols-2 gap-2">
              {['messages', 'messaging_referrals'].map((field) => (
                <div key={field} className="flex items-center gap-2 p-2 bg-muted rounded">
                  <Badge variant="secondary" className="text-xs">
                    {field}
                  </Badge>
                </div>
              ))}
            </div>
          </div>

          <Alert>
            <AlertTriangle className="h-4 w-4" />
            <AlertTitle>Configuraci√≥n Importante</AlertTitle>
            <AlertDescription className="text-sm">
              1. Verifica que en Meta Developer Console el URL del webhook sea exactamente el mostrado arriba<br/>
              2. Aseg√∫rate de que el App Secret en Meta coincida con el guardado en EVA<br/>
              3. Las suscripciones 'messages' y 'messaging_referrals' deben estar activas
            </AlertDescription>
          </Alert>
        </CardContent>
      </Card>
    </div>
  );
};
</file>

<file path="src/components/Settings/InstagramSettings.tsx">
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Instagram, AlertCircle, CheckCircle, RefreshCw, Settings, BookOpen, Activity, Play, Copy, ExternalLink, Info } from "lucide-react";
import { useInstagramConnection } from "@/hooks/useInstagramConnection";
import { useInstagramSync } from "@/hooks/useInstagramSync";
import { useInstagramDiagnostics } from "@/hooks/useInstagramDiagnostics";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { MetaAppCredentialsForm } from "./MetaAppCredentialsForm";
import { InstagramConfigGuide } from "./InstagramConfigGuide";
import { toast } from "sonner";

export function InstagramSettings() {
  const { organization } = useCurrentOrganization();
  const { isConnected, isTokenExpired, isConnecting, connectInstagram, disconnectInstagram, refreshTokenStatus } = useInstagramConnection();
  const { isSyncing, syncInstagramData, refreshToken } = useInstagramSync();
  const { isRunning, connectionTests, webhookStatus, runConnectionTests, testWebhookDelivery } = useInstagramDiagnostics();
  
  const [showCredentialsForm, setShowCredentialsForm] = useState(false);
  const [showConfigGuide, setShowConfigGuide] = useState(false);

  const getStatusInfo = () => {
    if (!isConnected) {
      return {
        status: 'Desconectado',
        variant: 'destructive' as const,
        icon: <AlertCircle className="h-4 w-4" />,
        description: 'Instagram no est√° conectado a tu organizaci√≥n'
      };
    }
    
    if (isTokenExpired) {
      return {
        status: 'Token Expirado',
        variant: 'destructive' as const,
        icon: <AlertCircle className="h-4 w-4" />,
        description: 'El token de acceso ha expirado y necesita ser renovado'
      };
    }
    
    return {
      status: 'Conectado',
      variant: 'default' as const,
      icon: <CheckCircle className="h-4 w-4" />,
      description: 'Instagram est√° conectado y funcionando correctamente'
    };
  };

  const statusInfo = getStatusInfo();

  const handleModalClose = () => {
    setShowCredentialsForm(false);
    setShowConfigGuide(false);
    refreshTokenStatus(); // Refresh status after closing modals
  };

  // Handle connection with automatic credential check
  const handleConnectClick = () => {
    connectInstagram(() => {
      // This callback opens the credentials form if they're missing
      setShowCredentialsForm(true);
    });
  };

  return (
    <div className="space-y-6">
      {/* Gu√≠a y configuraci√≥n de credenciales */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Settings className="h-5 w-5" />
            Configuraci√≥n de Meta App
          </CardTitle>
          <CardDescription>
            Cada organizaci√≥n necesita su propia aplicaci√≥n en Meta Developers
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex gap-2">
            <Button
              variant="outline"
              onClick={() => setShowConfigGuide(true)}
              className="gap-2"
            >
              <BookOpen className="h-4 w-4" />
              Ver Gu√≠a Completa
            </Button>
            <Button
              onClick={() => setShowCredentialsForm(true)}
              className="gap-2"
            >
              <Settings className="h-4 w-4" />
              Configurar Credenciales
            </Button>
          </div>
        </CardContent>
      </Card>

      {/* Webhook Configuration Info */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Info className="h-5 w-5" />
            Configuraci√≥n de Webhooks
          </CardTitle>
          <CardDescription>
            Informaci√≥n necesaria para configurar webhooks en Meta Developer Console
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Callback URL */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Callback URL:</label>
            <div className="flex items-center gap-2">
              <code className="flex-1 p-2 bg-muted rounded text-xs font-mono">
                https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-webhook
              </code>
              <Button
                variant="outline"
                size="sm"
                onClick={() => {
                  navigator.clipboard.writeText("https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-webhook");
                  toast.success("Callback URL copiado");
                }}
              >
                <Copy className="h-4 w-4" />
              </Button>
            </div>
          </div>

          {/* Verify Token */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Verify Token:</label>
            <div className="flex items-center gap-2">
              <code className="flex-1 p-2 bg-muted rounded text-xs font-mono">
                EVA_WEBHOOK_VERIFY_2024
              </code>
              <Button
                variant="outline"
                size="sm"
                onClick={() => {
                  navigator.clipboard.writeText("EVA_WEBHOOK_VERIFY_2024");
                  toast.success("Verify Token copiado");
                }}
              >
                <Copy className="h-4 w-4" />
              </Button>
            </div>
          </div>

          {/* Required Fields */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Campos Requeridos:</label>
            <div className="flex flex-wrap gap-1">
              <Badge variant="outline">mentions</Badge>
              <Badge variant="outline">comments</Badge>
              <Badge variant="outline">messages</Badge>
              <Badge variant="outline">story_insights</Badge>
            </div>
          </div>

          <Button
            onClick={() => window.open('https://developers.facebook.com/apps/', '_blank')}
            className="w-full gap-2"
          >
            <ExternalLink className="h-4 w-4" />
            Abrir Meta Developer Console
          </Button>
        </CardContent>
      </Card>

      {/* Estado de conexi√≥n */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Instagram className="h-5 w-5" />
            Conexi√≥n de Instagram
          </CardTitle>
          <CardDescription>
            Estado actual de la integraci√≥n con Instagram
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <div className="flex items-center gap-2">
                <Badge variant={statusInfo.variant} className="flex items-center gap-1">
                  {statusInfo.icon}
                  {statusInfo.status}
                </Badge>
              </div>
              <p className="text-sm text-muted-foreground">
                {statusInfo.description}
              </p>
            </div>
            
            <div className="flex gap-2">
              {isConnected ? (
                <>
                  {isTokenExpired ? (
                    <Button
                      onClick={refreshToken}
                      disabled={isSyncing}
                      variant="outline"
                      size="sm"
                    >
                      <RefreshCw className={`h-4 w-4 mr-2 ${isSyncing ? 'animate-spin' : ''}`} />
                      Renovar Token
                    </Button>
                  ) : (
                    <Button
                      onClick={() => {
                        syncInstagramData();
                        refreshTokenStatus(); // Refresh status after sync
                      }}
                      disabled={isSyncing}
                      variant="outline"
                      size="sm"
                    >
                      <RefreshCw className={`h-4 w-4 mr-2 ${isSyncing ? 'animate-spin' : ''}`} />
                      Sincronizar
                    </Button>
                  )}
                  
                  <Button
                    onClick={disconnectInstagram}
                    disabled={isConnecting}
                    variant="destructive"
                    size="sm"
                  >
                    Desconectar
                  </Button>
                </>
              ) : (
                <Button
                  onClick={handleConnectClick}
                  disabled={isConnecting}
                  className="flex items-center gap-2"
                >
                  <Instagram className="h-4 w-4" />
                  {isConnecting ? 'Conectando...' : 'Conectar Instagram'}
                </Button>
              )}
            </div>
          </div>

          {isConnected && organization?.last_instagram_sync && (
            <div className="text-sm text-muted-foreground">
              √öltima sincronizaci√≥n: {new Date(organization.last_instagram_sync).toLocaleString('es-ES')}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Instagram Diagnostics Panel */}
      {isConnected && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Activity className="h-5 w-5" />
              Diagn√≥sticos de Instagram
            </CardTitle>
            <CardDescription>
              Verifica el estado de la conexi√≥n y webhooks
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex gap-2">
              <Button
                onClick={runConnectionTests}
                disabled={isRunning}
                variant="outline"
                className="gap-2"
              >
                <Activity className={`h-4 w-4 ${isRunning ? 'animate-spin' : ''}`} />
                {isRunning ? 'Ejecutando Tests...' : 'Ejecutar Tests'}
              </Button>
              
              <Button
                onClick={testWebhookDelivery}
                disabled={isRunning || !isConnected}
                variant="outline"
                className="gap-2"
              >
                <Play className="h-4 w-4" />
                Test Webhook
              </Button>
            </div>

            {/* Test Results */}
            {connectionTests.length > 0 && (
              <div className="space-y-2">
                <h4 className="text-sm font-medium">Resultados de Conexi√≥n:</h4>
                {connectionTests.map((test, index) => (
                  <div key={index} className="flex items-center justify-between p-2 rounded border">
                    <span className="text-sm">{test.name}</span>
                    <div className="flex items-center gap-2">
                      {test.status === 'pending' && (
                        <Badge variant="secondary">Ejecutando...</Badge>
                      )}
                      {test.status === 'success' && (
                        <Badge variant="default" className="bg-green-100 text-green-800 hover:bg-green-100">
                          <CheckCircle className="h-3 w-3 mr-1" />
                          OK
                        </Badge>
                      )}
                      {test.status === 'error' && (
                        <Badge variant="destructive">
                          <AlertCircle className="h-3 w-3 mr-1" />
                          Error
                        </Badge>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Webhook Status */}
            {webhookStatus && (
              <div className="space-y-2">
                <h4 className="text-sm font-medium">Estado del Webhook:</h4>
                <div className="p-3 rounded border bg-muted/50">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm">Configurado:</span>
                    <Badge variant={webhookStatus.configured ? "default" : "destructive"}>
                      {webhookStatus.configured ? "S√≠" : "No"}
                    </Badge>
                  </div>
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm">Alcanzable:</span>
                    <Badge variant={webhookStatus.reachable ? "default" : "secondary"}>
                      {webhookStatus.reachable ? "S√≠" : "Sin eventos recientes"}
                    </Badge>
                  </div>
                  {webhookStatus.lastEvent && (
                    <div className="text-xs text-muted-foreground">
                      √öltimo evento: {new Date(webhookStatus.lastEvent).toLocaleString('es-ES')}
                    </div>
                  )}
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      )}

      {/* Informaci√≥n de la cuenta conectada */}
      {isConnected && (
        <Card>
          <CardHeader>
            <CardTitle>Informaci√≥n de la Cuenta</CardTitle>
            <CardDescription>
              Detalles de la cuenta de Instagram conectada
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              <div className="flex justify-between">
                <span className="text-sm font-medium">Estado del Token:</span>
                <span className="text-sm">
                  {isTokenExpired ? 'Expirado' : 'V√°lido'}
                </span>
              </div>
              <div className="flex justify-between">
                <span className="text-sm font-medium">Usuario:</span>
                <span className="text-sm">
                  {organization?.instagram_username || 'N/A'}
                </span>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Modals */}
      <MetaAppCredentialsForm
        isOpen={showCredentialsForm}
        onClose={handleModalClose}
        onCredentialsSaved={handleModalClose}
      />

      <InstagramConfigGuide
        isOpen={showConfigGuide}
        onClose={() => setShowConfigGuide(false)}
      />
    </div>
  );
}
</file>

<file path="src/components/Settings/MetaAppCredentialsForm.tsx">
import { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { AlertCircle, CheckCircle, Copy, ExternalLink, Eye, EyeOff } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { toast } from "sonner";

interface MetaAppCredentialsFormProps {
  isOpen: boolean;
  onClose: () => void;
  onCredentialsSaved: () => void;
}

export function MetaAppCredentialsForm({ 
  isOpen, 
  onClose, 
  onCredentialsSaved 
}: MetaAppCredentialsFormProps) {
  const { organization } = useCurrentOrganization();
  const [loading, setLoading] = useState(false);
  const [showSecrets, setShowSecrets] = useState(false);
  const [hasCredentials, setHasCredentials] = useState(false);
  const [lastUpdated, setLastUpdated] = useState<string | null>(null);
  
  const [formData, setFormData] = useState({
    metaAppId: "",
    metaAppSecret: "",
    webhookVerifyToken: ""
  });

  // URLs que el usuario necesita para configurar su app
  const redirectUri = `${window.location.origin}/api/meta-oauth?action=callback`;
  const webhookUrl = `https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-webhook`;

  useEffect(() => {
    if (isOpen && organization) {
      checkCredentialsStatus();
    }
  }, [isOpen, organization]);

  const checkCredentialsStatus = async () => {
    if (!organization) return;

    try {
      const { data, error } = await supabase.rpc('get_org_meta_credentials_status', {
        p_organization_id: organization.id
      });

      if (error) {
        console.error('Error checking credentials status:', error);
        return;
      }

      if (data && data.length > 0) {
        setHasCredentials(data[0].has_credentials || false);
        setLastUpdated(data[0].updated_at);
      }
    } catch (error) {
      console.error('Error checking credentials status:', error);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!organization) return;

    // Validaci√≥n b√°sica
    if (!formData.metaAppId.trim() || !formData.metaAppSecret.trim() || !formData.webhookVerifyToken.trim()) {
      toast.error('Todos los campos son obligatorios');
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.rpc('upsert_org_meta_credentials', {
        p_organization_id: organization.id,
        p_meta_app_id: formData.metaAppId.trim(),
        p_meta_app_secret: formData.metaAppSecret.trim(),
        p_webhook_verify_token: formData.webhookVerifyToken.trim()
      });

      if (error) {
        console.error('Error saving credentials:', error);
        toast.error('Error al guardar credenciales: ' + error.message);
        return;
      }

      toast.success('Credenciales de Meta guardadas exitosamente');
      onCredentialsSaved();
    } catch (error) {
      console.error('Error saving credentials:', error);
      toast.error('Error inesperado al guardar credenciales');
    } finally {
      setLoading(false);
    }
  };

  const copyToClipboard = (text: string, label: string) => {
    navigator.clipboard.writeText(text);
    toast.success(`${label} copiado al portapapeles`);
  };

  const generateRandomToken = () => {
    const token = Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2);
    setFormData({ ...formData, webhookVerifyToken: token });
  };

  const handleClose = () => {
    setFormData({
      metaAppId: "",
      metaAppSecret: "",
      webhookVerifyToken: ""
    });
    setShowSecrets(false);
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <svg className="h-5 w-5" viewBox="0 0 24 24" fill="currentColor">
              <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
            </svg>
            Configurar Meta App
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {/* Estado de credenciales */}
          <Card>
            <CardHeader className="pb-3">
              <CardTitle className="text-lg flex items-center gap-2">
                {hasCredentials ? (
                  <CheckCircle className="h-5 w-5 text-green-600" />
                ) : (
                  <AlertCircle className="h-5 w-5 text-orange-500" />
                )}
                Estado de Configuraci√≥n
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                <div>
                  <Badge variant={hasCredentials ? "default" : "secondary"}>
                    {hasCredentials ? "Configurado" : "Pendiente"}
                  </Badge>
                  {lastUpdated && (
                    <p className="text-sm text-muted-foreground mt-1">
                      √öltima actualizaci√≥n: {new Date(lastUpdated).toLocaleDateString()}
                    </p>
                  )}
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => window.open('https://developers.facebook.com/apps/', '_blank')}
                  className="gap-2 w-full sm:w-auto"
                >
                  <ExternalLink className="h-4 w-4" />
                  <span className="truncate">Ir a Meta Developers</span>
                </Button>
              </div>
            </CardContent>
          </Card>

          {/* URLs de configuraci√≥n */}
          <Card>
            <CardHeader>
              <CardTitle>URLs para tu Meta App</CardTitle>
              <CardDescription>
                Usa estas URLs exactas al configurar tu aplicaci√≥n en Meta Developers
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <Label className="text-sm font-medium">Redirect URI (OAuth)</Label>
                <div className="flex flex-col sm:flex-row gap-2 mt-1">
                  <Input value={redirectUri} readOnly className="font-mono text-sm break-all flex-1" />
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => copyToClipboard(redirectUri, "Redirect URI")}
                    className="w-full sm:w-auto shrink-0"
                  >
                    <Copy className="h-4 w-4" />
                  </Button>
                </div>
              </div>

              <div>
                <Label className="text-sm font-medium">Webhook URL</Label>
                <div className="flex flex-col sm:flex-row gap-2 mt-1">
                  <Input value={webhookUrl} readOnly className="font-mono text-sm break-all flex-1" />
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => copyToClipboard(webhookUrl, "Webhook URL")}
                    className="w-full sm:w-auto shrink-0"
                  >
                    <Copy className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Formulario de credenciales */}
          <Card>
            <CardHeader>
              <CardTitle>Credenciales de tu Meta App</CardTitle>
              <CardDescription>
                Ingresa los datos de tu aplicaci√≥n desde Meta Developers
              </CardDescription>
            </CardHeader>
            <CardContent>
              <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                  <Label htmlFor="metaAppId">App ID *</Label>
                  <Input
                    id="metaAppId"
                    value={formData.metaAppId}
                    onChange={(e) => setFormData({ ...formData, metaAppId: e.target.value })}
                    placeholder="123456789012345"
                    required
                  />
                </div>

                <div>
                  <Label htmlFor="metaAppSecret">App Secret *</Label>
                  <div className="relative">
                    <Input
                      id="metaAppSecret"
                      type={showSecrets ? "text" : "password"}
                      value={formData.metaAppSecret}
                      onChange={(e) => setFormData({ ...formData, metaAppSecret: e.target.value })}
                      placeholder="abcdef123456789..."
                      required
                    />
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      className="absolute right-0 top-0 h-full px-3"
                      onClick={() => setShowSecrets(!showSecrets)}
                    >
                      {showSecrets ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                    </Button>
                  </div>
                </div>

                  <div>
                    <Label htmlFor="webhookVerifyToken">Webhook Verify Token *</Label>
                    <div className="flex flex-col sm:flex-row gap-2">
                      <Input
                        id="webhookVerifyToken"
                        type={showSecrets ? "text" : "password"}
                        value={formData.webhookVerifyToken}
                        onChange={(e) => setFormData({ ...formData, webhookVerifyToken: e.target.value })}
                        placeholder="mi_token_secreto_123"
                        required
                        className="flex-1"
                      />
                      <Button
                        type="button"
                        variant="outline"
                        onClick={generateRandomToken}
                        size="sm"
                        className="w-full sm:w-auto shrink-0"
                      >
                        Generar
                      </Button>
                    </div>
                    <p className="text-xs text-muted-foreground mt-1">
                      √ösalo tambi√©n en la configuraci√≥n de Webhooks en Meta
                    </p>
                  </div>

                  <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
                    <Button type="button" variant="outline" onClick={handleClose} className="w-full sm:w-auto">
                      Cancelar
                    </Button>
                    <Button type="submit" disabled={loading} className="w-full sm:w-auto">
                      {loading ? 'Guardando...' : hasCredentials ? 'Actualizar' : 'Guardar'}
                    </Button>
                  </div>
              </form>
            </CardContent>
          </Card>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Settings/N8nConfigurationSection.tsx">
import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Webhook, CheckCircle, AlertTriangle, Settings } from 'lucide-react';
import { useOrganizationSettings } from '@/hooks/useOrganizationSettings';
import { toast } from 'sonner';

export function N8nConfigurationSection() {
  const { settings, updateIntegrationSettings, saving } = useOrganizationSettings();
  const [n8nUrl, setN8nUrl] = useState('');
  const [isTestingConnection, setIsTestingConnection] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<'unknown' | 'success' | 'error'>('unknown');

  useEffect(() => {
    if (settings.integration_settings.n8n_webhook_url) {
      setN8nUrl(settings.integration_settings.n8n_webhook_url);
    }
  }, [settings.integration_settings.n8n_webhook_url]);

  const validateN8nUrl = (url: string): boolean => {
    try {
      const parsedUrl = new URL(url);
      return parsedUrl.protocol === 'https:' && 
             (parsedUrl.hostname.includes('n8n.cloud') || 
              parsedUrl.hostname.includes('rquevedos.app.n8n.cloud'));
    } catch {
      return false;
    }
  };

  const testConnection = async () => {
    if (!n8nUrl) {
      toast.error('Por favor ingresa una URL v√°lida');
      return;
    }

    if (!validateN8nUrl(n8nUrl)) {
      toast.error('URL inv√°lida. Debe ser HTTPS y de un dominio n8n v√°lido');
      return;
    }

    setIsTestingConnection(true);
    try {
      // Test with a simple ping
      const testPayload = {
        test: true,
        message: 'Health check from EVA System',
        timestamp: new Date().toISOString()
      };

      const response = await fetch(`${n8nUrl}/webhook/health-check`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(testPayload),
      });

      if (response.ok) {
        setConnectionStatus('success');
        toast.success('Conexi√≥n exitosa con n8n');
      } else {
        setConnectionStatus('error');
        toast.error('Error de conexi√≥n: ' + response.statusText);
      }
    } catch (error) {
      setConnectionStatus('error');
      toast.error('Error de red: No se pudo conectar con n8n');
    } finally {
      setIsTestingConnection(false);
    }
  };

  const saveConfiguration = async () => {
    if (!n8nUrl) {
      toast.error('Por favor ingresa una URL v√°lida');
      return;
    }

    if (!validateN8nUrl(n8nUrl)) {
      toast.error('URL inv√°lida. Debe ser HTTPS y de un dominio n8n v√°lido');
      return;
    }

    try {
      await updateIntegrationSettings({
        n8n_webhook_url: n8nUrl
      });
      toast.success('Configuraci√≥n guardada exitosamente');
    } catch (error) {
      toast.error('Error al guardar la configuraci√≥n');
    }
  };

  const getStatusBadge = () => {
    if (!settings.integration_settings.n8n_webhook_url) {
      return <Badge variant="secondary">No Configurado</Badge>;
    }
    
    switch (connectionStatus) {
      case 'success':
        return <Badge variant="default" className="bg-green-500">Conectado</Badge>;
      case 'error':
        return <Badge variant="destructive">Error</Badge>;
      default:
        return <Badge variant="outline">Desconocido</Badge>;
    }
  };

  const getStatusIcon = () => {
    if (!settings.integration_settings.n8n_webhook_url) {
      return <Settings className="w-5 h-5 text-muted-foreground" />;
    }
    
    switch (connectionStatus) {
      case 'success':
        return <CheckCircle className="w-5 h-5 text-green-500" />;
      case 'error':
        return <AlertTriangle className="w-5 h-5 text-red-500" />;
      default:
        return <Webhook className="w-5 h-5 text-muted-foreground" />;
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          {getStatusIcon()}
          Configuraci√≥n de n8n
        </CardTitle>
        <CardDescription>
          Configura la URL base de tu instancia de n8n para automatizaci√≥n de workflows
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="flex items-center justify-between">
          <span className="text-sm font-medium">Estado de Conexi√≥n:</span>
          {getStatusBadge()}
        </div>

        <div className="space-y-2">
          <Label htmlFor="n8n-url">URL Base de n8n</Label>
          <Input
            id="n8n-url"
            type="url"
            placeholder="https://rquevedos.app.n8n.cloud"
            value={n8nUrl}
            onChange={(e) => setN8nUrl(e.target.value)}
          />
          <p className="text-xs text-muted-foreground">
            URL base de tu instancia de n8n (ej: https://tu-instancia.n8n.cloud)
          </p>
        </div>

        <div className="flex gap-2">
          <Button 
            variant="outline" 
            onClick={testConnection}
            disabled={isTestingConnection || !n8nUrl}
          >
            {isTestingConnection ? 'Probando...' : 'Probar Conexi√≥n'}
          </Button>
          <Button 
            onClick={saveConfiguration}
            disabled={saving || !n8nUrl || n8nUrl === settings.integration_settings.n8n_webhook_url}
          >
            {saving ? 'Guardando...' : 'Guardar'}
          </Button>
        </div>

        {settings.integration_settings.n8n_webhook_url && (
          <div className="p-4 border rounded-lg bg-muted/50">
            <h4 className="font-medium mb-2">Webhooks Configurados</h4>
            <div className="space-y-2 text-sm text-muted-foreground">
              <div>‚Ä¢ {settings.integration_settings.n8n_webhook_url}/webhook/auth-user-registration</div>
              <div>‚Ä¢ {settings.integration_settings.n8n_webhook_url}/webhook/event-management</div>
              <div>‚Ä¢ {settings.integration_settings.n8n_webhook_url}/webhook/crear-embajador</div>
              <div>‚Ä¢ {settings.integration_settings.n8n_webhook_url}/webhook/ambassador-management</div>
            </div>
          </div>
        )}

        <div className="p-4 border rounded-lg bg-blue-50 dark:bg-blue-950">
          <h4 className="font-medium mb-2 text-blue-800 dark:text-blue-200">Informaci√≥n Importante</h4>
          <ul className="text-sm text-blue-700 dark:text-blue-300 space-y-1">
            <li>‚Ä¢ Todas las llamadas a n8n pasan por el proxy seguro</li>
            <li>‚Ä¢ Se incluye contexto de organizaci√≥n y usuario autom√°ticamente</li>
            <li>‚Ä¢ Los webhooks deben estar configurados en tu instancia de n8n</li>
            <li>‚Ä¢ Se recomienda usar HTTPS para todas las conexiones</li>
          </ul>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Stories/CreateTaskModal.tsx">
import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Plus } from "lucide-react";
import { useTasksManagement } from "@/hooks/useTasksManagement";

interface CreateTaskModalProps {
  ambassadors: Array<{ id: string; name: string; instagram_user: string }>;
  events: Array<{ id: string; name: string; main_hashtag: string }>;
}

export function CreateTaskModal({ ambassadors, events }: CreateTaskModalProps) {
  const { createTask } = useTasksManagement();
  const [open, setOpen] = useState(false);
  const [formData, setFormData] = useState({
    embassador_id: "",
    event_id: "",
    task_type: "story" as "story" | "mention" | "repost",
    expected_hashtag: "",
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    const selectedEvent = events.find(e => e.id === formData.event_id);
    const hashtag = formData.expected_hashtag || selectedEvent?.main_hashtag || "";
    
    const success = await createTask({
      ...formData,
      expected_hashtag: hashtag,
    });

    if (success) {
      setOpen(false);
      setFormData({
        embassador_id: "",
        event_id: "",
        task_type: "story",
        expected_hashtag: "",
      });
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button>
          <Plus className="w-4 h-4 mr-2" />
          Crear Tarea
        </Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Crear Nueva Tarea</DialogTitle>
        </DialogHeader>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="embassador">Embajador</Label>
            <Select value={formData.embassador_id} onValueChange={(value) => setFormData({ ...formData, embassador_id: value })}>
              <SelectTrigger>
                <SelectValue placeholder="Seleccionar embajador" />
              </SelectTrigger>
              <SelectContent>
                {ambassadors.map((ambassador) => (
                  <SelectItem key={ambassador.id} value={ambassador.id}>
                    {ambassador.name} (@{ambassador.instagram_user})
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div>
            <Label htmlFor="event">Evento</Label>
            <Select value={formData.event_id} onValueChange={(value) => setFormData({ ...formData, event_id: value })}>
              <SelectTrigger>
                <SelectValue placeholder="Seleccionar evento" />
              </SelectTrigger>
              <SelectContent>
                {events.map((event) => (
                  <SelectItem key={event.id} value={event.id}>
                    {event.name} {event.main_hashtag && `(#${event.main_hashtag})`}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div>
            <Label htmlFor="task_type">Tipo de Tarea</Label>
            <Select value={formData.task_type} onValueChange={(value: "story" | "mention" | "repost") => setFormData({ ...formData, task_type: value })}>
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="story">Historia</SelectItem>
                <SelectItem value="mention">Menci√≥n</SelectItem>
                <SelectItem value="repost">Repost</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div>
            <Label htmlFor="hashtag">Hashtag Personalizado (opcional)</Label>
            <Input
              id="hashtag"
              placeholder="Dejar vac√≠o para usar hashtag del evento"
              value={formData.expected_hashtag}
              onChange={(e) => setFormData({ ...formData, expected_hashtag: e.target.value })}
            />
          </div>

          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={() => setOpen(false)}>
              Cancelar
            </Button>
            <Button type="submit" disabled={!formData.embassador_id || !formData.event_id}>
              Crear Tarea
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Stories/StoriesManagement.tsx">
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Plus, Filter, Download, Search, Eye, Clock, CheckCircle, XCircle, AlertTriangle } from "lucide-react";
import { TaskStatusBadge } from "./TaskStatusBadge";
import { TaskFilters } from "./TaskFilters";
import { TaskStatsCards } from "./TaskStatsCards";
import { useFiestas } from "@/hooks/useFiestas";
import { useTasksManagement } from "@/hooks/useTasksManagement";
import { FiestaSelector } from "@/components/Fiestas/FiestaSelector";
import { CreateTaskModal } from "./CreateTaskModal";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { PageHeader } from "@/components/Layout/PageHeader";
import { GlassPanel } from "@/components/Layout/GlassPanel";

interface Event {
  id: string;
  name: string;
  main_hashtag: string;
}

interface Ambassador {
  id: string;
  first_name: string;
  last_name: string;
  instagram_user: string;
  global_category: string;
}

export default function StoriesManagement() {
  const { selectedFiesta, selectedFiestaId } = useFiestas();
  const [ambassadors, setAmbassadors] = useState<Ambassador[]>([]);
  const [events, setEvents] = useState<Event[]>([]);
  const [selectedEventId, setSelectedEventId] = useState<string>("all");
  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState("all");
  const [loading, setLoading] = useState(false);
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);

  useEffect(() => {
    if (selectedFiestaId) {
      fetchAmbassadors();
      fetchEvents();
    }
  }, [selectedFiestaId]);

  const fetchAmbassadors = async () => {
    if (!selectedFiestaId) return;

    try {
      setLoading(true);
      // Get organization from fiesta first
      const { data: fiestaData, error: fiestaError } = await supabase
        .from('fiestas')
        .select('organization_id')
        .eq('id', selectedFiestaId)
        .single();

      if (fiestaError) throw fiestaError;

      const { data, error } = await supabase
        .from('embassadors')
        .select('id, first_name, last_name, instagram_user, global_category')
        .eq('organization_id', fiestaData.organization_id)
        .order('first_name', { ascending: true });

      if (error) throw error;
      setAmbassadors(data || []);
    } catch (error) {
      console.error('Error fetching ambassadors:', error);
      toast.error('Error al cargar embajadores');
    } finally {
      setLoading(false);
    }
  };

  const fetchEvents = async () => {
    if (!selectedFiestaId) return;

    try {
      const { data, error } = await supabase
        .from('events')
        .select('id')
        .eq('fiesta_id', selectedFiestaId);

      if (error) throw error;
      
      // Since events no longer have name, we'll use fiesta data
      const { data: fiestaData, error: fiestaError } = await supabase
        .from('fiestas')
        .select('name, main_hashtag')
        .eq('id', selectedFiestaId)
        .single();

      if (fiestaError) throw fiestaError;

      setEvents(data?.map(e => ({
        id: e.id,
        name: fiestaData.name,
        main_hashtag: fiestaData.main_hashtag || ''
      })) || []);
    } catch (error) {
      console.error('Error fetching events:', error);
    }
  };

  const {
    tasks,
    stats,
    loading: tasksLoading,
    refreshTasks,
    updateTaskStatus,
    deleteTask
  } = useTasksManagement();

  const filteredTasks = tasks.filter(task => {
    const matchesSearch = searchTerm === "" || 
      task.embassadors?.first_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      task.embassadors?.last_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      task.embassadors?.instagram_user?.toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesStatus = statusFilter === "all" || task.status === statusFilter;
    
    return matchesSearch && matchesStatus;
  });

  const exportTasks = async () => {
    try {
      toast.success("Funcionalidad de exportaci√≥n en desarrollo");
    } catch (error) {
      toast.error("Error al exportar tareas");
    }
  };

  if (!selectedFiestaId) {
    return (
      <div className="space-y-6">
        <PageHeader 
          title="Historias" 
          description="Gestiona y monitorea las historias de tus embajadores"
        />
        <GlassPanel>
          <div className="text-center text-muted-foreground py-12">
            <AlertTriangle className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>Selecciona una fiesta para gestionar historias</p>
          </div>
        </GlassPanel>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader 
        title="Gesti√≥n de Historias" 
        description={`Gesti√≥n de historias de ${selectedFiesta?.name || 'la fiesta'}`}
      >
        <div className="flex items-center space-x-2 flex-wrap gap-2">
          <Button onClick={() => setIsCreateModalOpen(true)}>
            <Plus className="h-4 w-4 mr-2" />
            Nueva Tarea
          </Button>
          <Button variant="outline" onClick={exportTasks}>
            <Download className="h-4 w-4 mr-2" />
            Exportar
          </Button>
        </div>
      </PageHeader>

                <TaskStatsCards stats={{
                  uploaded: stats.pending,
                  completed: stats.completed,
                  in_progress: stats.pending,
                  invalid: stats.invalid
                }} />

      <div className="grid gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Filtros y B√∫squeda</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-center space-x-4 flex-wrap gap-4">
              <div className="flex-1 min-w-[200px]">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground h-4 w-4" />
                  <Input
                    placeholder="Buscar por embajador..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="pl-10"
                  />
                </div>
              </div>
              
              <Select value={selectedEventId} onValueChange={setSelectedEventId}>
                <SelectTrigger className="w-[200px]">
                  <SelectValue placeholder="Todos los eventos" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Todos los eventos</SelectItem>
                  {events.map((event) => (
                    <SelectItem key={event.id} value={event.id}>
                      {event.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>

              <Select value={statusFilter} onValueChange={setStatusFilter}>
                <SelectTrigger className="w-[150px]">
                  <SelectValue placeholder="Estado" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Todos</SelectItem>
                  <SelectItem value="pending">Pendiente</SelectItem>
                  <SelectItem value="uploaded">Subida</SelectItem>
                  <SelectItem value="in_progress">En Progreso</SelectItem>
                  <SelectItem value="completed">Completada</SelectItem>
                  <SelectItem value="invalid">Inv√°lida</SelectItem>
                  <SelectItem value="expired">Expirada</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </CardContent>
        </Card>

        <Tabs defaultValue="all" className="space-y-4">
          <TabsList>
            <TabsTrigger value="all">Todas las Tareas</TabsTrigger>
            <TabsTrigger value="pending">Pendientes</TabsTrigger>
            <TabsTrigger value="completed">Completadas</TabsTrigger>
            <TabsTrigger value="invalid">Problem√°ticas</TabsTrigger>
          </TabsList>

          <TabsContent value="all">
            <Card>
              <CardHeader>
                <CardTitle>Lista de Tareas</CardTitle>
              </CardHeader>
              <CardContent>
                {tasksLoading ? (
                  <div className="space-y-4">
                    {[...Array(5)].map((_, i) => (
                      <div key={i} className="h-20 bg-muted animate-pulse rounded-lg" />
                    ))}
                  </div>
                ) : filteredTasks.length === 0 ? (
                  <div className="text-center py-8 text-muted-foreground">
                    <Clock className="h-8 w-8 mx-auto mb-2 opacity-50" />
                    <p>No hay tareas que coincidan con los filtros</p>
                  </div>
                ) : (
                  <div className="space-y-4">
                    {filteredTasks.map((task) => (
                      <div key={task.id} className="border rounded-lg p-4 hover:bg-accent/50 transition-colors">
                        <div className="flex items-center justify-between">
                          <div className="flex-1">
                            <div className="flex items-center space-x-3">
                              <div>
                                <h4 className="font-medium">
                                  {task.embassadors ? 
                                    `${task.embassadors.first_name} ${task.embassadors.last_name}` : 
                                    'Embajador no encontrado'
                                  }
                                </h4>
                                <p className="text-sm text-muted-foreground">
                                  @{task.embassadors?.instagram_user || 'usuario_no_encontrado'}
                                </p>
                              </div>
                              <Badge variant="outline" className="text-xs">
                                {task.task_type}
                              </Badge>
                              <TaskStatusBadge status={task.status} />
                            </div>
                            <div className="mt-2 text-sm text-muted-foreground">
                              {task.expected_hashtag && (
                                <span className="mr-4">Hashtag: {task.expected_hashtag}</span>
                              )}
                              {task.upload_time && (
                                <span>Subida: {new Date(task.upload_time).toLocaleDateString()}</span>
                              )}
                            </div>
                          </div>
                          <div className="flex items-center space-x-2">
                            <div className="text-right text-sm">
                              <div className="font-medium">{task.points_earned} pts</div>
                              <div className="text-muted-foreground">
                                {task.reach_count.toLocaleString()} alcance
                              </div>
                            </div>
                            <Button variant="outline" size="sm">
                              <Eye className="h-4 w-4" />
                            </Button>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="pending">
            <Card>
              <CardContent className="p-6">
                <div className="text-center text-muted-foreground">
                  <Clock className="h-8 w-8 mx-auto mb-2 opacity-50" />
                  <p>Tareas pendientes aparecer√°n aqu√≠</p>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="completed">
            <Card>
              <CardContent className="p-6">
                <div className="text-center text-muted-foreground">
                  <CheckCircle className="h-8 w-8 mx-auto mb-2 opacity-50" />
                  <p>Tareas completadas aparecer√°n aqu√≠</p>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="invalid">
            <Card>
              <CardContent className="p-6">
                <div className="text-center text-muted-foreground">
                  <XCircle className="h-8 w-8 mx-auto mb-2 opacity-50" />
                  <p>Tareas problem√°ticas aparecer√°n aqu√≠</p>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>
      </div>

      <CreateTaskModal
        ambassadors={ambassadors.map(amb => ({
          id: amb.id,
          name: `${amb.first_name} ${amb.last_name}`,
          instagram_user: amb.instagram_user
        }))}
        events={events}
      />
    </div>
  );
}
</file>

<file path="src/components/Stories/TaskFilters.tsx">
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Search } from "lucide-react";

interface TaskFiltersProps {
  searchTerm: string;
  onSearchChange: (value: string) => void;
  statusFilter: string;
  onStatusFilterChange: (value: string) => void;
  eventFilter: string;
  onEventFilterChange: (value: string) => void;
  events: Array<{ id: string; name: string }>;
}

export function TaskFilters({
  searchTerm,
  onSearchChange,
  statusFilter,
  onStatusFilterChange,
  eventFilter,
  onEventFilterChange,
  events
}: TaskFiltersProps) {
  return (
    <div className="flex gap-4 items-center">
      <div className="relative flex-1">
        <Search className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder="Buscar por embajador..."
          value={searchTerm}
          onChange={(e) => onSearchChange(e.target.value)}
          className="pl-10"
        />
      </div>
      
      <Select value={statusFilter} onValueChange={onStatusFilterChange}>
        <SelectTrigger className="w-48">
          <SelectValue placeholder="Filtrar por estado" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">Todos los estados</SelectItem>
          <SelectItem value="pending">Pendientes</SelectItem>
          <SelectItem value="uploaded">Subidas</SelectItem>
          <SelectItem value="in_progress">En Progreso</SelectItem>
          <SelectItem value="completed">Completadas</SelectItem>
          <SelectItem value="invalid">Inv√°lidas</SelectItem>
          <SelectItem value="expired">Expiradas</SelectItem>
        </SelectContent>
      </Select>

      <Select value={eventFilter} onValueChange={onEventFilterChange}>
        <SelectTrigger className="w-48">
          <SelectValue placeholder="Filtrar por evento" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">Todos los eventos</SelectItem>
          {events.map((event) => (
            <SelectItem key={event.id} value={event.id}>
              {event.name}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
}
</file>

<file path="src/components/Stories/TaskStatsCards.tsx">
import { Card, CardContent } from "@/components/ui/card";
import { Clock, CheckCircle, AlertTriangle, XCircle } from "lucide-react";

interface TaskStatsCardsProps {
  stats: {
    uploaded: number;
    completed: number;
    in_progress: number;
    invalid: number;
  };
}

export function TaskStatsCards({ stats }: TaskStatsCardsProps) {
  return (
    <div className="grid grid-cols-4 gap-4">
      <Card>
        <CardContent className="p-4">
          <div className="flex items-center space-x-2">
            <Clock className="w-5 h-5 text-blue-600" />
            <div>
              <div className="text-2xl font-bold text-blue-600">{stats.uploaded}</div>
              <p className="text-sm text-muted-foreground">Historias Subidas</p>
            </div>
          </div>
        </CardContent>
      </Card>
      
      <Card>
        <CardContent className="p-4">
          <div className="flex items-center space-x-2">
            <CheckCircle className="w-5 h-5 text-green-600" />
            <div>
              <div className="text-2xl font-bold text-green-600">{stats.completed}</div>
              <p className="text-sm text-muted-foreground">Completadas</p>
            </div>
          </div>
        </CardContent>
      </Card>
      
      <Card>
        <CardContent className="p-4">
          <div className="flex items-center space-x-2">
            <AlertTriangle className="w-5 h-5 text-orange-600" />
            <div>
              <div className="text-2xl font-bold text-orange-600">{stats.in_progress}</div>
              <p className="text-sm text-muted-foreground">En Progreso</p>
            </div>
          </div>
        </CardContent>
      </Card>
      
      <Card>
        <CardContent className="p-4">
          <div className="flex items-center space-x-2">
            <XCircle className="w-5 h-5 text-red-600" />
            <div>
              <div className="text-2xl font-bold text-red-600">{stats.invalid}</div>
              <p className="text-sm text-muted-foreground">Inv√°lidas</p>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/Stories/TaskStatusBadge.tsx">
import { Badge } from "@/components/ui/badge";
import { Clock, CheckCircle, XCircle, AlertTriangle, RotateCcw } from "lucide-react";

interface TaskStatusBadgeProps {
  status: 'pending' | 'uploaded' | 'in_progress' | 'completed' | 'invalid' | 'expired';
}

export function TaskStatusBadge({ status }: TaskStatusBadgeProps) {
  const statusConfig = {
    pending: { 
      variant: "outline" as const, 
      icon: Clock, 
      label: "Pendiente",
      className: "text-gray-600 border-gray-300"
    },
    uploaded: { 
      variant: "secondary" as const, 
      icon: Clock, 
      label: "Subida",
      className: "text-blue-600 bg-blue-50 border-blue-200"
    },
    in_progress: { 
      variant: "default" as const, 
      icon: RotateCcw, 
      label: "En Progreso",
      className: "text-orange-600 bg-orange-50 border-orange-200"
    },
    completed: { 
      variant: "default" as const, 
      icon: CheckCircle, 
      label: "Completada",
      className: "text-green-600 bg-green-50 border-green-200"
    },
    invalid: { 
      variant: "destructive" as const, 
      icon: XCircle, 
      label: "Inv√°lida",
      className: "text-red-600 bg-red-50 border-red-200"
    },
    expired: { 
      variant: "destructive" as const, 
      icon: AlertTriangle, 
      label: "Expirada",
      className: "text-red-600 bg-red-50 border-red-200"
    },
  };

  const config = statusConfig[status];
  const Icon = config.icon;

  return (
    <Badge variant={config.variant} className={`flex items-center gap-1 ${config.className}`}>
      <Icon className="w-3 h-3" />
      {config.label}
    </Badge>
  );
}
</file>

<file path="src/components/StoryMentions/StoryMentionDetails.tsx">
import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { MessageCircle, ExternalLink, Instagram, Calendar, User, Hash, AlertTriangle, CheckCircle, Clock } from "lucide-react";
import { formatDistanceToNow, format } from "date-fns";
import { es } from "date-fns/locale";
import { useToast } from "@/hooks/use-toast";
import { StoryMention } from "@/types/storyMentions";

interface StoryMentionDetailsProps {
  mention: StoryMention | null;
  open: boolean;
  onClose: () => void;
  onMarkAsProcessed: (mentionId: string) => void;
  onFlagAsEarlyDelete: (mentionId: string) => void;
  onReply: (mention: StoryMention, message: string) => Promise<void>;
  onCreateLead: (mention: StoryMention) => void;
}

export function StoryMentionDetails({
  mention,
  open,
  onClose,
  onMarkAsProcessed,
  onFlagAsEarlyDelete,
  onReply,
  onCreateLead
}: StoryMentionDetailsProps) {
  const [replyMessage, setReplyMessage] = useState("");
  const [sending, setSending] = useState(false);
  const { toast } = useToast();

  const handleSendReply = async () => {
    if (!mention || !replyMessage.trim()) return;

    try {
      setSending(true);
      await onReply(mention, replyMessage.trim());
      setReplyMessage("");
      toast({
        title: "Respuesta enviada",
        description: "Tu mensaje ha sido enviado correctamente"
      });
    } catch (error) {
      toast({
        title: "Error al enviar",
        description: "No se pudo enviar la respuesta",
        variant: "destructive"
      });
    } finally {
      setSending(false);
    }
  };

  const handleViewStory = () => {
    if (mention?.deep_link) {
      window.open(mention.deep_link, '_blank', 'noopener,noreferrer');
    } else if (mention?.story_url) {
      window.open(mention.story_url, '_blank', 'noopener,noreferrer');
    } else if (mention?.instagram_username) {
      window.open(`https://instagram.com/${mention.instagram_username}`, '_blank', 'noopener,noreferrer');
    }
  };

  const getStateBadge = (state: StoryMention['state']) => {
    switch (state) {
      case 'new':
        return (
          <Badge variant="default" className="flex items-center gap-1">
            <Clock className="w-3 h-3" />
            Nueva
          </Badge>
        );
      case 'completed':
        return (
          <Badge variant="secondary" className="flex items-center gap-1">
            <CheckCircle className="w-3 h-3" />
            Completada (24h)
          </Badge>
        );
      case 'flagged_early_delete':
        return (
          <Badge variant="destructive" className="flex items-center gap-1">
            <AlertTriangle className="w-3 h-3" />
            Borrada antes de 24h
          </Badge>
        );
      case 'expired_unknown':
        return (
          <Badge variant="outline" className="flex items-center gap-1">
            <AlertTriangle className="w-3 h-3" />
            Estado desconocido
          </Badge>
        );
      default:
        return <Badge variant="outline">{state}</Badge>;
    }
  };

  const getTimeRemaining = () => {
    if (!mention?.expires_at) return null;
    
    const now = new Date();
    const expires = new Date(mention.expires_at);
    
    if (now > expires) {
      return "Historia expirada";
    }
    
    const diffMs = expires.getTime() - now.getTime();
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffMinutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    
    if (diffHours > 0) {
      return `${diffHours}h ${diffMinutes}m restantes`;
    } else {
      return `${diffMinutes}m restantes`;
    }
  };

  if (!mention) return null;

  const isNew = mention.state === 'new';
  const timeRemaining = getTimeRemaining();

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Instagram className="w-5 h-5 text-pink-600" />
            Menci√≥n de Historia - @{mention.instagram_username}
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {/* Status and Info */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              {getStateBadge(mention.state)}
              {mention.ambassador_name && (
                <Badge variant="outline">
                  Embajador: {mention.ambassador_name}
                </Badge>
              )}
            </div>
            <span className="text-sm text-muted-foreground flex items-center gap-1">
              <Calendar className="w-4 h-4" />
              {format(new Date(mention.mentioned_at), "dd MMM yyyy 'a las' HH:mm", { locale: es })}
            </span>
          </div>

          {/* Time remaining */}
          {timeRemaining && isNew && (
            <div className="p-3 bg-primary/10 rounded-lg border border-primary/20">
              <div className="flex items-center gap-2 text-primary">
                <Clock className="w-4 h-4" />
                <span className="font-medium">{timeRemaining}</span>
              </div>
              <p className="text-xs text-muted-foreground mt-1">
                Las historias de Instagram duran 24 horas
              </p>
            </div>
          )}

          {/* User Info */}
          <div className="grid grid-cols-2 gap-4 p-4 bg-muted/50 rounded-lg">
            <div className="flex items-center gap-2">
              <User className="w-4 h-4 text-muted-foreground" />
              <span className="font-medium">@{mention.instagram_username}</span>
            </div>
            {mention.instagram_user_id && (
              <div className="flex items-center gap-2">
                <Hash className="w-4 h-4 text-muted-foreground" />
                <span className="text-sm text-muted-foreground">ID: {mention.instagram_user_id}</span>
              </div>
            )}
          </div>

          {/* Content */}
          <div>
            <h3 className="font-semibold mb-2">Contenido del mensaje:</h3>
            <p className="text-muted-foreground p-3 bg-muted/30 rounded-lg">
              {mention.content}
            </p>
          </div>

          {/* Action Buttons */}
          <div className="flex flex-wrap gap-2">
            <Button
              variant="outline"
              onClick={handleViewStory}
              className="flex items-center gap-2"
            >
              <ExternalLink className="w-4 h-4" />
              {mention.deep_link ? "Ver historia" : "Ver perfil"}
            </Button>

            {mention.inbox_link && (
              <Button
                variant="outline"
                onClick={() => window.open(mention.inbox_link, '_blank', 'noopener,noreferrer')}
                className="flex items-center gap-2"
              >
                <MessageCircle className="w-4 h-4" />
                Abrir en Bandeja
              </Button>
            )}

            {!mention.ambassador_name && (
              <Button
                variant="outline"
                onClick={() => onCreateLead(mention)}
              >
                Crear lead en CRM
              </Button>
            )}

            {isNew && (
              <>
                <Button
                  variant="secondary"
                  onClick={() => onMarkAsProcessed(mention.id)}
                >
                  Marcar como procesada
                </Button>
                
                <Button
                  variant="destructive"
                  onClick={() => onFlagAsEarlyDelete(mention.id)}
                  className="flex items-center gap-2"
                >
                  <AlertTriangle className="w-4 h-4" />
                  Borrada antes de 24h
                </Button>
              </>
            )}
          </div>

          <Separator />

          {/* Reply Section */}
          <div className="space-y-4">
            <h3 className="font-semibold flex items-center gap-2">
              <MessageCircle className="w-4 h-4" />
              Responder por mensaje directo
            </h3>
            
            <Textarea
              placeholder="Escribe tu respuesta aqu√≠..."
              value={replyMessage}
              onChange={(e) => setReplyMessage(e.target.value)}
              rows={4}
              className="resize-none"
            />
            
            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={onClose}>
                Cancelar
              </Button>
              <Button 
                onClick={handleSendReply}
                disabled={!replyMessage.trim() || sending}
              >
                {sending ? "Enviando..." : "Enviar respuesta"}
              </Button>
            </div>
          </div>

          {/* Deep link info */}
          {mention.deep_link && !mention.deep_link.includes('instagram.com') && (
            <div className="p-3 bg-muted/30 rounded-lg">
              <p className="text-sm text-muted-foreground">
                <strong>Nota:</strong> El enlace directo a la historia puede no funcionar en todos los navegadores. 
                Si no funciona, se abrir√° el perfil del usuario.
              </p>
            </div>
          )}

          {/* Raw Data (for debugging) */}
          {mention.raw_data && (
            <details className="mt-4">
              <summary className="cursor-pointer text-sm text-muted-foreground">
                Ver datos t√©cnicos
              </summary>
              <pre className="mt-2 p-3 bg-muted/30 rounded-lg text-xs overflow-x-auto">
                {JSON.stringify(mention.raw_data, null, 2)}
              </pre>
            </details>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/StoryMentions/StoryMentionsList.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { MessageCircle, Eye, UserPlus, ExternalLink, Instagram, AlertTriangle, CheckCircle } from "lucide-react";
import { formatDistanceToNow, format } from "date-fns";
import { es } from "date-fns/locale";
import { StoryMention } from "@/types/storyMentions";

interface StoryMentionsListProps {
  mentions: StoryMention[];
  loading: boolean;
  onViewDetails: (mention: StoryMention) => void;
  onMarkAsProcessed: (mentionId: string) => void;
  onFlagAsEarlyDelete: (mentionId: string) => void;
  onReply: (mention: StoryMention) => void;
  onCreateLead: (mention: StoryMention) => void;
}

export function StoryMentionsList({
  mentions,
  loading,
  onViewDetails,
  onMarkAsProcessed,
  onFlagAsEarlyDelete,
  onReply,
  onCreateLead
}: StoryMentionsListProps) {
  const handleViewStory = (mention: StoryMention) => {
    // Priority order: story_url > deep_link > profile fallback
    if (mention.story_url) {
      window.open(mention.story_url, '_blank', 'noopener,noreferrer');
    } else if (mention.deep_link) {
      window.open(mention.deep_link, '_blank', 'noopener,noreferrer');
    } else {
      // Fallback to Instagram profile
      window.open(`https://instagram.com/${mention.instagram_username}`, '_blank', 'noopener,noreferrer');
    }
  };

  const getStateBadge = (state: StoryMention['state'], expiresAt?: string, checksCount?: number) => {
    const now = new Date();
    const expires = expiresAt ? new Date(expiresAt) : null;
    const isExpired = expires && now > expires;
    const checksInfo = checksCount ? ` (${checksCount}/3)` : '';

    switch (state) {
      case 'new':
        return (
          <Badge variant={isExpired ? "secondary" : "default"} className="flex items-center gap-1">
            {isExpired ? <CheckCircle className="w-3 h-3" /> : null}
            {isExpired ? `Expirada${checksInfo}` : `Nueva${checksInfo}`}
          </Badge>
        );
      case 'completed':
        return (
          <Badge variant="secondary" className="flex items-center gap-1">
            <CheckCircle className="w-3 h-3" />
            Completada (24h)
            {checksCount && <span className="ml-1 text-xs">({checksCount} verificaciones)</span>}
          </Badge>
        );
      case 'flagged_early_delete':
        return (
          <Badge variant="destructive" className="flex items-center gap-1">
            <AlertTriangle className="w-3 h-3" />
            Borrada temprano
            {checksCount && <span className="ml-1 text-xs">({checksCount} verificaciones)</span>}
          </Badge>
        );
      case 'expired_unknown':
        return (
          <Badge variant="outline" className="flex items-center gap-1">
            <AlertTriangle className="w-3 h-3" />
            No verificable
            {checksCount && <span className="ml-1 text-xs">({checksCount} intentos)</span>}
          </Badge>
        );
      default:
        return <Badge variant="outline">{state}</Badge>;
    }
  };

  const getTimeRemaining = (expiresAt?: string) => {
    if (!expiresAt) return null;
    
    const now = new Date();
    const expires = new Date(expiresAt);
    
    if (now > expires) {
      return "Expirada";
    }
    
    const diffMs = expires.getTime() - now.getTime();
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffMinutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    
    if (diffHours > 0) {
      return `${diffHours}h ${diffMinutes}m restantes`;
    } else {
      return `${diffMinutes}m restantes`;
    }
  };

  if (loading) {
    return (
      <div className="grid gap-4">
        {[...Array(3)].map((_, i) => (
          <Card key={i}>
            <CardHeader>
              <div className="flex items-center justify-between">
                <Skeleton className="h-6 w-40" />
                <Skeleton className="h-5 w-20" />
              </div>
            </CardHeader>
            <CardContent>
              <Skeleton className="h-4 w-full mb-2" />
              <Skeleton className="h-4 w-3/4" />
            </CardContent>
          </Card>
        ))}
      </div>
    );
  }

  if (mentions.length === 0) {
    return (
      <Card>
        <CardContent className="pt-6">
          <div className="text-center text-muted-foreground">
            <MessageCircle className="w-12 h-12 mx-auto mb-4 opacity-50" />
            <p className="text-lg font-medium mb-2">No hay menciones de historias</p>
            <p>Las menciones aparecer√°n aqu√≠ cuando alguien interact√∫e con tus historias</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="grid gap-4">
      {mentions.map((mention) => {
        const isNew = mention.state === 'new';
        const timeRemaining = getTimeRemaining(mention.expires_at);
        
        return (
          <Card key={mention.id} className={`${isNew ? 'border-primary/50 bg-primary/5' : ''}`}>
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="text-lg flex items-center gap-2">
                  <Instagram className="w-5 h-5 text-pink-600" />
                  @{mention.instagram_username}
                  {mention.ambassador_name && (
                    <Badge variant="secondary" className="ml-2">
                      {mention.ambassador_name}
                    </Badge>
                  )}
                </CardTitle>
                <div className="flex items-center gap-2">
                  {getStateBadge(mention.state, mention.expires_at, mention.checks_count)}
                  <span className="text-sm text-muted-foreground">
                    {formatDistanceToNow(new Date(mention.mentioned_at), { 
                      addSuffix: true, 
                      locale: es 
                    })}
                  </span>
                </div>
              </div>
              {timeRemaining && mention.state === 'new' && (
                <div className="text-sm text-muted-foreground">
                  ‚è±Ô∏è {timeRemaining}
                </div>
              )}
            </CardHeader>
            <CardContent>
              <p className="text-muted-foreground mb-4 line-clamp-2">
                {mention.content}
              </p>
              
              <div className="flex flex-wrap items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => onViewDetails(mention)}
                  className="flex items-center gap-2"
                >
                  <Eye className="w-4 h-4" />
                  Ver detalles
                </Button>
                
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => onReply(mention)}
                  className="flex items-center gap-2"
                >
                  <MessageCircle className="w-4 h-4" />
                  Responder
                </Button>

                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handleViewStory(mention)}
                  className="flex items-center gap-2"
                  title={mention.story_url ? 'Abrir enlace directo a la historia' : mention.deep_link ? 'Abrir enlace de respaldo' : 'Ver perfil de Instagram'}
                >
                  <ExternalLink className="w-4 h-4" />
                  {mention.story_url ? 'Ver historia' : mention.deep_link ? 'Ver historia (respaldo)' : 'Ver perfil'}
                </Button>

                {!mention.ambassador_name && (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => onCreateLead(mention)}
                    className="flex items-center gap-2"
                  >
                    <UserPlus className="w-4 h-4" />
                    Crear lead
                  </Button>
                )}

                {isNew && (
                  <>
                    <Button
                      variant="secondary"
                      size="sm"
                      onClick={() => onMarkAsProcessed(mention.id)}
                    >
                      Marcar como procesada
                    </Button>
                    
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => onFlagAsEarlyDelete(mention.id)}
                      className="flex items-center gap-2"
                    >
                      <AlertTriangle className="w-4 h-4" />
                      Borrada antes de 24h
                    </Button>
                  </>
                )}
              </div>
            </CardContent>
          </Card>
        );
      })}
    </div>
  );
}
</file>

<file path="src/components/System/SystemHealthDashboard.tsx">
import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { AlertTriangle, CheckCircle, Clock, RefreshCw, Activity, Database, Zap } from 'lucide-react';
import { useInstagramConnection } from '@/hooks/useInstagramConnection';
import { useCurrentOrganization } from '@/hooks/useCurrentOrganization';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';

interface HealthCheck {
  id: string;
  name: string;
  status: 'healthy' | 'warning' | 'error';
  message: string;
  lastChecked: Date;
  details?: string;
}

interface SystemError {
  timestamp: Date;
  component: string;
  error: string;
  level: 'info' | 'warn' | 'error';
}

export function SystemHealthDashboard() {
  const { isConnected, isTokenExpired, lastSync } = useInstagramConnection();
  const { organization } = useCurrentOrganization();
  const [healthChecks, setHealthChecks] = useState<HealthCheck[]>([]);
  const [systemErrors, setSystemErrors] = useState<SystemError[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    runHealthChecks();
    loadSystemErrors();
    // Refresh every 30 seconds
    const interval = setInterval(runHealthChecks, 30000);
    return () => clearInterval(interval);
  }, [organization?.id]);

  const runHealthChecks = async () => {
    const checks: HealthCheck[] = [];
    
    // Instagram Connection Check
    const instagramCheck: HealthCheck = {
      id: 'instagram',
      name: 'Instagram Connection',
      status: !isConnected ? 'error' : isTokenExpired ? 'warning' : 'healthy',
      message: !isConnected ? 'Desconectado' : isTokenExpired ? 'Token expirado' : 'Conectado correctamente',
      lastChecked: new Date(),
      details: isConnected ? 'Cuenta conectada' : undefined
    };
    checks.push(instagramCheck);

    // Database Connection Check
    try {
      const { error } = await supabase.from('organizations').select('id').limit(1);
      checks.push({
        id: 'database',
        name: 'Database Connection', 
        status: error ? 'error' : 'healthy',
        message: error ? 'Error de conexi√≥n' : 'Conexi√≥n establecida',
        lastChecked: new Date(),
        details: error?.message
      });
    } catch (err) {
      checks.push({
        id: 'database',
        name: 'Database Connection',
        status: 'error',
        message: 'Error de conexi√≥n',
        lastChecked: new Date(),
        details: 'No se pudo conectar a la base de datos'
      });
    }

    // N8N Configuration Check
    try {
      const { data: settings } = await supabase
        .from('organization_settings')
        .select('integration_settings')
        .eq('organization_id', organization?.id)
        .single();
      
      // Type-safe access to n8n_webhook_url
      const integrationSettings = settings?.integration_settings as any;
      const n8nUrl = integrationSettings?.n8n_webhook_url;
      checks.push({
        id: 'n8n',
        name: 'N8N Configuration',
        status: n8nUrl ? 'healthy' : 'warning',
        message: n8nUrl ? 'URL configurada' : 'URL no configurada',
        lastChecked: new Date(),
        details: n8nUrl ? 'Configuraci√≥n activa' : 'Configure la URL en Configuraciones'
      });
    } catch (err) {
      checks.push({
        id: 'n8n',
        name: 'N8N Configuration',
        status: 'error',
        message: 'Error al verificar configuraci√≥n',
        lastChecked: new Date()
      });
    }

    // Token Expiry Check - simplified without tokenStatus
    if (isConnected) {
      // For now, we'll show a general check - can be enhanced later
      checks.push({
        id: 'token_expiry',
        name: 'Token Expiry',
        status: isTokenExpired ? 'warning' : 'healthy',
        message: isTokenExpired ? 'Token expirado - renovar requerido' : 'Token v√°lido',
        lastChecked: new Date(),
        details: isTokenExpired ? 'Renueva el token en la configuraci√≥n de Instagram' : 'Token funcionando correctamente'
      });
    }

    setHealthChecks(checks);
    setIsLoading(false);
  };

  const loadSystemErrors = async () => {
    try {
      // Load recent notifications as proxy for system errors
      const { data, error } = await supabase
        .from('notifications')
        .select('*')
        .eq('organization_id', organization?.id)
        .in('type', ['error', 'warning', 'token_expiry_warning'])
        .order('created_at', { ascending: false })
        .limit(10);

      if (!error && data) {
        const errors: SystemError[] = data.map(notification => ({
          timestamp: new Date(notification.created_at),
          component: notification.type,
          error: notification.message,
          level: notification.priority === 'high' ? 'error' : notification.priority === 'medium' ? 'warn' : 'info'
        }));
        setSystemErrors(errors);
      }
    } catch (err) {
      console.error('Error loading system errors:', err);
    }
  };

  const getStatusIcon = (status: HealthCheck['status']) => {
    switch (status) {
      case 'healthy': return <CheckCircle className="w-4 h-4 text-green-500" />;
      case 'warning': return <AlertTriangle className="w-4 h-4 text-yellow-500" />;
      case 'error': return <AlertTriangle className="w-4 h-4 text-red-500" />;
    }
  };

  const getStatusColor = (status: HealthCheck['status']) => {
    switch (status) {
      case 'healthy': return 'default';
      case 'warning': return 'warning';
      case 'error': return 'destructive';
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold flex items-center gap-2">
            <Activity className="w-6 h-6" />
            System Health
          </h2>
          <p className="text-muted-foreground">
            Estado en tiempo real de los componentes del sistema
          </p>
        </div>
        <Button 
          variant="outline" 
          size="sm" 
          onClick={runHealthChecks}
          disabled={isLoading}
        >
          <RefreshCw className={`w-4 h-4 ${isLoading ? 'animate-spin' : ''}`} />
          Actualizar
        </Button>
      </div>

      {/* System Overview */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium">Estado General</p>
                <p className="text-2xl font-bold">
                  {healthChecks.filter(c => c.status === 'healthy').length}/{healthChecks.length}
                </p>
              </div>
              <CheckCircle className="w-8 h-8 text-green-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium">Advertencias</p>
                <p className="text-2xl font-bold text-yellow-500">
                  {healthChecks.filter(c => c.status === 'warning').length}
                </p>
              </div>
              <AlertTriangle className="w-8 h-8 text-yellow-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium">Errores</p>
                <p className="text-2xl font-bold text-red-500">
                  {healthChecks.filter(c => c.status === 'error').length}
                </p>
              </div>
              <AlertTriangle className="w-8 h-8 text-red-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium">√öltima Verificaci√≥n</p>
                <p className="text-sm text-muted-foreground">
                  {new Date().toLocaleTimeString()}
                </p>
              </div>
              <Clock className="w-8 h-8 text-muted-foreground" />
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Health Checks */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Database className="w-5 h-5" />
            Verificaciones de Salud
          </CardTitle>
          <CardDescription>
            Estado detallado de todos los componentes del sistema
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {healthChecks.map((check) => (
              <div key={check.id} className="flex items-center justify-between p-4 border rounded-lg">
                <div className="flex items-center gap-3">
                  {getStatusIcon(check.status)}
                  <div>
                    <h4 className="font-medium">{check.name}</h4>
                    <p className="text-sm text-muted-foreground">{check.message}</p>
                    {check.details && (
                      <p className="text-xs text-muted-foreground mt-1">{check.details}</p>
                    )}
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  <Badge variant={getStatusColor(check.status)}>
                    {check.status === 'healthy' ? 'Saludable' : 
                     check.status === 'warning' ? 'Advertencia' : 'Error'}
                  </Badge>
                  <p className="text-xs text-muted-foreground">
                    {check.lastChecked.toLocaleTimeString()}
                  </p>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* Recent Errors */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Zap className="w-5 h-5" />
            Errores Recientes
          </CardTitle>
          <CardDescription>
            √öltimos errores y advertencias del sistema
          </CardDescription>
        </CardHeader>
        <CardContent>
          {systemErrors.length > 0 ? (
            <div className="space-y-2">
              {systemErrors.map((error, index) => (
                <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
                  <div className="flex items-center gap-3">
                    <div className={`w-2 h-2 rounded-full ${
                      error.level === 'error' ? 'bg-red-500' :
                      error.level === 'warn' ? 'bg-yellow-500' : 'bg-blue-500'
                    }`} />
                    <div>
                      <p className="text-sm font-medium">{error.component}</p>
                      <p className="text-xs text-muted-foreground">{error.error}</p>
                    </div>
                  </div>
                  <p className="text-xs text-muted-foreground">
                    {error.timestamp.toLocaleString()}
                  </p>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-8 text-muted-foreground">
              <CheckCircle className="w-12 h-12 mx-auto mb-4 opacity-50" />
              <p>No hay errores recientes</p>
              <p className="text-sm">El sistema est√° funcionando correctamente</p>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="src/components/ui/alert-dialog.tsx">
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/aspect-ratio.tsx">
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }
</file>

<file path="src/components/ui/avatar.tsx">
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-gradient-primary text-primary-foreground hover:shadow-glow",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground border-border",
        success:
          "border-transparent bg-success text-success-foreground hover:bg-success/80",
        warning:
          "border-transparent bg-warning text-warning-foreground hover:bg-warning/80",
        info:
          "border-transparent bg-info text-info-foreground hover:bg-info/80",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src/components/ui/breadcrumb.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:size-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-gradient-primary text-primary-foreground hover:shadow-glow transition-shadow",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground hover:border-primary/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        hero: "bg-white/10 text-white border border-white/20 hover:bg-white/20 backdrop-blur-sm",
        gradient: "ig-gradient-btn text-white font-medium shadow-md hover:shadow-lg",
        subtle: "bg-secondary/50 text-secondary-foreground border border-border hover:bg-secondary/80 transition-colors",
        success: "bg-success text-success-foreground hover:bg-success/90",
        warning: "bg-warning text-warning-foreground hover:bg-warning/90",
        info: "bg-info text-info-foreground hover:bg-info/90",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="src/components/ui/calendar.tsx">
import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ..._props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ..._props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";

export { Calendar };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/carousel.tsx">
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="src/components/ui/chart.tsx">
import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item.dataKey || item.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
</file>

<file path="src/components/ui/checkbox.tsx">
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
</file>

<file path="src/components/ui/collapsible.tsx">
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="src/components/ui/command.tsx">
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="src/components/ui/context-menu.tsx">
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
</file>

<file path="src/components/ui/dialog.tsx">
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src/components/ui/drawer.tsx">
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="src/components/ui/form.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="src/components/ui/hover-card.tsx">
import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }
</file>

<file path="src/components/ui/input-otp.tsx">
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="src/components/ui/label.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="src/components/ui/menubar.tsx">
import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const MenubarMenu = MenubarPrimitive.Menu

const MenubarGroup = MenubarPrimitive.Group

const MenubarPortal = MenubarPrimitive.Portal

const MenubarSub = MenubarPrimitive.Sub

const MenubarRadioGroup = MenubarPrimitive.RadioGroup

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
</file>

<file path="src/components/ui/navigation-menu.tsx">
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
</file>

<file path="src/components/ui/pagination.tsx">
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}
</file>

<file path="src/components/ui/popover.tsx">
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="src/components/ui/progress.tsx">
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
</file>

<file path="src/components/ui/radio-group.tsx">
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
</file>

<file path="src/components/ui/resizable.tsx">
import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="src/components/ui/scroll-area.tsx">
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="src/components/ui/select.tsx">
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="src/components/ui/separator.tsx">
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src/components/ui/sheet.tsx">
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
import * as React from "react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
  VariantProps<typeof sheetVariants> { }

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet, SheetClose,
  SheetContent, SheetDescription, SheetFooter, SheetHeader, SheetOverlay, SheetPortal, SheetTitle, SheetTrigger
}
</file>

<file path="src/components/ui/sidebar.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block text-sidebar-foreground"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="src/components/ui/slider.tsx">
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
</file>

<file path="src/components/ui/sonner.tsx">
import { useTheme } from "next-themes"
import { Toaster as Sonner, toast } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster, toast }
</file>

<file path="src/components/ui/switch.tsx">
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
</file>

<file path="src/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src/components/ui/tabs.tsx">
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm shrink-0",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="src/components/ui/toast.tsx">
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
</file>

<file path="src/components/ui/toaster.tsx">
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="src/components/ui/toggle-group.tsx">
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }
</file>

<file path="src/components/ui/toggle.tsx">
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }
</file>

<file path="src/components/ui/tooltip.tsx">
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src/components/ui/use-toast.ts">
import { useToast, toast } from "@/hooks/use-toast";

export { useToast, toast };
</file>

<file path="src/hooks/use-mobile.tsx">
import * as React from "react"

const MOBILE_BREAKPOINT = 1024

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="src/hooks/use-toast.ts">
import { useState, useEffect, ReactNode } from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: ReactNode
  description?: ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = useState<State>(memoryState)

  useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="src/hooks/useAdvancedAnalytics.ts">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { toast } from "sonner";

interface AnalyticsData {
  summary: {
    total_reach: number;
    total_mentions: number;
    total_social_mentions: number;
    unassigned_mentions: number;
    completion_rate: number;
    active_ambassadors: number;
    events_completed: number;
    average_engagement: number;
  };
  performance_distribution: Array<{
    category: string;
    count: number;
    percentage: number;
    color: string;
  }>;
  social_mention_types: Array<{
    type: string;
    count: number;
    percentage: number;
    color: string;
  }>;
  event_comparison: Array<{
    name: string;
    completed: number;
    pending: number;
    failed: number;
    total_reach: number;
  }>;
  top_ambassadors: Array<{
    id: string;
    name: string;
    instagram_user: string;
    total_points: number;
    events_participated: number;
    category: string;
    completion_rate: number;
    total_reach: number;
    social_mentions_count: number;
  }>;
  trends: Array<{
    date: string;
    reach: number;
    mentions: number;
    social_mentions: number;
    engagement: number;
  }>;
}

export function useAdvancedAnalytics(selectedFiestaId?: string | null, selectedEvent?: string, selectedPeriod?: string) {
  const { organization } = useCurrentOrganization();
  const [analyticsData, setAnalyticsData] = useState<AnalyticsData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (organization?.id) {
      fetchAnalyticsData();
    }
  }, [organization?.id, selectedFiestaId, selectedEvent, selectedPeriod]);

  const fetchAnalyticsData = async () => {
    if (!organization?.id) return;

    try {
      setLoading(true);
      setError(null);

      // Fetch summary metrics
      const summaryData = await fetchSummaryMetrics();
      
      // Fetch social mentions distribution
      const socialMentionsData = await fetchSocialMentionsDistribution();
      
      // Fetch performance distribution
      const performanceData = await fetchPerformanceDistribution();
      
      // Fetch event comparison - only if fiesta is selected
      const eventData = selectedFiestaId ? await fetchEventComparison() : [];
      
      // Fetch top ambassadors
      const ambassadorsData = await fetchTopAmbassadors();
      
      // Generate trends (√∫ltimos 30 d√≠as)
      const trendsData = await fetchTrends();

      setAnalyticsData({
        summary: summaryData,
        performance_distribution: performanceData,
        social_mention_types: socialMentionsData,
        event_comparison: eventData,
        top_ambassadors: ambassadorsData,
        trends: trendsData
      });

    } catch (err) {
      console.error('Error fetching analytics:', err);
      setError('Error al cargar datos anal√≠ticos');
      toast.error('Error al cargar analytics');
    } finally {
      setLoading(false);
    }
  };

  const fetchSummaryMetrics = async () => {
    // Fetch active ambassadors count
    const { count: activeAmbassadors } = await supabase
      .from('embassadors')
      .select('*', { count: 'exact', head: true })
      .eq('organization_id', organization!.id)
      .eq('status', 'active');

    // Fetch ambassadors with task data
    const { data: ambassadors } = await supabase
      .from('embassadors')
      .select('id, completed_tasks, failed_tasks')
      .eq('organization_id', organization!.id);

    // Calculate task metrics from ambassador data
    const totalCompleted = ambassadors?.reduce((sum, amb) => sum + (amb.completed_tasks || 0), 0) || 0;
    const totalFailed = ambassadors?.reduce((sum, amb) => sum + (amb.failed_tasks || 0), 0) || 0;
    const totalTasks = totalCompleted + totalFailed;
    
    // For reach, we'll use a simple query without complex joins
    const { data: tasks } = await supabase
      .from('tasks')
      .select('reach_count, engagement_score, embassador_id')
      .in('embassador_id', ambassadors?.map(a => a.id) || []);

    // Fetch social mentions data
    const { data: socialMentions } = await supabase
      .from('social_mentions')
      .select('reach_count, engagement_score, matched_ambassador_id')
      .eq('organization_id', organization!.id);

    const totalReach = (tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0) +
                      (socialMentions?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0);
    const totalEngagement = (tasks?.reduce((sum, t) => sum + (t.engagement_score || 0), 0) || 0) +
                           (socialMentions?.reduce((sum, t) => sum + (t.engagement_score || 0), 0) || 0);
    const totalEngagementCount = (tasks?.length || 0) + (socialMentions?.length || 0);
    
    const totalSocialMentions = socialMentions?.length || 0;
    const unassignedMentions = socialMentions?.filter(m => !m.matched_ambassador_id).length || 0;
    
    // Fetch completed fiestas
    const { count: completedEvents } = await supabase
      .from('fiestas')
      .select('*', { count: 'exact', head: true })
      .eq('organization_id', organization!.id)
      .eq('status', 'completed');

    return {
      total_reach: totalReach,
      total_mentions: totalTasks,
      total_social_mentions: totalSocialMentions,
      unassigned_mentions: unassignedMentions,
      completion_rate: totalTasks > 0 ? Math.round((totalCompleted / totalTasks) * 100) : 0,
      active_ambassadors: activeAmbassadors || 0,
      events_completed: completedEvents || 0,
      average_engagement: totalEngagementCount > 0 ? Number((totalEngagement / totalEngagementCount).toFixed(1)) : 0
    };
  };

  const fetchSocialMentionsDistribution = async () => {
    const { data: socialMentions } = await supabase
      .from('social_mentions')
      .select('mention_type')
      .eq('organization_id', organization!.id);

    const distribution = {
      story: 0,
      mention: 0,
      hashtag: 0,
      comment: 0
    };

    socialMentions?.forEach(mention => {
      const type = mention.mention_type || 'mention';
      if (type in distribution) {
        distribution[type as keyof typeof distribution]++;
      }
    });

    const total = socialMentions?.length || 1;
    
    return [
      {
        type: "Historias",
        count: distribution.story,
        percentage: Math.round((distribution.story / total) * 100),
        color: "#8b5cf6"
      },
      {
        type: "Menciones",
        count: distribution.mention,
        percentage: Math.round((distribution.mention / total) * 100),
        color: "#06b6d4"
      },
      {
        type: "Hashtags",
        count: distribution.hashtag,
        percentage: Math.round((distribution.hashtag / total) * 100),
        color: "#10b981"
      },
      {
        type: "Comentarios",
        count: distribution.comment,
        percentage: Math.round((distribution.comment / total) * 100),
        color: "#f59e0b"
      }
    ];
  };

  const fetchPerformanceDistribution = async () => {
    const { data: ambassadors } = await supabase
      .from('embassadors')
      .select('performance_status')
      .eq('organization_id', organization!.id)
      .eq('status', 'active');

    const distribution = {
      cumple: 0,
      advertencia: 0,
      no_cumple: 0,
      exclusivo: 0
    };

    ambassadors?.forEach(amb => {
      const status = amb.performance_status || 'cumple';
      if (status in distribution) {
        distribution[status as keyof typeof distribution]++;
      }
    });

    const total = ambassadors?.length || 1;
    
    return [
      {
        category: "Cumple",
        count: distribution.cumple,
        percentage: Math.round((distribution.cumple / total) * 100),
        color: "#10b981"
      },
      {
        category: "Advertencia",
        count: distribution.advertencia,
        percentage: Math.round((distribution.advertencia / total) * 100),
        color: "#f59e0b"
      },
      {
        category: "No Cumple",
        count: distribution.no_cumple,
        percentage: Math.round((distribution.no_cumple / total) * 100),
        color: "#ef4444"
      },
      {
        category: "Exclusivo",
        count: distribution.exclusivo,
        percentage: Math.round((distribution.exclusivo / total) * 100),
        color: "#8b5cf6"
      }
    ];
  };

  const fetchEventComparison = async () => {
    if (!selectedFiestaId) return [];

    // Get events for the selected fiesta
    const { data: events } = await supabase
      .from('events')
      .select('id')
      .eq('fiesta_id', selectedFiestaId);

    if (!events || events.length === 0) return [];

    // For each event, get task statistics
    const eventComparison = [];
    for (const event of events.slice(0, 4)) {
      const { data: tasks } = await supabase
        .from('tasks')
        .select('status, reach_count')
        .eq('event_id', event.id);

      const completed = tasks?.filter(t => t.status === 'completed').length || 0;
      const pending = tasks?.filter(t => ['pending', 'uploaded', 'in_progress'].includes(t.status)).length || 0;
      const failed = tasks?.filter(t => ['invalid', 'expired'].includes(t.status)).length || 0;
      const totalReach = tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;

      eventComparison.push({
        name: `Evento ${event.id.slice(0, 8)}`,
        completed,
        pending,
        failed,
        total_reach: totalReach
      });
    }

    return eventComparison;
  };

  const fetchTopAmbassadors = async () => {
    const { data: ambassadors } = await supabase
      .from('embassadors')
      .select('id, first_name, last_name, instagram_user, global_points, events_participated, global_category, completed_tasks, failed_tasks')
      .eq('organization_id', organization!.id)
      .eq('status', 'active')
      .order('global_points', { ascending: false })
      .limit(25);

    // For each ambassador, get their reach data and social mentions separately to avoid complex joins
    const ambassadorsWithReach = await Promise.all(
      (ambassadors || []).map(async (amb) => {
        const { data: tasks } = await supabase
          .from('tasks')
          .select('reach_count')
          .eq('embassador_id', amb.id);

        // Get social mentions count for this ambassador
        const { count: socialMentionsCount } = await supabase
          .from('social_mentions')
          .select('*', { count: 'exact', head: true })
          .eq('matched_ambassador_id', amb.id);

        const totalReach = tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;
        const totalTasks = (amb.completed_tasks || 0) + (amb.failed_tasks || 0);
        
        return {
          id: amb.id,
          name: `${amb.first_name} ${amb.last_name}`,
          instagram_user: amb.instagram_user,
          total_points: amb.global_points || 0,
          events_participated: amb.events_participated || 0,
          category: amb.global_category || 'bronze',
          completion_rate: totalTasks > 0 ? Math.round(((amb.completed_tasks || 0) / totalTasks) * 100) : 0,
          total_reach: totalReach,
          social_mentions_count: socialMentionsCount || 0
        };
      })
    );

    return ambassadorsWithReach;
  };

  const fetchTrends = async () => {
    // Generate last 30 days
    const trends = [];
    const now = new Date();
    
    // Get all ambassadors for this organization first
    const { data: ambassadors } = await supabase
      .from('embassadors')
      .select('id')
      .eq('organization_id', organization!.id);

    const ambassadorIds = ambassadors?.map(a => a.id) || [];
    
    for (let i = 29; i >= 0; i--) {
      const date = new Date(now);
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      
      // Fetch tasks created on this date for our ambassadors
      const { data: dailyTasks } = await supabase
        .from('tasks')
        .select('reach_count, engagement_score')
        .in('embassador_id', ambassadorIds)
        .gte('created_at', `${dateStr}T00:00:00`)
        .lt('created_at', `${dateStr}T23:59:59`);

      // Fetch social mentions created on this date
      const { data: dailySocialMentions } = await supabase
        .from('social_mentions')
        .select('reach_count, engagement_score')
        .eq('organization_id', organization!.id)
        .gte('created_at', `${dateStr}T00:00:00`)
        .lt('created_at', `${dateStr}T23:59:59`);

      const dailyReach = (dailyTasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0) +
                        (dailySocialMentions?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0);
      const dailyMentions = dailyTasks?.length || 0;
      const dailySocialMentionsCount = dailySocialMentions?.length || 0;
      const allDailyItems = [...(dailyTasks || []), ...(dailySocialMentions || [])];
      const dailyEngagement = allDailyItems.length > 0 
        ? allDailyItems.reduce((sum, t) => sum + (t.engagement_score || 0), 0) / allDailyItems.length 
        : 0;

      trends.push({
        date: dateStr,
        reach: dailyReach,
        mentions: dailyMentions,
        social_mentions: dailySocialMentionsCount,
        engagement: Number(dailyEngagement.toFixed(1))
      });
    }
    
    return trends;
  };

  return {
    analyticsData,
    loading,
    error,
    refreshAnalytics: fetchAnalyticsData
  };
}
</file>

<file path="src/hooks/useAmbassadorRequests.ts">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { useRealtimeSocialMentions } from "./useRealtimeSocialMentions";
import { toast } from "sonner";

export interface AmbassadorRequest {
  id: string;
  instagram_username: string;
  instagram_user_id?: string;
  follower_count: number;
  profile_picture_url?: string;
  bio?: string;
  status: 'pending' | 'approved' | 'rejected';
  total_mentions: number;
  last_mention_at: string;
  created_at: string;
  notes?: string;
  source_mention_ids: string[];
}

export function useAmbassadorRequests() {
  const { organization } = useCurrentOrganization();
  const [requests, setRequests] = useState<AmbassadorRequest[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (organization) {
      fetchRequests();
    }
  }, [organization]);

  // Setup realtime subscriptions for live updates
  useRealtimeSocialMentions({
    onNewAmbassadorRequest: () => {
      // Refresh requests when new one arrives
      fetchRequests();
    }
  });

  const fetchRequests = async () => {
    if (!organization) return;

    try {
      setLoading(true);
      setError(null);

      const { data, error: fetchError } = await supabase
        .from('ambassador_requests')
        .select('id, organization_id, instagram_user_id, instagram_username, bio, follower_count, profile_picture_url, source_mention_ids, total_mentions, last_mention_at, status, processed_by_user_id, processed_at, rejection_reason, notes, created_at')
        .eq('organization_id', organization.id)
        .order('created_at', { ascending: false });

      if (fetchError) {
        console.error('Error fetching ambassador requests:', fetchError);
        setError('Error al cargar solicitudes de embajadores');
        return;
      }

      setRequests((data || []).map(req => ({...req, status: req.status as 'pending' | 'approved' | 'rejected'})));

    } catch (err) {
      console.error('Error fetching ambassador requests:', err);
      setError('Error inesperado al cargar solicitudes');
    } finally {
      setLoading(false);
    }
  };

  const approveRequest = async (requestId: string, ambassadorData: {
    first_name: string;
    last_name: string;
    email: string;
    date_of_birth?: string;
    rut?: string;
  }) => {
    try {
      const request = requests.find(r => r.id === requestId);
      if (!request) throw new Error('Solicitud no encontrada');

      // Create ambassador
      const { data: ambassador, error: ambassadorError } = await supabase
        .from('embassadors')
        .insert({
          ...ambassadorData,
          instagram_user: request.instagram_username,
          instagram_user_id: request.instagram_user_id,
          follower_count: request.follower_count,
          profile_picture_url: request.profile_picture_url,
          organization_id: organization?.id,
          status: 'active',
          global_points: 0,
          global_category: 'bronze'
        })
        .select()
        .single();

      if (ambassadorError) throw ambassadorError;

      // Update all related social mentions to link to this ambassador
      const { error: updateMentionsError } = await supabase
        .from('social_mentions')
        .update({ 
          matched_ambassador_id: ambassador.id,
          processed: true,
          processed_at: new Date().toISOString()
        })
        .in('id', request.source_mention_ids);

      if (updateMentionsError) {
        console.error('Error updating social mentions:', updateMentionsError);
      }

      // Update request status
      const { error: updateError } = await supabase
        .from('ambassador_requests')
        .update({ 
          status: 'approved',
          processed_at: new Date().toISOString()
        })
        .eq('id', requestId);

      if (updateError) throw updateError;

      toast.success('Embajador aprobado exitosamente');
      fetchRequests(); // Refresh data
      
      return ambassador;
    } catch (error) {
      console.error('Error approving request:', error);
      toast.error('Error al aprobar solicitud');
      throw error;
    }
  };

  const rejectRequest = async (requestId: string, reason?: string) => {
    try {
      const { error } = await supabase
        .from('ambassador_requests')
        .update({ 
          status: 'rejected',
          rejection_reason: reason,
          processed_at: new Date().toISOString()
        })
        .eq('id', requestId);

      if (error) throw error;

      toast.success('Solicitud rechazada');
      fetchRequests(); // Refresh data
    } catch (error) {
      console.error('Error rejecting request:', error);
      toast.error('Error al rechazar solicitud');
    }
  };

  const getPendingCount = () => {
    return requests.filter(r => r.status === 'pending').length;
  };

  return {
    requests,
    loading,
    error,
    approveRequest,
    rejectRequest,
    getPendingCount,
    refreshRequests: fetchRequests
  };
}
</file>

<file path="src/hooks/useAuth.ts">
import { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { supabase } from "@/integrations/supabase/client";
import type { User, Session } from "@supabase/supabase-js";
import { toast } from "sonner";

export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user ?? null);
      setLoading(false);
    });

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        console.log('Auth state changed:', event, !!session);
        
        setSession(session);
        setUser(session?.user ?? null);
        setLoading(false);

        // Handle sign out - redirect immediately
        if (event === 'SIGNED_OUT') {
          console.log('User signed out - redirecting to auth');
          // Clear any cached data
          localStorage.clear();
          sessionStorage.clear();
          // Force redirect to auth page
          setTimeout(() => {
            navigate('/auth', { replace: true });
          }, 0);
          return;
        }

        // Si el usuario se acaba de registrar, crear su perfil en users
        if (session?.user && event === 'SIGNED_IN') {
          setTimeout(() => {
            ensureUserProfile(session.user);
          }, 0);
        }
      }
    );

    return () => subscription.unsubscribe();
  }, [navigate]);

  const ensureUserProfile = async (authUser: User) => {
    try {
      console.log('Ensuring user profile for:', authUser.id);
      
      // Verificar si ya existe el usuario en la tabla users
      const { data: existingUser, error: fetchError } = await supabase
        .from('users')
        .select('id, organization_id, name')
        .eq('auth_user_id', authUser.id)
        .maybeSingle();

      if (fetchError) {
        console.error('Error checking existing user:', fetchError);
        return;
      }

      if (!existingUser) {
        console.log('User does not exist, will need to create profile after organization setup');
        // No creamos el usuario autom√°ticamente, esperamos a que cree una organizaci√≥n
      } else {
        console.log('User already exists:', existingUser);
      }
    } catch (error) {
      console.error('Error in ensureUserProfile:', error);
    }
  };

  const signIn = async (email: string, password: string) => {
    try {
      console.log('Attempting to sign in:', email);
      
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });
      
      if (error) {
        console.error('Sign in error:', error);
        toast.error(error.message);
      } else {
        console.log('Sign in successful:', data);
        toast.success('¬°Bienvenido de vuelta!');
        // Redirect to main page after successful login
        setTimeout(() => {
          navigate('/', { replace: true });
        }, 100);
      }
      
      return { data, error };
    } catch (error) {
      console.error('Sign in error:', error);
      toast.error('Error al iniciar sesi√≥n');
      return { data: null, error };
    }
  };

  const signUp = async (email: string, password: string, fullName?: string) => {
    try {
      console.log('Attempting to sign up:', email);
      
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: {
            full_name: fullName || email.split('@')[0]
          },
          emailRedirectTo: `${window.location.origin}/`
        }
      });
      
      if (error) {
        console.error('Sign up error:', error);
        toast.error(error.message);
      } else {
        console.log('Sign up successful:', data);
        toast.success('¬°Cuenta creada correctamente! Ahora puedes iniciar sesi√≥n.');
      }
      
      return { data, error };
    } catch (error) {
      console.error('Sign up error:', error);
      toast.error('Error al crear cuenta');
      return { data: null, error };
    }
  };

  const signOut = async () => {
    try {
      console.log('Attempting to sign out');
      
      // Clear local state first
      setLoading(true);
      
      const { error } = await supabase.auth.signOut();
      
      if (error) {
        console.error('Sign out error:', error);
        toast.error('Error al cerrar sesi√≥n');
        setLoading(false);
      } else {
        console.log('Sign out successful');
        // Clear all local data
        localStorage.clear();
        sessionStorage.clear();
        
        // Reset states
        setSession(null);
        setUser(null);
        setLoading(false);
        
        toast.success('Sesi√≥n cerrada correctamente');
        
        // Force redirect to auth page
        navigate('/auth', { replace: true });
      }
      
      return { error };
    } catch (error) {
      console.error('Sign out error:', error);
      toast.error('Error al cerrar sesi√≥n');
      setLoading(false);
      return { error };
    }
  };

  return {
    user,
    session,
    loading,
    signIn,
    signUp,
    signOut,
  };
}
</file>

<file path="src/hooks/useAuthCleanup.ts">
import { supabase } from "@/integrations/supabase/client";

/**
 * Comprehensive auth state cleanup utility to prevent limbo states
 * when users switch accounts or experience authentication issues
 */
export const cleanupAuthState = () => {
  console.log('Cleaning up authentication state...');
  
  // Remove standard Supabase auth tokens
  localStorage.removeItem('supabase.auth.token');
  
  // Remove all Supabase auth keys from localStorage
  Object.keys(localStorage).forEach((key) => {
    if (key.startsWith('supabase.auth.') || key.includes('sb-')) {
      localStorage.removeItem(key);
      console.log(`Removed localStorage key: ${key}`);
    }
  });
  
  // Remove from sessionStorage if in use
  if (typeof sessionStorage !== 'undefined') {
    Object.keys(sessionStorage).forEach((key) => {
      if (key.startsWith('supabase.auth.') || key.includes('sb-')) {
        sessionStorage.removeItem(key);
        console.log(`Removed sessionStorage key: ${key}`);
      }
    });
  }
  
  console.log('Auth state cleanup completed');
};

/**
 * Enhanced sign out function that ensures complete cleanup
 */
export const performSecureSignOut = async (): Promise<void> => {
  try {
    console.log('Performing secure sign out...');
    
    // Step 1: Clean up local storage first
    cleanupAuthState();
    
    // Step 2: Attempt global sign out (ignore errors)
    try {
      await supabase.auth.signOut({ scope: 'global' });
      console.log('Global sign out successful');
    } catch (signOutError) {
      console.warn('Global sign out failed (continuing anyway):', signOutError);
    }
    
    // Step 3: Force page reload for clean state
    console.log('Redirecting to clean state...');
    window.location.href = '/auth';
    
  } catch (error) {
    console.error('Error during secure sign out:', error);
    // Force redirect even if there are errors
    window.location.href = '/auth';
  }
};

/**
 * Enhanced sign in function that ensures clean state before authentication
 */
export const performSecureSignIn = async (email: string, password: string): Promise<void> => {
  try {
    console.log('Performing secure sign in...');
    
    // Step 1: Clean up any existing state
    cleanupAuthState();
    
    // Step 2: Attempt global sign out to clear any server-side sessions
    try {
      await supabase.auth.signOut({ scope: 'global' });
    } catch (error) {
      console.warn('Cleanup sign out failed (continuing):', error);
    }
    
    // Step 3: Sign in with email/password
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });
    
    if (error) {
      throw error;
    }
    
    if (data.user) {
      console.log('Sign in successful, redirecting...');
      // Force page reload to ensure clean state
      window.location.href = '/';
    }
    
  } catch (error) {
    console.error('Secure sign in error:', error);
    throw error;
  }
};

/**
 * Hook for components that need auth cleanup functionality
 */
export const useAuthCleanup = () => {
  return {
    cleanupAuthState,
    performSecureSignOut,
    performSecureSignIn,
  };
};
</file>

<file path="src/hooks/useDebounce.ts">
import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
</file>

<file path="src/hooks/useEventLogger.ts">
import { supabase } from "@/integrations/supabase/client";

export function useEventLogger() {
  const createLog = async (
    action: string,
    eventId?: string,
    details?: any
  ) => {
    try {
      const { data: user } = await supabase.auth.getUser();
      if (!user.user) return;

      const { data: userData, error: userError } = await supabase
        .from('users')
        .select('id')
        .eq('auth_user_id', user.user.id)
        .single();

      if (userError) throw userError;

      // Por ahora solo loggeamos en consola ya que no tenemos tabla event_logs
      console.log('Event Log:', {
        user_id: userData.id,
        event_id: eventId,
        action: action,
        details: details || {},
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      console.error('Error in createLog:', error);
    }
  };

  const createFeedback = async (
    type: 'success' | 'error' | 'warning' | 'info',
    message: string,
    eventId?: string
  ) => {
    try {
      const { data: user } = await supabase.auth.getUser();
      if (!user.user) return;

      const { data: userData, error: userError } = await supabase
        .from('users')
        .select('id')
        .eq('auth_user_id', user.user.id)
        .single();

      if (userError) throw userError;

      // Por ahora solo loggeamos en consola ya que no tenemos tabla feedback_cards
      console.log('Feedback Card:', {
        user_id: userData.id,
        event_id: eventId,
        type: type,
        message: message,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      console.error('Error in createFeedback:', error);
    }
  };

  return {
    createLog,
    createFeedback
  };
}
</file>

<file path="src/hooks/useFiestaMetrics.ts">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

interface FiestaMetrics {
  total_ambassadors: number;
  active_ambassadors: number;
  total_tasks: number;
  completed_tasks: number;
  invalid_tasks: number;
  pending_tasks: number;
  total_reach: number;
  avg_engagement: number;
  completion_rate: number;
  top_ambassadors: Array<{
    id: string;
    name: string;
    instagram_user: string;
    points: number;
    tasks_completed: number;
    category: string;
  }>;
  recent_tasks: Array<{
    id: string;
    task_type: string;
    status: string;
    created_at: string;
    ambassador_name: string;
    fiesta_name: string;
  }>;
}

export function useFiestaMetrics(fiestaId: string | null) {
  const [metrics, setMetrics] = useState<FiestaMetrics | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchMetrics();
  }, [fiestaId]);

  const fetchMetrics = async () => {
    try {
      setLoading(true);

      if (!fiestaId) {
        // M√©tricas globales de todas las fiestas
        await fetchGlobalMetrics();
      } else {
        // M√©tricas espec√≠ficas de una fiesta
        await fetchFiestaSpecificMetrics(fiestaId);
      }
    } catch (error) {
      console.error('Error fetching fiesta metrics:', error);
      toast.error('Error al cargar m√©tricas');
    } finally {
      setLoading(false);
    }
  };

  const fetchGlobalMetrics = async () => {
    // Obtener todas las tareas de la organizaci√≥n
    const { data: tasks } = await supabase
      .from('tasks')
      .select(`
        id,
        task_type,
        status,
        points_earned,
        reach_count,
        engagement_score,
        created_at,
        embassadors!inner (
          id,
          first_name,
          last_name,
          instagram_user,
          global_points,
          global_category,
          organization_id
        ),
        events!inner (
          id,
          fiestas!inner (
            id,
            name,
            organization_id
          )
        )
      `);

    // Obtener embajadores √∫nicos
    const ambassadorSet = new Set();
    const ambassadorMap = new Map();
    
    tasks?.forEach(task => {
      const ambassador = task.embassadors;
      if (ambassador) {
        ambassadorSet.add(ambassador.id);
        
        const key = ambassador.id;
        if (!ambassadorMap.has(key)) {
          ambassadorMap.set(key, {
            id: ambassador.id,
            name: `${ambassador.first_name} ${ambassador.last_name}`,
            instagram_user: ambassador.instagram_user,
            points: ambassador.global_points || 0,
            tasks_completed: 0,
            category: ambassador.global_category || 'bronze'
          });
        }
        
        if (task.status === 'completed') {
          ambassadorMap.get(key).tasks_completed += 1;
        }
      }
    });

    const totalTasks = tasks?.length || 0;
    const completedTasks = tasks?.filter(t => t.status === 'completed').length || 0;
    const invalidTasks = tasks?.filter(t => t.status === 'invalid').length || 0;
    const pendingTasks = tasks?.filter(t => t.status === 'pending').length || 0;
    const totalReach = tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;
    const avgEngagement = tasks?.length > 0 
      ? tasks.reduce((sum, t) => sum + (t.engagement_score || 0), 0) / tasks.length 
      : 0;

    const metricsData: FiestaMetrics = {
      total_ambassadors: ambassadorSet.size,
      active_ambassadors: ambassadorSet.size, // Simplificado por ahora
      total_tasks: totalTasks,
      completed_tasks: completedTasks,
      invalid_tasks: invalidTasks,
      pending_tasks: pendingTasks,
      total_reach: totalReach,
      avg_engagement: Number(avgEngagement.toFixed(1)),
      completion_rate: totalTasks > 0 ? Number(((completedTasks / totalTasks) * 100).toFixed(1)) : 0,
      top_ambassadors: Array.from(ambassadorMap.values())
        .sort((a, b) => b.points - a.points)
        .slice(0, 5),
      recent_tasks: tasks?.slice(0, 10).map(task => ({
        id: task.id,
        task_type: task.task_type,
        status: task.status,
        created_at: task.created_at,
        ambassador_name: `${task.embassadors.first_name} ${task.embassadors.last_name}`,
        fiesta_name: task.events?.fiestas?.name || 'Sin fiesta'
      })) || []
    };

    setMetrics(metricsData);
  };

  const fetchFiestaSpecificMetrics = async (fiestaId: string) => {
    // Obtener eventos de la fiesta espec√≠fica
    const { data: events } = await supabase
      .from('events')
      .select('id')
      .eq('fiesta_id', fiestaId);

    const eventIds = events?.map(e => e.id) || [];

    if (eventIds.length === 0) {
      setMetrics({
        total_ambassadors: 0,
        active_ambassadors: 0,
        total_tasks: 0,
        completed_tasks: 0,
        invalid_tasks: 0,
        pending_tasks: 0,
        total_reach: 0,
        avg_engagement: 0,
        completion_rate: 0,
        top_ambassadors: [],
        recent_tasks: []
      });
      return;
    }

    // Obtener tareas espec√≠ficas de esta fiesta
    const { data: tasks } = await supabase
      .from('tasks')
      .select(`
        id,
        task_type,
        status,
        points_earned,
        reach_count,
        engagement_score,
        created_at,
        embassadors!inner (
          id,
          first_name,
          last_name,
          instagram_user,
          global_points,
          global_category
        ),
        events!inner (
          id,
          fiestas!inner (
            id,
            name
          )
        )
      `)
      .in('event_id', eventIds);

    // Similar l√≥gica que fetchGlobalMetrics pero filtrada por fiesta
    const ambassadorSet = new Set();
    const ambassadorMap = new Map();
    
    tasks?.forEach(task => {
      const ambassador = task.embassadors;
      if (ambassador) {
        ambassadorSet.add(ambassador.id);
        
        const key = ambassador.id;
        if (!ambassadorMap.has(key)) {
          ambassadorMap.set(key, {
            id: ambassador.id,
            name: `${ambassador.first_name} ${ambassador.last_name}`,
            instagram_user: ambassador.instagram_user,
            points: ambassador.global_points || 0,
            tasks_completed: 0,
            category: ambassador.global_category || 'bronze'
          });
        }
        
        if (task.status === 'completed') {
          ambassadorMap.get(key).tasks_completed += 1;
        }
      }
    });

    const totalTasks = tasks?.length || 0;
    const completedTasks = tasks?.filter(t => t.status === 'completed').length || 0;
    const invalidTasks = tasks?.filter(t => t.status === 'invalid').length || 0;
    const pendingTasks = tasks?.filter(t => t.status === 'pending').length || 0;
    const totalReach = tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;
    const avgEngagement = tasks?.length > 0 
      ? tasks.reduce((sum, t) => sum + (t.engagement_score || 0), 0) / tasks.length 
      : 0;

    const metricsData: FiestaMetrics = {
      total_ambassadors: ambassadorSet.size,
      active_ambassadors: ambassadorSet.size,
      total_tasks: totalTasks,
      completed_tasks: completedTasks,
      invalid_tasks: invalidTasks,
      pending_tasks: pendingTasks,
      total_reach: totalReach,
      avg_engagement: Number(avgEngagement.toFixed(1)),
      completion_rate: totalTasks > 0 ? Number(((completedTasks / totalTasks) * 100).toFixed(1)) : 0,
      top_ambassadors: Array.from(ambassadorMap.values())
        .sort((a, b) => b.points - a.points)
        .slice(0, 5),
      recent_tasks: tasks?.slice(0, 10).map(task => ({
        id: task.id,
        task_type: task.task_type,
        status: task.status,
        created_at: task.created_at,
        ambassador_name: `${task.embassadors.first_name} ${task.embassadors.last_name}`,
        fiesta_name: task.events?.fiestas?.name || 'Sin fiesta'
      })) || []
    };

    setMetrics(metricsData);
  };

  return {
    metrics,
    loading,
    refreshMetrics: fetchMetrics
  };
}
</file>

<file path="src/hooks/useFiestas.ts">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { toast } from "sonner";

export interface Fiesta {
  id: string;
  name: string;
  description: string | null;
  organization_id: string;
  event_date: string | null;
  location: string | null;
  main_hashtag: string | null;
  secondary_hashtags: string[] | null;
  status: string;
  created_at: string;
  updated_at: string;
}

export function useFiestas() {
  const { organization } = useCurrentOrganization();
  const [fiestas, setFiestas] = useState<Fiesta[]>([]);
  const [selectedFiestaId, setSelectedFiestaId] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (organization) {
      fetchFiestas();
    }
  }, [organization]);

  const fetchFiestas = async () => {
    if (!organization) return;

    try {
      setLoading(true);
      
      const { data, error } = await supabase
        .from('fiestas')
        .select('id, organization_id, name, description, location, event_date, main_hashtag, secondary_hashtags, instagram_handle, status, created_at, updated_at')
        .eq('organization_id', organization.id)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching fiestas:', error);
        toast.error('Error al cargar fiestas');
        return;
      }

      setFiestas(data || []);
      
      // Auto-select first fiesta if none selected
      if (!selectedFiestaId && data && data.length > 0) {
        setSelectedFiestaId(data[0].id);
      }
    } catch (error) {
      console.error('Unexpected error fetching fiestas:', error);
      toast.error('Error inesperado');
    } finally {
      setLoading(false);
    }
  };

  const createFiesta = async (fiestaData: Omit<Fiesta, 'id' | 'organization_id' | 'created_at' | 'updated_at'>) => {
    if (!organization) return null;

    try {
      setLoading(true);
      
      const { data, error } = await supabase
        .from('fiestas')
        .insert({
          ...fiestaData,
          organization_id: organization.id
        })
        .select()
        .single();

      if (error) {
        console.error('Error creating fiesta:', error);
        toast.error('Error al crear fiesta');
        return null;
      }

      await fetchFiestas();
      toast.success('Fiesta creada exitosamente');
      return data;
    } catch (error) {
      console.error('Error creating fiesta:', error);
      toast.error('Error inesperado');
      return null;
    } finally {
      setLoading(false);
    }
  };

  const updateFiesta = async (fiestaId: string, updates: Partial<Fiesta>) => {
    try {
      setLoading(true);
      
      const { error } = await supabase
        .from('fiestas')
        .update(updates)
        .eq('id', fiestaId);

      if (error) {
        console.error('Error updating fiesta:', error);
        toast.error('Error al actualizar fiesta');
        return false;
      }

      await fetchFiestas();
      toast.success('Fiesta actualizada');
      return true;
    } catch (error) {
      console.error('Error updating fiesta:', error);
      toast.error('Error inesperado');
      return false;
    } finally {
      setLoading(false);
    }
  };

  const selectedFiesta = fiestas.find(f => f.id === selectedFiestaId) || null;

  return {
    fiestas,
    selectedFiesta,
    selectedFiestaId,
    setSelectedFiestaId,
    loading,
    createFiesta,
    updateFiesta,
    refreshFiestas: fetchFiestas
  };
}
</file>

<file path="src/hooks/useInstagramDiagnostics.ts">
import { useState } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { useInstagramConnection } from "./useInstagramConnection";
import { toast } from "sonner";

interface ConnectionTest {
  name: string;
  status: 'pending' | 'success' | 'error';
  message?: string;
  details?: any;
}

interface WebhookStatus {
  configured: boolean;
  reachable: boolean;
  lastEvent?: string;
  errors?: string[];
  credentials_configured?: boolean;
  app_id?: string;
  recent_activity?: Array<{
    type: string;
    created_at: string;
  }>;
}

export function useInstagramDiagnostics() {
  const { organization } = useCurrentOrganization();
  const { isConnected } = useInstagramConnection();
  const [isRunning, setIsRunning] = useState(false);
  const [connectionTests, setConnectionTests] = useState<ConnectionTest[]>([]);
  const [webhookStatus, setWebhookStatus] = useState<WebhookStatus | null>(null);

  const runConnectionTests = async () => {
    if (!organization?.id || !isConnected) {
      toast.error('Instagram no est√° conectado');
      return;
    }

    setIsRunning(true);
    setConnectionTests([]);

    const tests: ConnectionTest[] = [
      { name: 'Token v√°lido', status: 'pending' },
      { name: 'Acceso a perfil de Instagram', status: 'pending' },
      { name: 'Permisos de lectura de menciones', status: 'pending' },
      { name: 'Permisos de historias', status: 'pending' },
      { name: 'Webhook configurado', status: 'pending' },
    ];

    setConnectionTests([...tests]);

    try {
      // Test 1: Verify token validity
      const { data: tokenData, error: tokenError } = await supabase.functions.invoke('instagram-diagnostics', {
        body: { 
          organization_id: organization.id,
          test: 'token_validity'
        }
      });

      tests[0] = {
        ...tests[0],
        status: tokenError ? 'error' : 'success',
        message: tokenError ? 'Token inv√°lido o expirado' : 'Token v√°lido y activo',
        details: tokenData
      };
      setConnectionTests([...tests]);

      if (!tokenError) {
        // Test 2: Instagram profile access
        const { data: profileData, error: profileError } = await supabase.functions.invoke('instagram-diagnostics', {
          body: { 
            organization_id: organization.id,
            test: 'profile_access'
          }
        });

        tests[1] = {
          ...tests[1],
          status: profileError ? 'error' : 'success',
          message: profileError ? 'No se puede acceder al perfil' : `Perfil: ${profileData?.username || 'Disponible'}`,
          details: profileData
        };
        setConnectionTests([...tests]);

        // Test 3: Mentions permissions
        const { data: mentionsData, error: mentionsError } = await supabase.functions.invoke('instagram-diagnostics', {
          body: { 
            organization_id: organization.id,
            test: 'mentions_permissions'
          }
        });

        tests[2] = {
          ...tests[2],
          status: mentionsError ? 'error' : 'success',
          message: mentionsError ? 'Sin acceso a menciones' : 'Permisos de menciones activos',
          details: mentionsData
        };
        setConnectionTests([...tests]);

        // Test 4: Stories permissions
        const { data: storiesData, error: storiesError } = await supabase.functions.invoke('instagram-diagnostics', {
          body: { 
            organization_id: organization.id,
            test: 'stories_permissions'
          }
        });

        tests[3] = {
          ...tests[3],
          status: storiesError ? 'error' : 'success',
          message: storiesError ? 'Sin acceso a historias' : 'Permisos de historias activos',
          details: storiesData
        };
        setConnectionTests([...tests]);
      } else {
        // Mark other tests as skipped if token is invalid
        for (let i = 1; i < 4; i++) {
          tests[i] = { ...tests[i], status: 'error', message: 'Saltado por token inv√°lido' };
        }
      }

      // Test 5: Webhook status
      const { data: webhookData, error: webhookError } = await supabase.functions.invoke('instagram-diagnostics', {
        body: { 
          organization_id: organization.id,
          test: 'webhook_status'
        }
      });

      tests[4] = {
        ...tests[4],
        status: webhookError ? 'error' : 'success',
        message: webhookError ? 'Webhook no configurado' : 'Webhook activo',
        details: webhookData
      };

      setWebhookStatus(webhookData || { configured: false, reachable: false });
      setConnectionTests([...tests]);

    } catch (error) {
      console.error('Error running diagnostics:', error);
      toast.error('Error al ejecutar diagn√≥sticos');
    } finally {
      setIsRunning(false);
    }
  };

  const testWebhookDelivery = async () => {
    if (!organization?.id) {
      toast.error('No se encontr√≥ organizaci√≥n');
      return;
    }

    try {
      toast.info('Enviando test de webhook...');
      
      const { data, error } = await supabase.functions.invoke('instagram-diagnostics', {
        body: { 
          organization_id: organization.id,
          test: 'webhook_test'
        }
      });

      if (error) {
        console.error('Webhook test error:', error);
        toast.error('Error al probar webhook: ' + error.message);
      } else if (data.test_sent) {
        toast.success('Test de webhook enviado correctamente');
        toast.info('Revisa la secci√≥n de menciones para ver el test', {
          description: 'El webhook deber√≠a crear una menci√≥n de prueba'
        });
      } else {
        toast.error('Test de webhook fall√≥: ' + (data.error || 'Error desconocido'));
      }
    } catch (error) {
      console.error('Error testing webhook:', error);
      toast.error('Error al probar webhook');
    }
  };

  return {
    isRunning,
    connectionTests,
    webhookStatus,
    runConnectionTests,
    testWebhookDelivery
  };
}
</file>

<file path="src/hooks/useInstagramSync.ts">
import { useState } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { toast } from "sonner";

export function useInstagramSync() {
  const { organization } = useCurrentOrganization();
  const [isSyncing, setIsSyncing] = useState(false);

  const syncInstagramData = async () => {
    if (!organization?.id) {
      toast.error('No se encontr‡∏£‡∏ì organizaci‡∏£‡∏ìn');
      return false;
    }

    try {
      setIsSyncing(true);
      
      const { data, error } = await supabase.functions.invoke('instagram-sync', {
        body: { organization_id: organization.id }
      });

      if (error) {
        console.error('Error syncing Instagram data:', error);
        toast.error('Error al sincronizar datos de Instagram');
        return false;
      }

      if (data?.success) {
        const totalProcessed = data.totalProcessed || 0;
        const newMentions = data.results?.reduce((sum: number, r: any) => sum + (r.newMentions || 0), 0) || 0;
        const newTags = data.results?.reduce((sum: number, r: any) => sum + (r.newTags || 0), 0) || 0;
        
        if (newMentions > 0 || newTags > 0) {
          toast.success(`Sincronizaci‡∏£‡∏ìn completada: ${newMentions} menciones, ${newTags} etiquetas detectadas`);
        } else {
          toast.success('Datos de Instagram sincronizados correctamente');
        }
        return true;
      } else {
        toast.error('Error en la sincronizaci‡∏£‡∏ìn');
        return false;
      }
    } catch (error) {
      console.error('Error syncing Instagram:', error);
      toast.error('Error inesperado al sincronizar');
      return false;
    } finally {
      setIsSyncing(false);
    }
  };

  // Nuevas funciones seg‡∏£‡∏ön especificaciones del usuario
  const getInstagramProfile = async () => {
    if (!organization?.id) {
      toast.error('No se encontr‡∏£‡∏ì organizaci‡∏£‡∏ìn');
      return null;
    }

    try {
      setIsSyncing(true);
      
      const { data, error } = await supabase.functions.invoke('instagram-profile', {
        body: { 
          organization_id: organization.id, 
          endpoint: 'profile' 
        }
      });

      if (error) {
        console.error('Error getting Instagram profile:', error);
        toast.error('Error al obtener perfil de Instagram');
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error getting Instagram profile:', error);
      toast.error('Error inesperado al obtener perfil');
      return null;
    } finally {
      setIsSyncing(false);
    }
  };

  const getInstagramMedia = async () => {
    if (!organization?.id) {
      toast.error('No se encontr‡∏£‡∏ì organizaci‡∏£‡∏ìn');
      return null;
    }

    try {
      setIsSyncing(true);
      
      const { data, error } = await supabase.functions.invoke('instagram-profile', {
        body: { 
          organization_id: organization.id, 
          endpoint: 'media' 
        }
      });

      if (error) {
        console.error('Error getting Instagram media:', error);
        toast.error('Error al obtener feed de Instagram');
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error getting Instagram media:', error);
      toast.error('Error inesperado al obtener feed');
      return null;
    } finally {
      setIsSyncing(false);
    }
  };

  const getInstagramTags = async () => {
    if (!organization?.id) {
      toast.error('No se encontr‡∏£‡∏ì organizaci‡∏£‡∏ìn');
      return null;
    }

    try {
      setIsSyncing(true);
      
      const { data, error } = await supabase.functions.invoke('instagram-profile', {
        body: { 
          organization_id: organization.id, 
          endpoint: 'tags' 
        }
      });

      if (error) {
        console.error('Error getting Instagram tags:', error);
        toast.error('Error al obtener menciones de Instagram');
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error getting Instagram tags:', error);
      toast.error('Error inesperado al obtener menciones');
      return null;
    } finally {
      setIsSyncing(false);
    }
  };

  const refreshToken = async () => {
    if (!organization?.id) {
      toast.error('No se encontr‡∏£‡∏ì organizaci‡∏£‡∏ìn');
      return false;
    }

    try {
      setIsSyncing(true);
      
      const { data, error } = await supabase.functions.invoke('meta-oauth?action=refresh', {
        body: { organization_id: organization.id }
      });

      if (error) {
        console.error('Error refreshing token:', error);
        toast.error('Error al renovar token de Instagram');
        return false;
      }

      if (data?.success) {
        toast.success('Token de Instagram renovado correctamente');
        return true;
      } else {
        toast.error('Error al renovar token');
        return false;
      }
    } catch (error) {
      console.error('Error refreshing token:', error);
      toast.error('Error inesperado al renovar token');
      return false;
    } finally {
      setIsSyncing(false);
    }
  };

  return {
    isSyncing,
    syncInstagramData,
    refreshToken,
    getInstagramProfile,
    getInstagramMedia,
    getInstagramTags
  };
}
</file>

<file path="src/hooks/useMentionsManagement.ts">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { useRealtimeSocialMentions } from "./useRealtimeSocialMentions";
import { toast } from "sonner";

interface SocialMention {
  id: string;
  instagram_username: string;
  content: string;
  mention_type: 'mention' | 'hashtag' | 'story' | 'comment';
  platform: string;
  reach_count: number;
  engagement_score: number;
  created_at: string;
  processed: boolean;
  matched_ambassador_id?: string;
  ambassador_name?: string;
  event_name?: string;
  fiesta_name?: string;
  story_url?: string;
  hashtag?: string;
  raw_data?: any;
}

interface MentionStats {
  total: number;
  reach: number;
  engagement: number;
  unique_hashtags: number;
  unassigned: number;
}

export function useMentionsManagement() {
  const { organization } = useCurrentOrganization();
  const [mentions, setMentions] = useState<SocialMention[]>([]);
  const [stats, setStats] = useState<MentionStats>({
    total: 0,
    reach: 0,
    engagement: 0,
    unique_hashtags: 0,
    unassigned: 0
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (organization) {
      fetchMentions();
    }
  }, [organization]);

  // Setup realtime subscriptions for live updates
  useRealtimeSocialMentions({
    onNewMention: () => {
      // Refresh mentions when new one arrives
      fetchMentions();
    },
    onMentionUpdated: () => {
      // Refresh mentions when one is updated
      fetchMentions();
    }
  });

  const fetchMentions = async () => {
    if (!organization) return;

    try {
      setLoading(true);
      setError(null);

      const { data, error: fetchError } = await supabase
        .from('social_mentions')
        .select(`
          id,
          instagram_username,
          content,
          mention_type,
          platform,
          reach_count,
          engagement_score,
          created_at,
          processed,
          matched_ambassador_id,
          story_url,
          hashtag,
          raw_data,
          embassadors:matched_ambassador_id (
            first_name,
            last_name
          ),
          fiestas:matched_fiesta_id (
            name
          ),
          events:matched_event_id (
            id
          )
        `)
        .eq('organization_id', organization.id)
        .order('created_at', { ascending: false });

      if (fetchError) {
        console.error('Error fetching social mentions:', fetchError);
        setError('Error al cargar menciones');
        return;
      }

      // Transform data for the component
      const mentionsData: SocialMention[] = (data || []).map(mention => ({
        id: mention.id,
        instagram_username: mention.instagram_username || 'Usuario desconocido',
        content: mention.content || '',
        mention_type: mention.mention_type as SocialMention['mention_type'],
        platform: mention.platform || 'Instagram',
        reach_count: mention.reach_count || 0,
        engagement_score: mention.engagement_score || 0,
        created_at: mention.created_at || new Date().toISOString(),
        processed: mention.processed || false,
        matched_ambassador_id: mention.matched_ambassador_id,
        ambassador_name: mention.embassadors ? 
          `${mention.embassadors.first_name} ${mention.embassadors.last_name}` : 
          undefined,
        fiesta_name: mention.fiestas?.name || undefined,
        story_url: mention.story_url || undefined,
        hashtag: mention.hashtag || undefined,
        raw_data: mention.raw_data
      }));

      setMentions(mentionsData);

      // Calculate statistics
      const totalReach = mentionsData.reduce((sum, m) => sum + m.reach_count, 0);
      const avgEngagement = mentionsData.length > 0 ? 
        mentionsData.reduce((sum, m) => sum + m.engagement_score, 0) / mentionsData.length : 0;
      const uniqueHashtags = new Set(
        mentionsData
          .filter(m => m.hashtag)
          .map(m => m.hashtag)
      ).size;
      const unassignedCount = mentionsData.filter(m => !m.matched_ambassador_id).length;

      setStats({
        total: mentionsData.length,
        reach: totalReach,
        engagement: Math.round(avgEngagement * 100) / 100,
        unique_hashtags: uniqueHashtags,
        unassigned: unassignedCount
      });

    } catch (err) {
      console.error('Error fetching mentions:', err);
      setError('Error inesperado al cargar menciones');
    } finally {
      setLoading(false);
    }
  };

  const filterMentions = (searchTerm: string, typeFilter: string, statusFilter: string) => {
    return mentions.filter(mention => {
      const matchesSearch = mention.instagram_username.toLowerCase().includes(searchTerm.toLowerCase()) ||
        mention.content.toLowerCase().includes(searchTerm.toLowerCase());
      
      const matchesType = typeFilter === 'all' || mention.mention_type === typeFilter;
      const matchesStatus = statusFilter === 'all' || 
        (statusFilter === 'assigned' && mention.matched_ambassador_id) ||
        (statusFilter === 'unassigned' && !mention.matched_ambassador_id);
      
      return matchesSearch && matchesType && matchesStatus;
    });
  };

  const assignToAmbassador = async (mentionId: string, ambassadorId: string) => {
    try {
      const { error } = await supabase
        .from('social_mentions')
        .update({ 
          matched_ambassador_id: ambassadorId, 
          processed: true,
          processed_at: new Date().toISOString()
        })
        .eq('id', mentionId);

      if (error) throw error;

      toast.success('Menci√≥n asignada exitosamente');
      fetchMentions(); // Refresh data
    } catch (error) {
      console.error('Error assigning mention:', error);
      toast.error('Error al asignar menci√≥n');
    }
  };

  return {
    mentions,
    stats,
    loading,
    error,
    filterMentions,
    assignToAmbassador,
    refreshMentions: fetchMentions
  };
}
</file>

<file path="src/hooks/useMentionsOptimized.ts">
import { useState, useMemo } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { useDebounce } from "./useDebounce";
import { toast } from "sonner";

interface SocialMention {
  id: string;
  instagram_username: string;
  content: string;
  mention_type: 'mention' | 'hashtag' | 'story' | 'comment';
  platform: string;
  reach_count: number;
  engagement_score: number;
  created_at: string;
  processed: boolean;
  matched_ambassador_id?: string;
  ambassador_name?: string;
  event_name?: string;
  fiesta_name?: string;
  story_url?: string;
  hashtag?: string;
  raw_data?: any;
}

interface MentionStats {
  total: number;
  reach: number;
  engagement: number;
  unique_hashtags: number;
  unassigned: number;
}

interface PaginatedMentions {
  mentions: SocialMention[];
  stats: MentionStats;
  count: number;
}

const MENTIONS_PER_PAGE = 50;

export function useMentionsOptimized(
  searchTerm: string = "",
  typeFilter: string = "all", 
  statusFilter: string = "all"
) {
  const { organization } = useCurrentOrganization();
  const queryClient = useQueryClient();
  const debouncedSearchTerm = useDebounce(searchTerm, 300);

  const {
    data,
    isLoading,
    error,
    refetch
  } = useQuery({
    queryKey: ['social_mentions', organization?.id, debouncedSearchTerm, typeFilter, statusFilter],
    queryFn: async (): Promise<PaginatedMentions> => {
      if (!organization?.id) {
        throw new Error('No organization selected');
      }

      let query = supabase
        .from('social_mentions')
        .select(`
          id,
          instagram_username,
          content,
          mention_type,
          platform,
          reach_count,
          engagement_score,
          created_at,
          processed,
          matched_ambassador_id,
          story_url,
          hashtag,
          raw_data,
          embassadors:matched_ambassador_id (
            first_name,
            last_name
          ),
          fiestas:matched_fiesta_id (
            name
          ),
          events:matched_event_id (
            id
          )
        `, { count: 'exact' })
        .eq('organization_id', organization.id)
        .order('created_at', { ascending: false })
        .limit(MENTIONS_PER_PAGE);

      // Apply filters
      if (debouncedSearchTerm) {
        query = query.or(`instagram_username.ilike.%${debouncedSearchTerm}%,content.ilike.%${debouncedSearchTerm}%`);
      }
      
      if (typeFilter !== 'all') {
        query = query.eq('mention_type', typeFilter);
      }
      
      if (statusFilter === 'assigned') {
        query = query.not('matched_ambassador_id', 'is', null);
      } else if (statusFilter === 'unassigned') {
        query = query.is('matched_ambassador_id', null);
      }

      const { data: mentionsData, error: fetchError, count } = await query;

      if (fetchError) {
        console.error('Error fetching social mentions:', fetchError);
        throw new Error('Error al cargar menciones');
      }

      // Transform data
      const mentions: SocialMention[] = (mentionsData || []).map(mention => ({
        id: mention.id,
        instagram_username: mention.instagram_username || 'Usuario desconocido',
        content: mention.content || '',
        mention_type: mention.mention_type as SocialMention['mention_type'],
        platform: mention.platform || 'Instagram',
        reach_count: mention.reach_count || 0,
        engagement_score: mention.engagement_score || 0,
        created_at: mention.created_at || new Date().toISOString(),
        processed: mention.processed || false,
        matched_ambassador_id: mention.matched_ambassador_id,
        ambassador_name: mention.embassadors ? 
          `${mention.embassadors.first_name} ${mention.embassadors.last_name}` : 
          undefined,
        fiesta_name: mention.fiestas?.name || undefined,
        story_url: mention.story_url || undefined,
        hashtag: mention.hashtag || undefined,
        raw_data: mention.raw_data
      }));

      // Calculate statistics
      const totalReach = mentions.reduce((sum, m) => sum + m.reach_count, 0);
      const avgEngagement = mentions.length > 0 ? 
        mentions.reduce((sum, m) => sum + m.engagement_score, 0) / mentions.length : 0;
      const uniqueHashtags = new Set(
        mentions
          .filter(m => m.hashtag)
          .map(m => m.hashtag)
      ).size;
      const unassignedCount = mentions.filter(m => !m.matched_ambassador_id).length;

      const stats: MentionStats = {
        total: count || 0,
        reach: totalReach,
        engagement: Math.round(avgEngagement * 100) / 100,
        unique_hashtags: uniqueHashtags,
        unassigned: unassignedCount
      };

      return {
        mentions,
        stats,
        count: count || 0
      };
    },
    enabled: !!organization?.id,
    placeholderData: (previousData) => previousData,
    staleTime: 5 * 60 * 1000, // 5 minutes
    retry: 1,
  });

  const assignToAmbassador = async (mentionId: string, ambassadorId: string) => {
    try {
      const { error } = await supabase
        .from('social_mentions')
        .update({ 
          matched_ambassador_id: ambassadorId, 
          processed: true,
          processed_at: new Date().toISOString()
        })
        .eq('id', mentionId);

      if (error) throw error;

      toast.success('Menci√≥n asignada exitosamente');
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries({ queryKey: ['social_mentions', organization?.id] });
    } catch (error) {
      console.error('Error assigning mention:', error);
      toast.error('Error al asignar menci√≥n');
    }
  };

  // Memoized client-side filtering for search responsiveness
  const filteredMentions = useMemo(() => {
    if (!data?.mentions) return [];
    
    let filtered = data.mentions;
    
    // Additional client-side filtering for immediate responsiveness
    if (searchTerm && searchTerm !== debouncedSearchTerm) {
      filtered = filtered.filter(mention => 
        mention.instagram_username.toLowerCase().includes(searchTerm.toLowerCase()) ||
        mention.content.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    return filtered;
  }, [data?.mentions, searchTerm, debouncedSearchTerm]);

  return {
    mentions: filteredMentions,
    stats: data?.stats || {
      total: 0,
      reach: 0,
      engagement: 0,
      unique_hashtags: 0,
      unassigned: 0
    },
    loading: isLoading,
    error: error?.message || null,
    assignToAmbassador,
    refreshMentions: refetch
  };
}
</file>

<file path="src/hooks/useN8nWebhooks.ts">
import { useState } from 'react';
import { useToast } from '@/components/ui/use-toast';
import { supabase } from '@/integrations/supabase/client';
import { useOrganizationSettings } from './useOrganizationSettings';
import { useCurrentOrganization } from './useCurrentOrganization';

interface N8nWebhookResponse {
  success: boolean;
  message: string;
  data?: any;
  error?: string;
}

export function useN8nWebhooks() {
  const [isLoading, setIsLoading] = useState(false);
  const { toast } = useToast();
  const { settings } = useOrganizationSettings();
  const { organization } = useCurrentOrganization();

  const callWebhook = async (
    webhookUrl: string,
    data: any,
    successMessage?: string
  ): Promise<N8nWebhookResponse> => {
    setIsLoading(true);
    
    try {
      // Use secure webhook proxy instead of direct calls
      const { data: result, error } = await supabase.functions.invoke('secure-webhook-proxy', {
        body: {
          webhookUrl,
          data
        }
      });

      if (error) {
        throw new Error(error.message || 'Error en la conexi√≥n con el webhook');
      }

      if (result.success) {
        toast({
          title: "√âxito",
          description: successMessage || result.data?.message || 'Operaci√≥n completada',
        });
      } else {
        toast({
          title: "Error",
          description: result.error || 'Error en el procesamiento',
          variant: "destructive",
        });
      }

      return {
        success: result.success,
        message: result.data?.message || result.error || '',
        data: result.data
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Error desconocido';
      
      toast({
        title: "Error de conexi√≥n",
        description: `No se pudo conectar con el servicio: ${errorMessage}`,
        variant: "destructive",
      });

      return {
        success: false,
        message: errorMessage,
        error: errorMessage
      };
    } finally {
      setIsLoading(false);
    }
  };

  // Get configured n8n webhook URL from organization settings
  const getN8nUrl = () => {
    const n8nUrl = settings.integration_settings.n8n_webhook_url;
    if (!n8nUrl) {
      throw new Error('N8N webhook URL no configurada. Por favor config√∫rala en Configuraciones.');
    }
    return n8nUrl;
  };

  // Webhook espec√≠ficos del sistema EVA - ahora centralizados
  const registerUser = async (userData: {
    email: string;
    password: string;
    name: string;
    organizationName: string;
  }) => {
    const n8nUrl = getN8nUrl();
    return callWebhook(
      `${n8nUrl}/webhook/auth-user-registration`,
      { action: 'register_user', ...userData },
      'Usuario registrado exitosamente'
    );
  };

  const createEvent = async (eventData: any) => {
    const n8nUrl = getN8nUrl();
    return callWebhook(
      `${n8nUrl}/webhook/event-management`,
      { action: 'create', ...eventData },
      'Evento creado exitosamente'
    );
  };

  const updateEvent = async (eventData: any) => {
    const n8nUrl = getN8nUrl();
    return callWebhook(
      `${n8nUrl}/webhook/event-management`,
      { action: 'update', ...eventData },
      'Evento actualizado exitosamente'
    );
  };

  const createAmbassador = async (ambassadorData: any) => {
    const n8nUrl = getN8nUrl();
    // Now unified through secure-webhook-proxy
    return callWebhook(
      `${n8nUrl}/webhook/crear-embajador`,
      { action: 'create_ambassador', ...ambassadorData },
      'Embajador creado exitosamente'
    );
  };

  const importAmbassadors = async (ambassadors: any[], organizationId: string) => {
    const n8nUrl = getN8nUrl();
    return callWebhook(
      `${n8nUrl}/webhook/ambassador-management`,
      { action: 'import', ambassadors, organizationId },
      'Embajadores importados exitosamente'
    );
  };

  const approveAmbassador = async (ambassadorId: string, status: string) => {
    const n8nUrl = getN8nUrl();
    return callWebhook(
      `${n8nUrl}/webhook/ambassador-management`,
      { action: 'approve', ambassadorId, status },
      'Estado del embajador actualizado'
    );
  };

  return {
    isLoading,
    callWebhook,
    registerUser,
    createEvent,
    updateEvent,
    createAmbassador,
    importAmbassadors,
    approveAmbassador,
  };
}
</file>

<file path="src/hooks/useNotifications.ts">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useUserProfile } from "./useUserProfile";
import { toast } from "sonner";

interface Notification {
  id: string;
  organization_id: string;
  type: string;
  message: string;
  priority: 'low' | 'normal' | 'high' | 'critical';
  target_type: string | null;
  target_id: string | null;
  read_status: boolean;
  created_at: string;
}

export function useNotifications() {
  const { profile } = useUserProfile();
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (profile?.organization_id) {
      fetchNotifications();
      subscribeToNotifications();
    }
  }, [profile?.organization_id]);

  const fetchNotifications = async () => {
    if (!profile?.organization_id) return;

    try {
      setLoading(true);
      
      const { data, error } = await supabase
        .from('notifications')
        .select('id, organization_id, type, message, target_type, target_id, read_status, priority, created_at')
        .eq('organization_id', profile.organization_id)
        .order('created_at', { ascending: false })
        .limit(50);

      if (error) {
        console.error('Error fetching notifications:', error);
        return;
      }

      // Type assertion to ensure proper typing
      const notificationsData = (data || []).map(notification => ({
        ...notification,
        priority: notification.priority as 'low' | 'normal' | 'high' | 'critical'
      }));
      
      setNotifications(notificationsData);
      setUnreadCount(notificationsData.filter(n => !n.read_status).length);

    } catch (err) {
      console.error('Error fetching notifications:', err);
    } finally {
      setLoading(false);
    }
  };

  const subscribeToNotifications = () => {
    if (!profile?.organization_id) return;

    const channel = supabase
      .channel('notifications')
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'notifications',
          filter: `organization_id=eq.${profile.organization_id}`,
        },
        (payload) => {
          const newNotification = {
            ...payload.new,
            priority: payload.new.priority as 'low' | 'normal' | 'high' | 'critical'
          } as Notification;
          
          setNotifications(prev => [newNotification, ...prev]);
          setUnreadCount(prev => prev + 1);
          
          // Mostrar toast para notificaciones importantes
          if (newNotification.priority === 'high' || newNotification.priority === 'critical') {
            toast.warning(newNotification.message);
          }
        }
      )
      .subscribe();

    return () => {
      channel.unsubscribe();
    };
  };

  const markAsRead = async (notificationId: string) => {
    try {
      const { error } = await supabase
        .from('notifications')
        .update({ read_status: true })
        .eq('id', notificationId);

      if (error) {
        console.error('Error marking notification as read:', error);
        return;
      }

      setNotifications(prev => 
        prev.map(n => 
          n.id === notificationId 
            ? { ...n, read_status: true }
            : n
        )
      );

      setUnreadCount(prev => Math.max(0, prev - 1));

    } catch (err) {
      console.error('Error marking notification as read:', err);
    }
  };

  const markAllAsRead = async () => {
    if (!profile?.organization_id) return;

    try {
      const { error } = await supabase
        .from('notifications')
        .update({ read_status: true })
        .eq('organization_id', profile.organization_id)
        .eq('read_status', false);

      if (error) {
        console.error('Error marking all notifications as read:', error);
        return;
      }

      setNotifications(prev => 
        prev.map(n => ({ ...n, read_status: true }))
      );

      setUnreadCount(0);
      toast.success('Todas las notificaciones marcadas como le√≠das');

    } catch (err) {
      console.error('Error marking all notifications as read:', err);
    }
  };

  return {
    notifications,
    unreadCount,
    loading,
    markAsRead,
    markAllAsRead,
    refreshNotifications: fetchNotifications
  };
}
</file>

<file path="src/hooks/useOrganizationMetrics.ts">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

interface OrganizationMetrics {
  id: string;
  name: string;
  description: string | null;
  created_at: string;
  total_events: number;
  active_events: number;
  total_ambassadors: number;
  active_ambassadors: number;
  total_tasks: number;
  completed_tasks: number;
  total_reach: number;
  avg_engagement: number;
  completion_rate: number;
  instagram_username: string | null;
  last_instagram_sync: string | null;
  top_ambassadors: Array<{
    id: string;
    name: string;
    instagram_user: string;
    points: number;
    tasks_completed: number;
    performance_status: string;
  }>;
  recent_events: Array<{
    id: string;
    name: string;
    event_date: string;
    total_tasks: number;
    completed_tasks: number;
    total_reach: number;
  }>;
  monthly_performance: Array<{
    month: string;
    events: number;
    tasks: number;
    reach: number;
    ambassadors: number;
  }>;
}

export function useOrganizationMetrics(organizationId?: string) {
  const [metrics, setMetrics] = useState<OrganizationMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (organizationId) {
      fetchOrganizationMetrics();
    }
  }, [organizationId]);

  const fetchOrganizationMetrics = async () => {
    if (!organizationId) return;

    try {
      setLoading(true);
      setError(null);

      // Fetch organization basic info
      const { data: organization, error: orgError } = await supabase
        .from('organizations')
        .select('id, name, description, timezone, logo_url, plan_type, instagram_username, facebook_page_id, instagram_business_account_id, instagram_user_id, last_instagram_sync, created_by, created_at')
        .eq('id', organizationId)
        .single();

      if (orgError) throw orgError;

      // Fetch fiestas for this organization  
      const { data: fiestas } = await supabase
        .from('fiestas')
        .select('id, organization_id, name, description, location, event_date, main_hashtag, secondary_hashtags, status, created_at, updated_at')
        .eq('organization_id', organizationId);

      // Get events for this organization
      const { data: events } = await supabase
        .from('events')
        .select('id, fiesta_id, event_date, end_date, start_date, active, created_at, created_by_user_id')
        .in('fiesta_id', fiestas?.map(f => f.id) || []);

      // Fetch ambassadors for this organization
      const { data: ambassadors } = await supabase
        .from('embassadors')
        .select('id, first_name, last_name, email, instagram_user, instagram_user_id, follower_count, global_points, global_category, performance_status, events_participated, completed_tasks, failed_tasks, organization_id, status, created_at')
        .eq('organization_id', organizationId);

      // Fetch tasks for this organization's ambassadors
      const { data: tasks } = await supabase
        .from('tasks')
        .select(`
          id,
          status,
          points_earned,
          reach_count,
          engagement_score,
          created_at,
          embassador_id,
          event_id,
          embassadors!inner (first_name, last_name, instagram_user, global_points, performance_status)
        `)
        .in('embassador_id', ambassadors?.map(a => a.id) || []);

      // Calculate metrics
      const totalReach = tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;
      const avgEngagement = tasks?.length > 0 
        ? tasks.reduce((sum, t) => sum + (t.engagement_score || 0), 0) / tasks.length 
        : 0;
      
      const completedTasks = tasks?.filter(t => t.status === 'completed').length || 0;
      const totalTasks = tasks?.length || 0;
      const completionRate = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;

      // Generate top ambassadors
      const ambassadorMap = new Map();
      tasks?.forEach(task => {
        const ambassador = task.embassadors;
        if (ambassador) {
          const key = ambassador.instagram_user;
          if (!ambassadorMap.has(key)) {
            ambassadorMap.set(key, {
              id: task.embassador_id,
              name: `${ambassador.first_name} ${ambassador.last_name}`,
              instagram_user: ambassador.instagram_user,
              points: ambassador.global_points || 0,
              tasks_completed: 0,
              performance_status: ambassador.performance_status || 'cumple'
            });
          }
          if (task.status === 'completed') {
            ambassadorMap.get(key).tasks_completed += 1;
          }
        }
      });

      const topAmbassadors = Array.from(ambassadorMap.values())
        .sort((a, b) => b.points - a.points)
        .slice(0, 5);

      // Generate recent fiestas with metrics
      const recentEvents = fiestas?.slice(0, 5).map(fiesta => {
        // Find events for this fiesta
        const fiestaEvents = events?.filter(e => e.fiesta_id === fiesta.id) || [];
        const eventIds = fiestaEvents.map(e => e.id);
        const fiestaTasksFiltered = tasks?.filter(t => eventIds.includes(t.event_id)) || [];
        const fiestaCompletedTasks = fiestaTasksFiltered.filter(t => t.status === 'completed').length;
        const fiestaReach = fiestaTasksFiltered.reduce((sum, t) => sum + (t.reach_count || 0), 0);

        return {
          id: fiesta.id,
          name: fiesta.name,
          event_date: fiesta.event_date || fiesta.created_at,
          total_tasks: fiestaTasksFiltered.length,
          completed_tasks: fiestaCompletedTasks,
          total_reach: fiestaReach
        };
      }) || [];

      // Generate monthly performance (last 6 months)
      const monthlyPerformance = generateMonthlyPerformance(events || [], tasks || [], ambassadors || []);

      const metricsData: OrganizationMetrics = {
        id: organization.id,
        name: organization.name,
        description: organization.description,
        created_at: organization.created_at,
        total_events: fiestas?.length || 0,
        active_events: fiestas?.filter(f => f.status === 'active').length || 0,
        total_ambassadors: ambassadors?.length || 0,
        active_ambassadors: ambassadors?.filter(a => a.status === 'active').length || 0,
        total_tasks: totalTasks,
        completed_tasks: completedTasks,
        total_reach: totalReach,
        avg_engagement: Number(avgEngagement.toFixed(1)),
        completion_rate: Number(completionRate.toFixed(1)),
        instagram_username: organization.instagram_username,
        last_instagram_sync: organization.last_instagram_sync,
        top_ambassadors: topAmbassadors,
        recent_events: recentEvents,
        monthly_performance: monthlyPerformance
      };

      setMetrics(metricsData);

    } catch (err) {
      console.error('Error fetching organization metrics:', err);
      setError('Error al cargar m√©tricas de la organizaci√≥n');
      toast.error('Error al cargar m√©tricas');
    } finally {
      setLoading(false);
    }
  };

  const generateMonthlyPerformance = (events: any[], tasks: any[], ambassadors: any[]) => {
    const monthlyData = new Map();
    const now = new Date();

    // Initialize last 6 months
    for (let i = 5; i >= 0; i--) {
      const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
      const key = date.toISOString().slice(0, 7); // YYYY-MM format
      monthlyData.set(key, { 
        month: date.toLocaleDateString('es-ES', { month: 'short', year: 'numeric' }),
        events: 0,
        tasks: 0,
        reach: 0,
        ambassadors: 0
      });
    }

    // Populate with events data
    events.forEach(event => {
      const eventDate = new Date(event.event_date);
      const key = eventDate.toISOString().slice(0, 7);
      
      if (monthlyData.has(key)) {
        monthlyData.get(key).events += 1;
      }
    });

    // Populate with tasks data
    tasks.forEach(task => {
      const taskDate = new Date(task.created_at);
      const key = taskDate.toISOString().slice(0, 7);
      
      if (monthlyData.has(key)) {
        const monthData = monthlyData.get(key);
        monthData.tasks += 1;
        monthData.reach += task.reach_count || 0;
      }
    });

    // Populate with ambassador data (count unique ambassadors per month)
    const monthlyAmbassadors = new Map();
    tasks.forEach(task => {
      const taskDate = new Date(task.created_at);
      const key = taskDate.toISOString().slice(0, 7);
      
      if (monthlyData.has(key)) {
        if (!monthlyAmbassadors.has(key)) {
          monthlyAmbassadors.set(key, new Set());
        }
        monthlyAmbassadors.get(key).add(task.embassador_id);
      }
    });

    // Update ambassador counts
    monthlyAmbassadors.forEach((ambassadorSet, key) => {
      if (monthlyData.has(key)) {
        monthlyData.get(key).ambassadors = ambassadorSet.size;
      }
    });

    return Array.from(monthlyData.values());
  };

  return {
    metrics,
    loading,
    error,
    refreshMetrics: fetchOrganizationMetrics
  };
}
</file>

<file path="src/hooks/useOrganizationSettings.ts">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { toast } from "sonner";

interface OrganizationSettings {
  general_settings: {
    timezone: string;
    language: string;
    logo_url?: string;
    description?: string;
  };
  instagram_settings: {
    auto_sync: boolean;
    sync_interval: string;
    auto_validate_tasks: boolean;
    story_validation_24h: boolean;
  };
  notification_settings: {
    email_notifications: boolean;
    push_notifications: boolean;
    token_expiry_alerts: boolean;
    weekly_reports: boolean;
  };
  permission_settings: {
    allow_ambassador_self_registration: boolean;
    require_approval_for_tasks: boolean;
    auto_validate_tasks: boolean;
  };
  appearance_settings: {
    theme: string;
    compact_mode: boolean;
  };
  integration_settings: {
    google_drive_enabled: boolean;
    zapier_enabled: boolean;
    n8n_webhook_url?: string;
  };
}

const defaultSettings: OrganizationSettings = {
  general_settings: {
    timezone: "America/Santiago",
    language: "es",
    logo_url: undefined,
    description: undefined
  },
  instagram_settings: {
    auto_sync: true,
    sync_interval: "hourly",
    auto_validate_tasks: false,
    story_validation_24h: true
  },
  notification_settings: {
    email_notifications: true,
    push_notifications: true,
    token_expiry_alerts: true,
    weekly_reports: false
  },
  permission_settings: {
    allow_ambassador_self_registration: false,
    require_approval_for_tasks: true,
    auto_validate_tasks: false
  },
  appearance_settings: {
    theme: "system",
    compact_mode: false
  },
  integration_settings: {
    google_drive_enabled: false,
    zapier_enabled: false,
    n8n_webhook_url: undefined
  }
};

export function useOrganizationSettings() {
  const { organization } = useCurrentOrganization();
  const [settings, setSettings] = useState<OrganizationSettings>(defaultSettings);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  useEffect(() => {
    if (organization?.id) {
      loadSettings();
    }
  }, [organization?.id]);

  const loadSettings = async () => {
    if (!organization?.id) return;

    try {
      setLoading(true);
      
      const { data, error } = await supabase
        .from('organization_settings')
        .select('id, organization_id, general_settings, appearance_settings, notification_settings, instagram_settings, integration_settings, permission_settings, created_at, updated_at')
        .eq('organization_id', organization.id)
        .maybeSingle();

      if (error) throw error;

      if (data) {
        const generalSettings = data.general_settings as any || {};
        const instagramSettings = data.instagram_settings as any || {};
        const notificationSettings = data.notification_settings as any || {};
        const permissionSettings = data.permission_settings as any || {};
        const appearanceSettings = data.appearance_settings as any || {};
        const integrationSettings = data.integration_settings as any || {};
        
        const mergedSettings: OrganizationSettings = {
          general_settings: { ...defaultSettings.general_settings, ...generalSettings },
          instagram_settings: { ...defaultSettings.instagram_settings, ...instagramSettings },
          notification_settings: { ...defaultSettings.notification_settings, ...notificationSettings },
          permission_settings: { ...defaultSettings.permission_settings, ...permissionSettings },
          appearance_settings: { ...defaultSettings.appearance_settings, ...appearanceSettings },
          integration_settings: { ...defaultSettings.integration_settings, ...integrationSettings }
        };
        setSettings(mergedSettings);
      } else {
        // Create default settings if none exist
        await createDefaultSettings();
      }
    } catch (error) {
      console.error('Error loading organization settings:', error);
      toast.error('Error al cargar configuraciones');
    } finally {
      setLoading(false);
    }
  };

  const createDefaultSettings = async () => {
    if (!organization?.id) return;

    try {
      const { error } = await supabase
        .from('organization_settings')
        .insert({
          organization_id: organization.id,
          general_settings: defaultSettings.general_settings,
          instagram_settings: defaultSettings.instagram_settings,
          notification_settings: defaultSettings.notification_settings,
          permission_settings: defaultSettings.permission_settings,
          appearance_settings: defaultSettings.appearance_settings,
          integration_settings: defaultSettings.integration_settings
        });

      if (error) throw error;
      
      setSettings(defaultSettings);
    } catch (error) {
      console.error('Error creating default settings:', error);
    }
  };

  const updateSettings = async (section: keyof OrganizationSettings, newSettings: any) => {
    if (!organization?.id) return;

    try {
      setSaving(true);

      const updatedSettings = {
        ...settings,
        [section]: { ...settings[section], ...newSettings }
      };

      const { error } = await supabase
        .from('organization_settings')
        .update({ [section]: updatedSettings[section] })
        .eq('organization_id', organization.id);

      if (error) throw error;

      setSettings(updatedSettings);
      toast.success('Configuraci√≥n guardada exitosamente');
    } catch (error) {
      console.error('Error updating settings:', error);
      toast.error('Error al guardar configuraci√≥n');
    } finally {
      setSaving(false);
    }
  };

  const updateGeneralSettings = (newSettings: Partial<OrganizationSettings['general_settings']>) => {
    return updateSettings('general_settings', newSettings);
  };

  const updateInstagramSettings = (newSettings: Partial<OrganizationSettings['instagram_settings']>) => {
    return updateSettings('instagram_settings', newSettings);
  };

  const updateNotificationSettings = (newSettings: Partial<OrganizationSettings['notification_settings']>) => {
    return updateSettings('notification_settings', newSettings);
  };

  const updatePermissionSettings = (newSettings: Partial<OrganizationSettings['permission_settings']>) => {
    return updateSettings('permission_settings', newSettings);
  };

  const updateAppearanceSettings = (newSettings: Partial<OrganizationSettings['appearance_settings']>) => {
    return updateSettings('appearance_settings', newSettings);
  };

  const updateIntegrationSettings = (newSettings: Partial<OrganizationSettings['integration_settings']>) => {
    return updateSettings('integration_settings', newSettings);
  };

  return {
    settings,
    loading,
    saving,
    updateGeneralSettings,
    updateInstagramSettings,
    updateNotificationSettings,
    updatePermissionSettings,
    updateAppearanceSettings,
    updateIntegrationSettings,
    refreshSettings: loadSettings
  };
}
</file>

<file path="src/hooks/useRealEventLogs.ts">
import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useCurrentOrganization } from './useCurrentOrganization';

interface EventLog {
  id: string;
  type: string;
  message: string;
  timestamp: string;
  details?: string;
  entity_type?: string;
  entity_id?: string;
}

export function useRealEventLogs() {
  const { organization } = useCurrentOrganization();
  const [logs, setLogs] = useState<EventLog[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (organization?.id) {
      fetchEventLogs();
    }
  }, [organization?.id]);

  const fetchEventLogs = async () => {
    if (!organization?.id) return;

    try {
      setLoading(true);

      // Generate event logs based on recent activity
      const logs: EventLog[] = [];

      // Recent ambassador activity
      const { data: recentAmbassadors } = await supabase
        .from('embassadors')
        .select('id, first_name, last_name, created_at, status')
        .eq('organization_id', organization.id)
        .order('created_at', { ascending: false })
        .limit(5);

      recentAmbassadors?.forEach(amb => {
        logs.push({
          id: `amb-${amb.id}`,
          type: amb.status === 'pending' ? 'warning' : 'info',
          message: `Embajador ${amb.first_name} ${amb.last_name} ${amb.status === 'pending' ? 'pendiente de aprobaci√≥n' : 'registrado'}`,
          timestamp: amb.created_at,
          entity_type: 'ambassador',
          entity_id: amb.id
        });
      });

      // Recent task activity
      const { data: ambassadors } = await supabase
        .from('embassadors')
        .select('id')
        .eq('organization_id', organization.id);

      if (ambassadors && ambassadors.length > 0) {
        const { data: recentTasks } = await supabase
          .from('tasks')
          .select('id, status, created_at, last_status_update, embassador_id, embassadors(first_name, last_name)')
          .in('embassador_id', ambassadors.map(a => a.id))
          .order('last_status_update', { ascending: false })
          .limit(10);

        recentTasks?.forEach(task => {
          const ambassador = task.embassadors as any;
          logs.push({
            id: `task-${task.id}`,
            type: task.status === 'completed' ? 'success' : 
                  task.status === 'invalid' ? 'error' : 'info',
            message: `Tarea ${task.status} por ${ambassador?.first_name} ${ambassador?.last_name}`,
            timestamp: task.last_status_update || task.created_at,
            entity_type: 'task',
            entity_id: task.id
          });
        });
      }

      // Recent fiestas activity
      const { data: recentFiestas } = await supabase
        .from('fiestas')
        .select('id, name, created_at, status')
        .eq('organization_id', organization.id)
        .order('created_at', { ascending: false })
        .limit(3);

      recentFiestas?.forEach(fiesta => {
        logs.push({
          id: `fiesta-${fiesta.id}`,
          type: 'info',
          message: `Fiesta "${fiesta.name}" ${fiesta.status}`,
          timestamp: fiesta.created_at,
          entity_type: 'fiesta',
          entity_id: fiesta.id
        });
      });

      // Sort all logs by timestamp
      logs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

      setLogs(logs.slice(0, 20)); // Keep only 20 most recent
    } catch (error) {
      console.error('Error fetching event logs:', error);
    } finally {
      setLoading(false);
    }
  };

  return {
    logs,
    loading,
    refreshLogs: fetchEventLogs
  };
}
</file>

<file path="src/hooks/useRealNotifications.ts">
import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useCurrentOrganization } from './useCurrentOrganization';

interface Notification {
  id: string;
  type: string;
  message: string;
  priority: string;
  read_status: boolean;
  created_at: string;
  target_type?: string;
  target_id?: string;
}

export function useRealNotifications() {
  const { organization } = useCurrentOrganization();
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (organization?.id) {
      fetchNotifications();
      setupRealtimeSubscription();
    }
  }, [organization?.id]);

  const fetchNotifications = async () => {
    if (!organization?.id) return;

    try {
      const { data, error } = await supabase
        .from('notifications')
        .select('id, organization_id, type, message, target_type, target_id, read_status, priority, created_at')
        .eq('organization_id', organization.id)
        .order('created_at', { ascending: false })
        .limit(20);

      if (error) throw error;

      const notificationData = data || [];
      setNotifications(notificationData);
      setUnreadCount(notificationData.filter(n => !n.read_status).length);
    } catch (error) {
      console.error('Error fetching notifications:', error);
    } finally {
      setLoading(false);
    }
  };

  const setupRealtimeSubscription = () => {
    if (!organization?.id) return;

    const subscription = supabase
      .channel('notifications')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'notifications',
        filter: `organization_id=eq.${organization.id}`
      }, (payload) => {
        if (payload.eventType === 'INSERT') {
          setNotifications(prev => [payload.new as Notification, ...prev].slice(0, 20));
          if (!(payload.new as Notification).read_status) {
            setUnreadCount(prev => prev + 1);
          }
        } else if (payload.eventType === 'UPDATE') {
          setNotifications(prev => 
            prev.map(n => n.id === payload.new.id ? payload.new as Notification : n)
          );
          fetchNotifications(); // Refresh to update counts
        }
      })
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  };

  const markAsRead = async (notificationId: string) => {
    try {
      const { error } = await supabase
        .from('notifications')
        .update({ read_status: true })
        .eq('id', notificationId);

      if (error) throw error;

      setNotifications(prev =>
        prev.map(n => n.id === notificationId ? { ...n, read_status: true } : n)
      );
      setUnreadCount(prev => Math.max(0, prev - 1));
    } catch (error) {
      console.error('Error marking notification as read:', error);
    }
  };

  const markAllAsRead = async () => {
    if (!organization?.id) return;

    try {
      const { error } = await supabase
        .from('notifications')
        .update({ read_status: true })
        .eq('organization_id', organization.id)
        .eq('read_status', false);

      if (error) throw error;

      setNotifications(prev =>
        prev.map(n => ({ ...n, read_status: true }))
      );
      setUnreadCount(0);
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
    }
  };

  return {
    notifications,
    unreadCount,
    loading,
    markAsRead,
    markAllAsRead,
    refreshNotifications: fetchNotifications
  };
}
</file>

<file path="src/hooks/useRealtimeCards.ts">
import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';

interface SimpleActivity {
  id: string;
  type: string;
  message: string;
  created_at: string;
}

export const useRealtimeCards = () => {
  const [cards, setCards] = useState<SimpleActivity[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const generateActivities = async () => {
      try {
        const { data: user } = await supabase.auth.getUser();
        if (!user.user) return;

        // Generar actividades basadas en los datos existentes
        const activities: SimpleActivity[] = [];

        // Verificar organizaciones del usuario
        const { data: organizations, error: orgError } = await supabase
          .from('organizations')
          .select('id, name, description, timezone, logo_url, plan_type, instagram_username, facebook_page_id, instagram_business_account_id, instagram_user_id, last_instagram_sync, created_by, created_at')
          .eq('created_by', user.user.id);

        if (!orgError && organizations && organizations.length > 0) {
          activities.push({
            id: `org-summary`,
            type: 'success',
            message: `Dashboard cargado: ${organizations.length} organizaci√≥n(es) activa(s)`,
            created_at: new Date().toISOString()
          });
        }

        setCards(activities);
      } catch (error) {
        console.error('Error generating activities:', error);
      } finally {
        setLoading(false);
      }
    };

    generateActivities();
  }, []);

  const markAsRead = async (cardId: string) => {
    setCards(prev => prev.filter(card => card.id !== cardId));
    toast.success('Actividad marcada como le√≠da');
  };

  const refreshCards = async () => {
    setLoading(true);
    // Simular refresh
    setTimeout(() => {
      setLoading(false);
      toast.success('Actividades actualizadas');
    }, 500);
  };

  return { cards, loading, markAsRead, refreshCards };
};
</file>

<file path="src/hooks/useRealtimeSocialMentions.ts">
import { useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useCurrentOrganization } from './useCurrentOrganization';
import { toast } from 'sonner';

interface RealtimeSocialMentionsProps {
  onNewMention?: (mention: any) => void;
  onMentionUpdated?: (mention: any) => void;
  onNewAmbassadorRequest?: (request: any) => void;
}

export function useRealtimeSocialMentions({ 
  onNewMention, 
  onMentionUpdated, 
  onNewAmbassadorRequest 
}: RealtimeSocialMentionsProps = {}) {
  const { organization } = useCurrentOrganization();

  useEffect(() => {
    if (!organization) return;

    // Subscribe to social mentions changes
    const socialMentionsChannel = supabase
      .channel(`social_mentions_${organization.id}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'social_mentions',
          filter: `organization_id=eq.${organization.id}`
        },
        (payload) => {
          console.log('New social mention:', payload);
          
          // Show notification based on mention type
          const mentionType = payload.new.mention_type;
          const username = payload.new.instagram_username;
          
          let message = '';
          switch (mentionType) {
            case 'story':
              message = `üì± Nueva historia de @${username}`;
              break;
            case 'comment':
              message = `üí¨ Nuevo comentario de @${username}`;
              break;
            case 'mention':
              message = `üîî Nueva menci√≥n de @${username}`;
              break;
            case 'hashtag':
              message = `#Ô∏è‚É£ Nuevo hashtag de @${username}`;
              break;
            default:
              message = `üì£ Nueva actividad de @${username}`;
          }

          if (payload.new.matched_ambassador_id) {
            toast.success(message, {
              description: 'Menci√≥n asignada a embajador'
            });
          } else {
            toast.info(message, {
              description: 'Menci√≥n sin asignar - revisar solicitudes'
            });
          }

          onNewMention?.(payload.new);
        }
      )
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'social_mentions',
          filter: `organization_id=eq.${organization.id}`
        },
        (payload) => {
          console.log('Social mention updated:', payload);
          
          // Show notification when mention is processed/assigned
          if (payload.new.processed && !payload.old.processed) {
            toast.success('Menci√≥n procesada', {
              description: `Asignada a embajador`
            });
          }

          onMentionUpdated?.(payload.new);
        }
      )
      .subscribe();

    // Subscribe to ambassador requests changes
    const ambassadorRequestsChannel = supabase
      .channel(`ambassador_requests_${organization.id}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'ambassador_requests',
          filter: `organization_id=eq.${organization.id}`
        },
        (payload) => {
          console.log('New ambassador request:', payload);
          
          toast.info('üôã‚Äç‚ôÇÔ∏è Nueva solicitud de embajador', {
            description: `@${payload.new.instagram_username} quiere ser embajador`,
            action: {
              label: 'Ver solicitudes',
              onClick: () => {
                // This could navigate to ambassador requests tab
                window.location.hash = '#ambassadors-requests';
              }
            }
          });

          onNewAmbassadorRequest?.(payload.new);
        }
      )
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'ambassador_requests',
          filter: `organization_id=eq.${organization.id}`
        },
        (payload) => {
          console.log('Ambassador request updated:', payload);
          
          // Show notification when request is approved/rejected
          if (payload.new.status !== payload.old.status) {
            if (payload.new.status === 'approved') {
              toast.success('‚úÖ Embajador aprobado', {
                description: `@${payload.new.instagram_username} es ahora embajador`
              });
            } else if (payload.new.status === 'rejected') {
              toast.error('‚ùå Solicitud rechazada', {
                description: `@${payload.new.instagram_username}`
              });
            }
          }
        }
      )
      .subscribe();

    // Cleanup subscriptions
    return () => {
      supabase.removeChannel(socialMentionsChannel);
      supabase.removeChannel(ambassadorRequestsChannel);
    };
  }, [organization, onNewMention, onMentionUpdated, onNewAmbassadorRequest]);

  return null; // This hook doesn't return any value, just manages subscriptions
}
</file>

<file path="src/hooks/useStoryMentions.ts">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { useToast } from "@/hooks/use-toast";
import { StoryMention } from "@/types/storyMentions";

type StoryMentionState = 'new' | 'flagged_early_delete' | 'completed' | 'expired_unknown';

const validateState = (state: unknown): StoryMentionState => {
  const validStates: StoryMentionState[] = ['new', 'flagged_early_delete', 'completed', 'expired_unknown'];
  return validStates.includes(state as StoryMentionState) ? (state as StoryMentionState) : 'new';
};

export function useStoryMentions() {
  const [mentions, setMentions] = useState<StoryMention[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { organization } = useCurrentOrganization();
  const { toast } = useToast();

  const fetchStoryMentions = async () => {
    if (!organization?.id) return;

    try {
      setLoading(true);
      setError(null);

      // Fetch story mentions with related ambassador info
      const { data, error } = await supabase
        .from('social_mentions')
        .select(`
          id,
          instagram_username,
          instagram_user_id,
          content,
          created_at,
          processed,
          raw_data,
          recipient_page_id,
          external_event_id,
          story_url,
          instagram_story_id,
          mentioned_at,
          expires_at,
          state,
          deep_link,
          checks_count,
          last_check_at,
          conversation_id,
          inbox_link,
          embassadors!matched_ambassador_id (
            first_name,
            last_name
          )
        `)
        .eq('organization_id', organization.id)
        .eq('mention_type', 'story_referral')
        .order('mentioned_at', { ascending: false });

      if (error) {
        console.error('Error fetching story mentions:', error);
        setError(error.message);
        return;
      }

      // Transform data to match our interface
      const mentionsData: StoryMention[] = (data || []).map(mention => ({
        id: mention.id,
        instagram_username: mention.instagram_username || 'unknown',
        instagram_user_id: mention.instagram_user_id || '',
        content: mention.content || '',
        created_at: mention.created_at,
        processed: mention.processed,
        ambassador_name: mention.embassadors ? 
          `${mention.embassadors.first_name} ${mention.embassadors.last_name}` : 
          undefined,
        raw_data: mention.raw_data,
        recipient_page_id: mention.recipient_page_id || undefined,
        external_event_id: mention.external_event_id || undefined,
        story_url: mention.story_url || undefined,
        instagram_story_id: mention.instagram_story_id || undefined,
        mentioned_at: mention.mentioned_at,
        expires_at: mention.expires_at || undefined,
        state: validateState(mention.state),
        deep_link: mention.deep_link || undefined,
        checks_count: mention.checks_count || 0,
        last_check_at: mention.last_check_at || undefined,
        conversation_id: mention.conversation_id || undefined,
        inbox_link: mention.inbox_link || undefined
      }));

      setMentions(mentionsData);
    } catch (err) {
      console.error('Error in fetchStoryMentions:', err);
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  };

  const markAsProcessed = async (mentionId: string) => {
    try {
      const { error } = await supabase
        .from('social_mentions')
        .update({ 
          processed: true,
          processed_at: new Date().toISOString()
        })
        .eq('id', mentionId);

      if (error) {
        throw error;
      }

      // Update local state
      setMentions(prev => 
        prev.map(mention => 
          mention.id === mentionId 
            ? { ...mention, processed: true }
            : mention
        )
      );

      toast({
        title: "Menci√≥n actualizada",
        description: "La menci√≥n ha sido marcada como atendida"
      });
    } catch (error) {
      console.error('Error marking mention as processed:', error);
      toast({
        title: "Error",
        description: "No se pudo actualizar la menci√≥n",
        variant: "destructive"
      });
      throw error;
    }
  };

  const flagAsEarlyDelete = async (mentionId: string) => {
    try {
      const { error } = await supabase
        .from('social_mentions')
        .update({ 
          state: 'flagged_early_delete',
          processed: true,
          processed_at: new Date().toISOString()
        })
        .eq('id', mentionId);

      if (error) {
        throw error;
      }

      // Update local state
      setMentions(prev => 
        prev.map(mention => 
          mention.id === mentionId 
            ? { ...mention, state: 'flagged_early_delete', processed: true }
            : mention
        )
      );

      // Create notification for early deletion
      await supabase
        .from('notifications')
        .insert({
          organization_id: organization?.id,
          type: 'story_early_delete',
          message: `Historia marcada como borrada antes de 24h`,
          target_type: 'story_mention',
          target_id: mentionId,
          priority: 'medium'
        });

      toast({
        title: "Menci√≥n marcada",
        description: "La historia ha sido marcada como borrada antes de 24h"
      });
    } catch (error) {
      console.error('Error flagging mention as early delete:', error);
      toast({
        title: "Error",
        description: "No se pudo marcar la menci√≥n",
        variant: "destructive"
      });
      throw error;
    }
  };

  const sendReply = async (mention: StoryMention, message: string) => {
    if (!organization?.id) {
      throw new Error('Organization not found');
    }

    try {
      // Call the Instagram send message edge function
      const { data, error } = await supabase.functions.invoke('instagram-send-message', {
        body: {
          recipientId: mention.instagram_user_id,
          message: message,
          organizationId: organization.id
        }
      });

      if (error) {
        throw error;
      }

      if (!data.success) {
        throw new Error(data.error || 'Failed to send message');
      }

      // Optionally mark as processed after successful reply
      await markAsProcessed(mention.id);

      return data;
    } catch (error) {
      console.error('Error sending reply:', error);
      throw error;
    }
  };

  // Set up real-time subscription for new story mentions
  useEffect(() => {
    if (!organization?.id) return;

    const channel = supabase
      .channel(`story-mentions-${organization.id}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'social_mentions',
          filter: `organization_id=eq.${organization.id}`
        },
        (payload) => {
          console.log('New story mention received:', payload);
          // Only handle story referrals
          if (payload.new.mention_type === 'story_referral') {
            fetchStoryMentions(); // Refresh the list
            toast({
              title: "Nueva menci√≥n de historia",
              description: `@${payload.new.instagram_username || 'Usuario desconocido'} mencion√≥ tu historia`
            });
          }
        }
      )
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'social_mentions',
          filter: `organization_id=eq.${organization.id}`
        },
        (payload) => {
          console.log('Story mention updated:', payload);
          // Only handle story referrals
          if (payload.new.mention_type === 'story_referral') {
            fetchStoryMentions(); // Refresh the list
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [organization?.id, toast]);

  // Fetch mentions when organization changes
  useEffect(() => {
    fetchStoryMentions();
  }, [organization?.id]);

  return {
    mentions,
    loading,
    error,
    fetchStoryMentions,
    markAsProcessed,
    flagAsEarlyDelete,
    sendReply
  };
}
</file>

<file path="src/hooks/useTasksManagement.ts">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useUserProfile } from "./useUserProfile";
import { toast } from "sonner";

interface Task {
  id: string;
  embassador_id: string;
  event_id: string;
  task_type: 'story' | 'mention' | 'repost';
  platform: string;
  expected_hashtag: string | null;
  status: 'pending' | 'uploaded' | 'in_progress' | 'completed' | 'invalid' | 'expired';
  instagram_story_id: string | null;
  story_url: string | null;
  upload_time: string | null;
  expiry_time: string | null;
  completion_method: '24h_validation' | 'manual';
  engagement_score: number;
  reach_count: number;
  verified_through_api: boolean;
  points_earned: number;
  last_status_update: string;
  created_at: string;
  embassadors?: {
    first_name: string;
    last_name: string;
    instagram_user: string;
  };
  events?: {
    id: string;
    fiesta_id: string;
    fiestas?: {
      name: string;
    };
  };
}

interface TaskStats {
  total: number;
  completed: number;
  pending: number;
  invalid: number;
  totalPoints: number;
  completionRate: number;
}

export function useTasksManagement() {
  const { profile } = useUserProfile();
  const [tasks, setTasks] = useState<Task[]>([]);
  const [stats, setStats] = useState<TaskStats>({
    total: 0,
    completed: 0,
    pending: 0,
    invalid: 0,
    totalPoints: 0,
    completionRate: 0
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (profile?.organization_id) {
      fetchTasks();
    }
  }, [profile?.organization_id]);

  const fetchTasks = async () => {
    if (!profile?.organization_id) return;

    try {
      setLoading(true);
      setError(null);

      const { data, error: fetchError } = await supabase
        .from('tasks')
        .select(`
          *,
          embassadors (
            first_name,
            last_name,
            instagram_user,
            organization_id
          ),
          events (
            id,
            fiesta_id,
            fiestas (
              name
            )
          )
        `)
        .eq('embassadors.organization_id', profile.organization_id)
        .order('created_at', { ascending: false });

      if (fetchError) {
        console.error('Error fetching tasks:', fetchError);
        setError('Error al cargar tareas');
        return;
      }

      // Type assertion to ensure proper typing
      const tasksData = (data || []).map(task => ({
        ...task,
        task_type: task.task_type as 'story' | 'mention' | 'repost',
        status: task.status as 'pending' | 'uploaded' | 'in_progress' | 'completed' | 'invalid' | 'expired',
        completion_method: task.completion_method as '24h_validation' | 'manual'
      }));
      
      setTasks(tasksData);

      // Calcular estad√≠sticas
      const completed = tasksData.filter(t => t.status === 'completed').length;
      const pending = tasksData.filter(t => ['pending', 'uploaded', 'in_progress'].includes(t.status)).length;
      const invalid = tasksData.filter(t => ['invalid', 'expired'].includes(t.status)).length;
      const totalPoints = tasksData.reduce((sum, t) => sum + t.points_earned, 0);
      const completionRate = tasksData.length > 0 ? (completed / tasksData.length) * 100 : 0;

      setStats({
        total: tasksData.length,
        completed,
        pending,
        invalid,
        totalPoints,
        completionRate: Math.round(completionRate * 100) / 100
      });

    } catch (err) {
      console.error('Error fetching tasks:', err);
      setError('Error inesperado al cargar tareas');
    } finally {
      setLoading(false);
    }
  };

  const createTask = async (taskData: {
    embassador_id: string;
    event_id: string;
    task_type: 'story' | 'mention' | 'repost';
    expected_hashtag?: string;
  }) => {
    try {
      const { data, error } = await supabase
        .from('tasks')
        .insert({
          ...taskData,
          status: 'pending',
          created_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) {
        console.error('Error creating task:', error);
        toast.error('Error al crear tarea');
        return null;
      }

      toast.success('Tarea creada exitosamente');
      fetchTasks(); // Refrescar lista
      return data;

    } catch (err) {
      console.error('Error creating task:', err);
      toast.error('Error al crear tarea');
      return null;
    }
  };

  const updateTaskStatus = async (taskId: string, status: Task['status'], points?: number) => {
    try {
      const updateData: any = {
        status,
        last_status_update: new Date().toISOString()
      };

      if (points !== undefined) {
        updateData.points_earned = points;
      }

      const { error } = await supabase
        .from('tasks')
        .update(updateData)
        .eq('id', taskId);

      if (error) {
        console.error('Error updating task:', error);
        toast.error('Error al actualizar tarea');
        return false;
      }

      toast.success('Tarea actualizada correctamente');
      fetchTasks(); // Refrescar lista
      return true;

    } catch (err) {
      console.error('Error updating task:', err);
      toast.error('Error al actualizar tarea');
      return false;
    }
  };

  const deleteTask = async (taskId: string) => {
    try {
      const { error } = await supabase
        .from('tasks')
        .delete()
        .eq('id', taskId);

      if (error) {
        console.error('Error deleting task:', error);
        toast.error('Error al eliminar tarea');
        return false;
      }

      toast.success('Tarea eliminada correctamente');
      fetchTasks(); // Refrescar lista
      return true;

    } catch (err) {
      console.error('Error deleting task:', err);
      toast.error('Error al eliminar tarea');
      return false;
    }
  };

  return {
    tasks,
    stats,
    loading,
    error,
    createTask,
    updateTaskStatus,
    deleteTask,
    refreshTasks: fetchTasks
  };
}
</file>

<file path="src/i18n/index.ts">
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

// Translation resources
const resources = {
  es: {
    common: {
      // Navigation
      dashboard: 'Dashboard',
      stories: 'Historias',
      mentions: 'Menciones',
      storyMentions: 'Menciones Historias',
      analytics: 'Anal√≠ticas',
      events: 'Fiestas',
      ambassadors: 'Embajadores',
      profile: 'Mi Perfil',
      settings: 'Configuraciones',
      notifications: 'Notificaciones',
      importExport: 'Import/Export',
      
      // Common actions
      save: 'Guardar',
      cancel: 'Cancelar',
      delete: 'Eliminar',
      edit: 'Editar',
      view: 'Ver',
      add: 'Agregar',
      create: 'Crear',
      update: 'Actualizar',
      search: 'Buscar',
      filter: 'Filtrar',
      export: 'Exportar',
      import: 'Importar',
      
      // Status
      active: 'Activo',
      inactive: 'Inactivo',
      pending: 'Pendiente',
      completed: 'Completado',
      progress: 'En progreso',
      
      // Common phrases
      loading: 'Cargando...',
      noData: 'No hay datos disponibles',
      error: 'Ocurri√≥ un error',
      success: 'Operaci√≥n exitosa',
      
      // Fiesta/Event related
      selectEvent: 'Seleccionar Fiesta',
      noEventSelected: 'No hay fiesta seleccionada',
      allEvents: 'Todas las Fiestas',
    }
  },
  en: {
    common: {
      // Navigation
      dashboard: 'Dashboard',
      stories: 'Stories',
      mentions: 'Mentions',
      storyMentions: 'Story Mentions',
      analytics: 'Analytics',
      events: 'Events',
      ambassadors: 'Ambassadors',
      profile: 'My Profile',
      settings: 'Settings',
      notifications: 'Notifications',
      importExport: 'Import/Export',
      
      // Common actions
      save: 'Save',
      cancel: 'Cancel',
      delete: 'Delete',
      edit: 'Edit',
      view: 'View',
      add: 'Add',
      create: 'Create',
      update: 'Update',
      search: 'Search',
      filter: 'Filter',
      export: 'Export',
      import: 'Import',
      
      // Status
      active: 'Active',
      inactive: 'Inactive',
      pending: 'Pending',
      completed: 'Completed',
      progress: 'In Progress',
      
      // Common phrases
      loading: 'Loading...',
      noData: 'No data available',
      error: 'An error occurred',
      success: 'Operation successful',
      
      // Fiesta/Event related
      selectEvent: 'Select Event',
      noEventSelected: 'No event selected',
      allEvents: 'All Events',
    }
  }
};

i18n
  .use(initReactI18next)
  .init({
    resources,
    lng: localStorage.getItem('eva-language') || 'es', // Default to Spanish
    fallbackLng: 'es',
    
    interpolation: {
      escapeValue: false, // React already does escaping
    },
    
    react: {
      useSuspense: false, // Disable suspense to avoid loading issues
    }
  });

export default i18n;
</file>

<file path="src/integrations/supabase/client.ts">
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://awpfslcepylnipaolmvv.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF3cGZzbGNlcHlsbmlwYW9sbXZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3NTUzOTUsImV4cCI6MjA2OTMzMTM5NX0.KyXrezLFMXhsOr3zyrNm1nb1T3w6C6R3WdJZ2w21oOY";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
});
</file>

<file path="src/integrations/supabase/types.ts">
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: "12.2.12 (cd3cf9e)"
  }
  public: {
    Tables: {
      ambassador_requests: {
        Row: {
          bio: string | null
          created_at: string
          follower_count: number | null
          id: string
          instagram_user_id: string | null
          instagram_username: string
          last_mention_at: string | null
          notes: string | null
          organization_id: string
          processed_at: string | null
          processed_by_user_id: string | null
          profile_picture_url: string | null
          rejection_reason: string | null
          source_mention_ids: string[] | null
          status: string | null
          total_mentions: number | null
        }
        Insert: {
          bio?: string | null
          created_at?: string
          follower_count?: number | null
          id?: string
          instagram_user_id?: string | null
          instagram_username: string
          last_mention_at?: string | null
          notes?: string | null
          organization_id: string
          processed_at?: string | null
          processed_by_user_id?: string | null
          profile_picture_url?: string | null
          rejection_reason?: string | null
          source_mention_ids?: string[] | null
          status?: string | null
          total_mentions?: number | null
        }
        Update: {
          bio?: string | null
          created_at?: string
          follower_count?: number | null
          id?: string
          instagram_user_id?: string | null
          instagram_username?: string
          last_mention_at?: string | null
          notes?: string | null
          organization_id?: string
          processed_at?: string | null
          processed_by_user_id?: string | null
          profile_picture_url?: string | null
          rejection_reason?: string | null
          source_mention_ids?: string[] | null
          status?: string | null
          total_mentions?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_ambassador_requests_organization"
            columns: ["organization_id"]
            isOneToOne: false
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
        ]
      }
      ambassador_tokens: {
        Row: {
          access_token: string
          created_at: string
          embassador_id: string
          id: string
          token_expiry: string | null
          updated_at: string
        }
        Insert: {
          access_token: string
          created_at?: string
          embassador_id: string
          id?: string
          token_expiry?: string | null
          updated_at?: string
        }
        Update: {
          access_token?: string
          created_at?: string
          embassador_id?: string
          id?: string
          token_expiry?: string | null
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "ambassador_tokens_embassador_id_fkey"
            columns: ["embassador_id"]
            isOneToOne: true
            referencedRelation: "embassadors"
            referencedColumns: ["id"]
          },
        ]
      }
      embassadors: {
        Row: {
          completed_tasks: number | null
          created_at: string | null
          created_by_user_id: string | null
          date_of_birth: string | null
          email: string
          events_participated: number | null
          failed_tasks: number | null
          first_name: string
          follower_count: number | null
          global_category: string | null
          global_points: number | null
          id: string
          instagram_access_token: string | null
          instagram_user: string
          instagram_user_id: string | null
          last_instagram_sync: string | null
          last_name: string
          organization_id: string
          performance_status: string | null
          profile_picture_url: string | null
          profile_public: boolean | null
          rut: string | null
          status: string | null
          token_expires_at: string | null
        }
        Insert: {
          completed_tasks?: number | null
          created_at?: string | null
          created_by_user_id?: string | null
          date_of_birth?: string | null
          email: string
          events_participated?: number | null
          failed_tasks?: number | null
          first_name: string
          follower_count?: number | null
          global_category?: string | null
          global_points?: number | null
          id?: string
          instagram_access_token?: string | null
          instagram_user: string
          instagram_user_id?: string | null
          last_instagram_sync?: string | null
          last_name: string
          organization_id: string
          performance_status?: string | null
          profile_picture_url?: string | null
          profile_public?: boolean | null
          rut?: string | null
          status?: string | null
          token_expires_at?: string | null
        }
        Update: {
          completed_tasks?: number | null
          created_at?: string | null
          created_by_user_id?: string | null
          date_of_birth?: string | null
          email?: string
          events_participated?: number | null
          failed_tasks?: number | null
          first_name?: string
          follower_count?: number | null
          global_category?: string | null
          global_points?: number | null
          id?: string
          instagram_access_token?: string | null
          instagram_user?: string
          instagram_user_id?: string | null
          last_instagram_sync?: string | null
          last_name?: string
          organization_id?: string
          performance_status?: string | null
          profile_picture_url?: string | null
          profile_public?: boolean | null
          rut?: string | null
          status?: string | null
          token_expires_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "embassadors_created_by_user_id_fkey"
            columns: ["created_by_user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "embassadors_organization_id_fkey"
            columns: ["organization_id"]
            isOneToOne: false
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
        ]
      }
      events: {
        Row: {
          active: boolean | null
          created_at: string | null
          created_by_user_id: string | null
          end_date: string | null
          event_date: string
          fiesta_id: string | null
          id: string
          start_date: string | null
        }
        Insert: {
          active?: boolean | null
          created_at?: string | null
          created_by_user_id?: string | null
          end_date?: string | null
          event_date: string
          fiesta_id?: string | null
          id?: string
          start_date?: string | null
        }
        Update: {
          active?: boolean | null
          created_at?: string | null
          created_by_user_id?: string | null
          end_date?: string | null
          event_date?: string
          fiesta_id?: string | null
          id?: string
          start_date?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "events_created_by_user_id_fkey"
            columns: ["created_by_user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "events_fiesta_id_fkey"
            columns: ["fiesta_id"]
            isOneToOne: false
            referencedRelation: "fiestas"
            referencedColumns: ["id"]
          },
        ]
      }
      fiestas: {
        Row: {
          created_at: string | null
          description: string | null
          event_date: string | null
          id: string
          instagram_handle: string | null
          location: string | null
          main_hashtag: string | null
          name: string
          organization_id: string
          secondary_hashtags: string[] | null
          status: string | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          event_date?: string | null
          id?: string
          instagram_handle?: string | null
          location?: string | null
          main_hashtag?: string | null
          name: string
          organization_id: string
          secondary_hashtags?: string[] | null
          status?: string | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          event_date?: string | null
          id?: string
          instagram_handle?: string | null
          location?: string | null
          main_hashtag?: string | null
          name?: string
          organization_id?: string
          secondary_hashtags?: string[] | null
          status?: string | null
          updated_at?: string | null
        }
        Relationships: []
      }
      import_logs: {
        Row: {
          created_at: string | null
          file_name: string | null
          id: string
          organization_id: string
          result_json: Json | null
          source: string | null
          status: string | null
          type: string
          user_id: string
        }
        Insert: {
          created_at?: string | null
          file_name?: string | null
          id?: string
          organization_id: string
          result_json?: Json | null
          source?: string | null
          status?: string | null
          type: string
          user_id: string
        }
        Update: {
          created_at?: string | null
          file_name?: string | null
          id?: string
          organization_id?: string
          result_json?: Json | null
          source?: string | null
          status?: string | null
          type?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "import_logs_organization_id_fkey"
            columns: ["organization_id"]
            isOneToOne: false
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "import_logs_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      leaderboards: {
        Row: {
          embassador_id: string
          event_id: string
          id: string
          last_updated: string | null
          points: number | null
          rank: number | null
        }
        Insert: {
          embassador_id: string
          event_id: string
          id?: string
          last_updated?: string | null
          points?: number | null
          rank?: number | null
        }
        Update: {
          embassador_id?: string
          event_id?: string
          id?: string
          last_updated?: string | null
          points?: number | null
          rank?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "leaderboards_embassador_id_fkey"
            columns: ["embassador_id"]
            isOneToOne: false
            referencedRelation: "embassadors"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "leaderboards_event_id_fkey"
            columns: ["event_id"]
            isOneToOne: false
            referencedRelation: "events"
            referencedColumns: ["id"]
          },
        ]
      }
      notifications: {
        Row: {
          created_at: string | null
          id: string
          message: string
          organization_id: string
          priority: string | null
          read_status: boolean | null
          target_id: string | null
          target_type: string | null
          type: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          message: string
          organization_id: string
          priority?: string | null
          read_status?: boolean | null
          target_id?: string | null
          target_type?: string | null
          type: string
        }
        Update: {
          created_at?: string | null
          id?: string
          message?: string
          organization_id?: string
          priority?: string | null
          read_status?: boolean | null
          target_id?: string | null
          target_type?: string | null
          type?: string
        }
        Relationships: [
          {
            foreignKeyName: "notifications_organization_id_fkey"
            columns: ["organization_id"]
            isOneToOne: false
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
        ]
      }
      oauth_states: {
        Row: {
          created_at: string
          expires_at: string
          id: string
          organization_id: string | null
          redirect_base: string | null
          state: string
          type: string
          user_id: string | null
        }
        Insert: {
          created_at?: string
          expires_at: string
          id?: string
          organization_id?: string | null
          redirect_base?: string | null
          state: string
          type: string
          user_id?: string | null
        }
        Update: {
          created_at?: string
          expires_at?: string
          id?: string
          organization_id?: string | null
          redirect_base?: string | null
          state?: string
          type?: string
          user_id?: string | null
        }
        Relationships: []
      }
      organization_instagram_tokens: {
        Row: {
          access_token: string
          created_at: string
          id: string
          organization_id: string
          token_expiry: string | null
          updated_at: string
        }
        Insert: {
          access_token: string
          created_at?: string
          id?: string
          organization_id: string
          token_expiry?: string | null
          updated_at?: string
        }
        Update: {
          access_token?: string
          created_at?: string
          id?: string
          organization_id?: string
          token_expiry?: string | null
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "organization_instagram_tokens_organization_id_fkey"
            columns: ["organization_id"]
            isOneToOne: true
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
        ]
      }
      organization_members: {
        Row: {
          id: string
          invited_by: string | null
          joined_at: string
          organization_id: string
          permissions: Json | null
          role: string
          status: string
          user_id: string
        }
        Insert: {
          id?: string
          invited_by?: string | null
          joined_at?: string
          organization_id: string
          permissions?: Json | null
          role?: string
          status?: string
          user_id: string
        }
        Update: {
          id?: string
          invited_by?: string | null
          joined_at?: string
          organization_id?: string
          permissions?: Json | null
          role?: string
          status?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "organization_members_organization_id_fkey"
            columns: ["organization_id"]
            isOneToOne: false
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
        ]
      }
      organization_meta_credentials: {
        Row: {
          created_at: string
          id: string
          meta_app_id: string
          meta_app_secret: string
          organization_id: string
          updated_at: string
          webhook_verify_token: string
        }
        Insert: {
          created_at?: string
          id?: string
          meta_app_id: string
          meta_app_secret: string
          organization_id: string
          updated_at?: string
          webhook_verify_token: string
        }
        Update: {
          created_at?: string
          id?: string
          meta_app_id?: string
          meta_app_secret?: string
          organization_id?: string
          updated_at?: string
          webhook_verify_token?: string
        }
        Relationships: [
          {
            foreignKeyName: "organization_meta_credentials_organization_id_fkey"
            columns: ["organization_id"]
            isOneToOne: true
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
        ]
      }
      organization_settings: {
        Row: {
          appearance_settings: Json | null
          created_at: string | null
          general_settings: Json | null
          id: string
          instagram_settings: Json | null
          integration_settings: Json | null
          notification_settings: Json | null
          organization_id: string
          permission_settings: Json | null
          updated_at: string | null
        }
        Insert: {
          appearance_settings?: Json | null
          created_at?: string | null
          general_settings?: Json | null
          id?: string
          instagram_settings?: Json | null
          integration_settings?: Json | null
          notification_settings?: Json | null
          organization_id: string
          permission_settings?: Json | null
          updated_at?: string | null
        }
        Update: {
          appearance_settings?: Json | null
          created_at?: string | null
          general_settings?: Json | null
          id?: string
          instagram_settings?: Json | null
          integration_settings?: Json | null
          notification_settings?: Json | null
          organization_id?: string
          permission_settings?: Json | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_organization_settings_organization"
            columns: ["organization_id"]
            isOneToOne: true
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
        ]
      }
      organizations: {
        Row: {
          created_at: string | null
          created_by: string | null
          description: string | null
          facebook_page_id: string | null
          id: string
          instagram_business_account_id: string | null
          instagram_user_id: string | null
          instagram_username: string | null
          last_instagram_sync: string | null
          logo_url: string | null
          meta_token: string | null
          name: string
          plan_type: string | null
          timezone: string | null
          token_expiry: string | null
        }
        Insert: {
          created_at?: string | null
          created_by?: string | null
          description?: string | null
          facebook_page_id?: string | null
          id?: string
          instagram_business_account_id?: string | null
          instagram_user_id?: string | null
          instagram_username?: string | null
          last_instagram_sync?: string | null
          logo_url?: string | null
          meta_token?: string | null
          name: string
          plan_type?: string | null
          timezone?: string | null
          token_expiry?: string | null
        }
        Update: {
          created_at?: string | null
          created_by?: string | null
          description?: string | null
          facebook_page_id?: string | null
          id?: string
          instagram_business_account_id?: string | null
          instagram_user_id?: string | null
          instagram_username?: string | null
          last_instagram_sync?: string | null
          logo_url?: string | null
          meta_token?: string | null
          name?: string
          plan_type?: string | null
          timezone?: string | null
          token_expiry?: string | null
        }
        Relationships: []
      }
      plans: {
        Row: {
          created_at: string | null
          features: Json | null
          id: string
          is_active: boolean | null
          max_ambassadors: number | null
          max_events: number | null
          max_users: number | null
          name: string
          price: number | null
          slug: string
        }
        Insert: {
          created_at?: string | null
          features?: Json | null
          id?: string
          is_active?: boolean | null
          max_ambassadors?: number | null
          max_events?: number | null
          max_users?: number | null
          name: string
          price?: number | null
          slug: string
        }
        Update: {
          created_at?: string | null
          features?: Json | null
          id?: string
          is_active?: boolean | null
          max_ambassadors?: number | null
          max_events?: number | null
          max_users?: number | null
          name?: string
          price?: number | null
          slug?: string
        }
        Relationships: []
      }
      social_mentions: {
        Row: {
          checks_count: number | null
          content: string | null
          conversation_id: string | null
          created_at: string
          created_task_id: string | null
          deep_link: string | null
          engagement_score: number | null
          expires_at: string | null
          external_event_id: string | null
          hashtag: string | null
          id: string
          inbox_link: string | null
          instagram_media_id: string | null
          instagram_story_id: string | null
          instagram_user_id: string | null
          instagram_username: string | null
          last_check_at: string | null
          matched_ambassador_id: string | null
          matched_event_id: string | null
          matched_fiesta_id: string | null
          mention_type: string
          mentioned_at: string
          organization_id: string
          platform: string | null
          processed: boolean | null
          processed_at: string | null
          raw_data: Json | null
          reach_count: number | null
          recipient_page_id: string | null
          state: string
          story_url: string | null
        }
        Insert: {
          checks_count?: number | null
          content?: string | null
          conversation_id?: string | null
          created_at?: string
          created_task_id?: string | null
          deep_link?: string | null
          engagement_score?: number | null
          expires_at?: string | null
          external_event_id?: string | null
          hashtag?: string | null
          id?: string
          inbox_link?: string | null
          instagram_media_id?: string | null
          instagram_story_id?: string | null
          instagram_user_id?: string | null
          instagram_username?: string | null
          last_check_at?: string | null
          matched_ambassador_id?: string | null
          matched_event_id?: string | null
          matched_fiesta_id?: string | null
          mention_type: string
          mentioned_at?: string
          organization_id: string
          platform?: string | null
          processed?: boolean | null
          processed_at?: string | null
          raw_data?: Json | null
          reach_count?: number | null
          recipient_page_id?: string | null
          state?: string
          story_url?: string | null
        }
        Update: {
          checks_count?: number | null
          content?: string | null
          conversation_id?: string | null
          created_at?: string
          created_task_id?: string | null
          deep_link?: string | null
          engagement_score?: number | null
          expires_at?: string | null
          external_event_id?: string | null
          hashtag?: string | null
          id?: string
          inbox_link?: string | null
          instagram_media_id?: string | null
          instagram_story_id?: string | null
          instagram_user_id?: string | null
          instagram_username?: string | null
          last_check_at?: string | null
          matched_ambassador_id?: string | null
          matched_event_id?: string | null
          matched_fiesta_id?: string | null
          mention_type?: string
          mentioned_at?: string
          organization_id?: string
          platform?: string | null
          processed?: boolean | null
          processed_at?: string | null
          raw_data?: Json | null
          reach_count?: number | null
          recipient_page_id?: string | null
          state?: string
          story_url?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_social_mentions_ambassador"
            columns: ["matched_ambassador_id"]
            isOneToOne: false
            referencedRelation: "embassadors"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_social_mentions_event"
            columns: ["matched_event_id"]
            isOneToOne: false
            referencedRelation: "events"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_social_mentions_fiesta"
            columns: ["matched_fiesta_id"]
            isOneToOne: false
            referencedRelation: "fiestas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_social_mentions_organization"
            columns: ["organization_id"]
            isOneToOne: false
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_social_mentions_task"
            columns: ["created_task_id"]
            isOneToOne: false
            referencedRelation: "tasks"
            referencedColumns: ["id"]
          },
        ]
      }
      task_logs: {
        Row: {
          api_response: Json | null
          checked_by: string | null
          details: string | null
          id: string
          story_status: string | null
          task_id: string
          timestamp_checked: string | null
          was_active: boolean | null
        }
        Insert: {
          api_response?: Json | null
          checked_by?: string | null
          details?: string | null
          id?: string
          story_status?: string | null
          task_id: string
          timestamp_checked?: string | null
          was_active?: boolean | null
        }
        Update: {
          api_response?: Json | null
          checked_by?: string | null
          details?: string | null
          id?: string
          story_status?: string | null
          task_id?: string
          timestamp_checked?: string | null
          was_active?: boolean | null
        }
        Relationships: [
          {
            foreignKeyName: "task_logs_task_id_fkey"
            columns: ["task_id"]
            isOneToOne: false
            referencedRelation: "tasks"
            referencedColumns: ["id"]
          },
        ]
      }
      tasks: {
        Row: {
          completion_method: string | null
          created_at: string | null
          embassador_id: string
          engagement_score: number | null
          event_id: string
          expected_hashtag: string | null
          expiry_time: string | null
          id: string
          instagram_story_id: string | null
          last_status_update: string | null
          platform: string | null
          points_earned: number | null
          reach_count: number | null
          status: string | null
          story_url: string | null
          task_type: string
          upload_time: string | null
          verified_through_api: boolean | null
        }
        Insert: {
          completion_method?: string | null
          created_at?: string | null
          embassador_id: string
          engagement_score?: number | null
          event_id: string
          expected_hashtag?: string | null
          expiry_time?: string | null
          id?: string
          instagram_story_id?: string | null
          last_status_update?: string | null
          platform?: string | null
          points_earned?: number | null
          reach_count?: number | null
          status?: string | null
          story_url?: string | null
          task_type: string
          upload_time?: string | null
          verified_through_api?: boolean | null
        }
        Update: {
          completion_method?: string | null
          created_at?: string | null
          embassador_id?: string
          engagement_score?: number | null
          event_id?: string
          expected_hashtag?: string | null
          expiry_time?: string | null
          id?: string
          instagram_story_id?: string | null
          last_status_update?: string | null
          platform?: string | null
          points_earned?: number | null
          reach_count?: number | null
          status?: string | null
          story_url?: string | null
          task_type?: string
          upload_time?: string | null
          verified_through_api?: boolean | null
        }
        Relationships: [
          {
            foreignKeyName: "tasks_embassador_id_fkey"
            columns: ["embassador_id"]
            isOneToOne: false
            referencedRelation: "embassadors"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tasks_event_id_fkey"
            columns: ["event_id"]
            isOneToOne: false
            referencedRelation: "events"
            referencedColumns: ["id"]
          },
        ]
      }
      token_rotation_logs: {
        Row: {
          ambassador_id: string | null
          created_at: string
          id: string
          new_token_hash: string | null
          old_token_hash: string | null
          organization_id: string | null
          reason: string | null
          rotated_by: string | null
          rotation_type: string
          success: boolean
        }
        Insert: {
          ambassador_id?: string | null
          created_at?: string
          id?: string
          new_token_hash?: string | null
          old_token_hash?: string | null
          organization_id?: string | null
          reason?: string | null
          rotated_by?: string | null
          rotation_type: string
          success?: boolean
        }
        Update: {
          ambassador_id?: string | null
          created_at?: string
          id?: string
          new_token_hash?: string | null
          old_token_hash?: string | null
          organization_id?: string | null
          reason?: string | null
          rotated_by?: string | null
          rotation_type?: string
          success?: boolean
        }
        Relationships: [
          {
            foreignKeyName: "token_rotation_logs_ambassador_id_fkey"
            columns: ["ambassador_id"]
            isOneToOne: false
            referencedRelation: "embassadors"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "token_rotation_logs_organization_id_fkey"
            columns: ["organization_id"]
            isOneToOne: false
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
        ]
      }
      users: {
        Row: {
          auth_user_id: string | null
          created_at: string | null
          email: string
          full_name: string | null
          id: string
          last_login: string | null
          name: string
          organization_id: string | null
          role: string | null
        }
        Insert: {
          auth_user_id?: string | null
          created_at?: string | null
          email: string
          full_name?: string | null
          id?: string
          last_login?: string | null
          name: string
          organization_id?: string | null
          role?: string | null
        }
        Update: {
          auth_user_id?: string | null
          created_at?: string | null
          email?: string
          full_name?: string | null
          id?: string
          last_login?: string | null
          name?: string
          organization_id?: string | null
          role?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_users_organization"
            columns: ["organization_id"]
            isOneToOne: false
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "users_organization_id_fkey"
            columns: ["organization_id"]
            isOneToOne: false
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      cleanup_expired_oauth_states: {
        Args: Record<PropertyKey, never>
        Returns: undefined
      }
      get_ambassador_basic_data: {
        Args: Record<PropertyKey, never>
        Returns: {
          completed_tasks: number
          created_at: string
          events_participated: number
          failed_tasks: number
          first_name: string
          follower_count: number
          global_category: string
          global_points: number
          id: string
          instagram_user: string
          instagram_user_id: string
          last_instagram_sync: string
          last_name: string
          organization_id: string
          performance_status: string
          profile_public: boolean
          status: string
        }[]
      }
      get_ambassador_safe_info: {
        Args: { org_id?: string }
        Returns: {
          completed_tasks: number
          created_at: string
          email: string
          events_participated: number
          failed_tasks: number
          first_name: string
          follower_count: number
          global_category: string
          global_points: number
          id: string
          instagram_user: string
          last_instagram_sync: string
          last_name: string
          organization_id: string
          performance_status: string
          profile_picture_url: string
          profile_public: boolean
          status: string
        }[]
      }
      get_ambassador_sensitive_data: {
        Args: { ambassador_id: string }
        Returns: {
          date_of_birth: string
          email: string
          id: string
          profile_picture_url: string
          rut: string
        }[]
      }
      get_ambassador_token_info: {
        Args: { ambassador_id: string }
        Returns: {
          access_token: string
          is_expired: boolean
          token_expiry: string
        }[]
      }
      get_org_meta_credentials_status: {
        Args: { p_organization_id: string }
        Returns: {
          has_credentials: boolean
          updated_at: string
        }[]
      }
      get_organization_credentials_by_instagram_user: {
        Args: { p_instagram_user_id: string }
        Returns: {
          meta_app_id: string
          meta_app_secret: string
          organization_id: string
          webhook_verify_token: string
        }[]
      }
      get_organization_credentials_secure: {
        Args: { p_organization_id: string }
        Returns: {
          meta_app_id: string
          meta_app_secret: string
          webhook_verify_token: string
        }[]
      }
      get_organization_hierarchy: {
        Args: { org_id: string }
        Returns: {
          description: string
          id: string
          is_main_account: boolean
          level: number
          name: string
          organization_type: string
        }[]
      }
      get_organization_safe_info: {
        Args: { org_id?: string }
        Returns: {
          created_at: string
          description: string
          id: string
          instagram_connected: boolean
          instagram_username: string
          last_instagram_sync: string
          logo_url: string
          name: string
          plan_type: string
          timezone: string
        }[]
      }
      get_organization_token_info: {
        Args: { org_id: string }
        Returns: {
          access_token: string
          is_expired: boolean
          token_expiry: string
        }[]
      }
      get_safe_ambassador_data: {
        Args: { user_organization_ids: string[] }
        Returns: {
          completed_tasks: number
          created_at: string
          created_by_user_id: string
          date_of_birth: string
          email: string
          events_participated: number
          failed_tasks: number
          first_name: string
          follower_count: number
          global_category: string
          global_points: number
          id: string
          instagram_access_token: string
          instagram_user: string
          instagram_user_id: string
          last_instagram_sync: string
          last_name: string
          organization_id: string
          performance_status: string
          profile_picture_url: string
          profile_public: boolean
          rut: string
          status: string
          token_expires_at: string
        }[]
      }
      get_safe_organization_data: {
        Args: { user_id: string }
        Returns: {
          created_at: string
          created_by: string
          description: string
          facebook_page_id: string
          id: string
          instagram_business_account_id: string
          instagram_user_id: string
          instagram_username: string
          last_instagram_sync: string
          logo_url: string
          meta_token: string
          name: string
          plan_type: string
          timezone: string
          token_expiry: string
        }[]
      }
      get_user_organization_ids: {
        Args: { user_id: string }
        Returns: {
          organization_id: string
        }[]
      }
      get_user_organizations: {
        Args: { user_auth_id: string }
        Returns: {
          is_owner: boolean
          organization_id: string
          role: string
        }[]
      }
      hash_token_for_audit: {
        Args: { token_text: string }
        Returns: string
      }
      is_organization_member: {
        Args: { org_id: string; user_auth_id: string }
        Returns: boolean
      }
      upsert_org_meta_credentials: {
        Args: {
          p_meta_app_id: string
          p_meta_app_secret: string
          p_organization_id: string
          p_webhook_verify_token: string
        }
        Returns: undefined
      }
    }
    Enums: {
      import_export_type: "import" | "export"
      user_role_extended: "admin" | "rrpp" | "cliente_viewer"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {
      import_export_type: ["import", "export"],
      user_role_extended: ["admin", "rrpp", "cliente_viewer"],
    },
  },
} as const
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/pages/auth-callback.tsx">
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import { Loader2, CheckCircle, AlertCircle } from "lucide-react";
import { toast } from "sonner";

export default function AuthCallback() {
  const navigate = useNavigate();
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');
  const [message, setMessage] = useState('');

  useEffect(() => {
    const handleCallback = async () => {
      try {
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get('code');
        const state = urlParams.get('state');
        const error = urlParams.get('error');

        if (error) {
          throw new Error(urlParams.get('error_description') || 'Error de autorizaci√≥n de Instagram');
        }

        if (!code || !state) {
          throw new Error('Par√°metros de callback inv√°lidos');
        }

        setMessage('Procesando autorizaci√≥n de Instagram...');

        // Here we would normally process the callback
        // For now, we'll just show success and redirect
        setTimeout(() => {
          setStatus('success');
          setMessage('¬°Instagram conectado exitosamente!');
          toast.success('Instagram conectado exitosamente');
          
          // Redirect to ambassadors page after a short delay
          setTimeout(() => {
            navigate('/ambassadors');
          }, 2000);
        }, 1500);

      } catch (error) {
        console.error('Error processing Instagram callback:', error);
        setStatus('error');
        setMessage(error instanceof Error ? error.message : 'Error procesando autorizaci√≥n');
        toast.error('Error conectando Instagram');
        
        // Redirect to ambassadors page after error
        setTimeout(() => {
          navigate('/ambassadors');
        }, 3000);
      }
    };

    handleCallback();
  }, [navigate]);

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-primary/5 to-secondary/5">
      <div className="max-w-md w-full mx-4">
        <div className="bg-white dark:bg-gray-900 rounded-lg shadow-lg p-8 text-center">
          {status === 'loading' && (
            <>
              <Loader2 className="w-12 h-12 animate-spin mx-auto mb-4 text-primary" />
              <h2 className="text-xl font-semibold mb-2">Conectando Instagram</h2>
              <p className="text-muted-foreground">{message}</p>
            </>
          )}
          
          {status === 'success' && (
            <>
              <CheckCircle className="w-12 h-12 mx-auto mb-4 text-green-500" />
              <h2 className="text-xl font-semibold mb-2 text-green-600">¬°√âxito!</h2>
              <p className="text-muted-foreground">{message}</p>
              <p className="text-sm text-muted-foreground mt-2">
                Redirigiendo en unos segundos...
              </p>
            </>
          )}
          
          {status === 'error' && (
            <>
              <AlertCircle className="w-12 h-12 mx-auto mb-4 text-red-500" />
              <h2 className="text-xl font-semibold mb-2 text-red-600">Error</h2>
              <p className="text-muted-foreground">{message}</p>
              <p className="text-sm text-muted-foreground mt-2">
                Redirigiendo en unos segundos...
              </p>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/Auth.tsx">
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "@/hooks/useAuth";
import { AuthForm } from "@/components/Auth/AuthForm";

export default function Auth() {
  const { user, loading } = useAuth();
  const navigate = useNavigate();

  useEffect(() => {
    if (!loading && user) {
      console.log("User already authenticated, redirecting to home");
      navigate('/', { replace: true });
    }
  }, [user, loading, navigate]);

  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-gray-50 via-gray-100 to-gray-200 flex items-center justify-center">
        <div className="flex flex-col items-center space-y-4">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
          <p className="text-sm text-muted-foreground animate-pulse">Verificando autenticaci√≥n...</p>
        </div>
      </div>
    );
  }

  // Don't show auth form if user is authenticated
  if (user) {
    return null;
  }

  return <AuthForm />;
}
</file>

<file path="src/pages/Events.tsx">
import { MainLayout } from "@/components/Layout/MainLayout";
import FiestasManagement from "@/components/Fiestas/FiestasManagement";
import { ProtectedRoute } from "@/components/Auth/ProtectedRoute";

const Events = () => {
  return (
    <ProtectedRoute>
      <MainLayout>
        <FiestasManagement />
      </MainLayout>
    </ProtectedRoute>
  );
};

export default Events;
</file>

<file path="src/pages/ImportExport.tsx">
import { MainLayout } from "@/components/Layout/MainLayout";
import { PageHeader } from "@/components/Layout/PageHeader";
import { GlassPanel } from "@/components/Layout/GlassPanel";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import ImportExportReal from "@/components/ImportExport/ImportExportReal";
import BackupCenter from "@/components/ImportExport/BackupCenter";

export default function ImportExport() {
  return (
    <MainLayout>
      <PageHeader 
        title="Centro de Respaldos e Importaci√≥n" 
        description="Gestiona tus datos con herramientas de respaldo, importaci√≥n y exportaci√≥n"
      />
      
      <GlassPanel>
        <Tabs defaultValue="backup" className="space-y-6">
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="backup">Centro de Respaldos</TabsTrigger>
            <TabsTrigger value="import-export">Importar/Exportar</TabsTrigger>
          </TabsList>
          
          <TabsContent value="backup">
            <BackupCenter />
          </TabsContent>
          
          <TabsContent value="import-export">
            <ImportExportReal />
          </TabsContent>
        </Tabs>
      </GlassPanel>
    </MainLayout>
  );
}
</file>

<file path="src/pages/Index.tsx">
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { EVABrandedDashboard } from "@/components/Dashboard/EVABrandedDashboard";
import { MainLayout } from "@/components/Layout/MainLayout";
import { ProtectedRoute } from "@/components/Auth/ProtectedRoute";
import { useAuth } from "@/hooks/useAuth";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";

export default function Index() {
  const { user, loading: authLoading } = useAuth();
  const { organization, loading: orgLoading } = useCurrentOrganization();
  const navigate = useNavigate();

  // Redirect authenticated users from auth page
  useEffect(() => {
    if (!authLoading && user && window.location.pathname === '/auth') {
      navigate('/', { replace: true });
    }
  }, [user, authLoading, navigate]);

  return (
    <ProtectedRoute>
      <MainLayout>
        {/* Mostrar loading mientras se cargan las organizaciones */}
        {orgLoading ? (
          <div className="flex items-center justify-center min-h-[50vh]">
            <div className="flex flex-col items-center space-y-4">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
              <p className="text-sm text-muted-foreground animate-pulse">Cargando organizaciones...</p>
            </div>
          </div>
        ) : (
          <EVABrandedDashboard />
        )}
      </MainLayout>
    </ProtectedRoute>
  );
}
</file>

<file path="src/pages/InstagramBusiness.tsx">
import { PageHeader } from "@/components/Layout/PageHeader";
import { InstagramBusinessDashboard } from "@/components/Instagram/InstagramBusinessDashboard";
import { ProtectedRoute } from "@/components/Auth/ProtectedRoute";

export default function InstagramBusinessPage() {
  return (
    <ProtectedRoute>
      <div className="container mx-auto px-4 py-8">
        <PageHeader 
          title="Instagram Business" 
          description="Gestiona tu cuenta de Instagram Business y consulta m√©tricas seg√∫n la API de Meta" 
        />
        <InstagramBusinessDashboard />
      </div>
    </ProtectedRoute>
  );
}
</file>

<file path="src/pages/InstagramDiagnostics.tsx">
import { MainLayout } from "@/components/Layout/MainLayout";
import { PageHeader } from "@/components/Layout/PageHeader";
import { InstagramDiagnosticsPanel } from "@/components/Settings/InstagramDiagnosticsPanel";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { 
  Instagram, 
  CheckCircle, 
  XCircle, 
  AlertTriangle,
  RefreshCw,
  Activity,
  Settings,
  Database,
  Zap,
  Globe
} from "lucide-react";
import { useState, useEffect } from "react";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { useInstagramConnection } from "@/hooks/useInstagramConnection";
import { useInstagramSync } from "@/hooks/useInstagramSync";
import { toast } from "sonner";
import { supabase } from "@/integrations/supabase/client";

interface SystemCheck {
  name: string;
  status: 'success' | 'warning' | 'error';
  description: string;
  action?: string;
}

export default function InstagramDiagnostics() {
  const { organization } = useCurrentOrganization();
  const { isConnected, isTokenExpired, refreshTokenStatus } = useInstagramConnection();
  const { isSyncing, syncInstagramData, refreshToken } = useInstagramSync();
  const [systemChecks, setSystemChecks] = useState<SystemCheck[]>([]);
  const [isRunningSystemCheck, setIsRunningSystemCheck] = useState(false);

  useEffect(() => {
    runSystemChecks();
  }, [organization, isConnected, isTokenExpired]);

  const runSystemChecks = async () => {
    if (!organization) return;

    setIsRunningSystemCheck(true);
    const checks: SystemCheck[] = [];

    try {
      // Check 1: Organization setup
      checks.push({
        name: "Organizaci√≥n configurada",
        status: organization ? 'success' : 'error',
        description: organization 
          ? `Organizaci√≥n: ${organization.name}` 
          : "No se encontr√≥ organizaci√≥n activa"
      });

      // Check 2: Instagram connection
      checks.push({
        name: "Conexi√≥n de Instagram",
        status: isConnected ? 'success' : 'error',
        description: isConnected 
          ? `Conectado como @${organization.instagram_username}` 
          : "Instagram no est√° conectado",
        action: !isConnected ? "Conectar Instagram" : undefined
      });

      // Check 3: Token status
      if (isConnected) {
        checks.push({
          name: "Estado del token",
          status: isTokenExpired ? 'error' : 'success',
          description: isTokenExpired 
            ? "Token expirado - requiere renovaci√≥n" 
            : "Token v√°lido y activo",
          action: isTokenExpired ? "Renovar token" : undefined
        });
      }

      // Check 4: Database tables
      const { data: socialMentions, error: mentionsError } = await supabase
        .from('social_mentions')
        .select('id, created_at')
        .eq('organization_id', organization.id)
        .order('created_at', { ascending: false })
        .limit(1);

      checks.push({
        name: "Base de datos",
        status: mentionsError ? 'error' : 'success',
        description: mentionsError 
          ? `Error de base de datos: ${mentionsError.message}`
          : socialMentions && socialMentions.length > 0
            ? `√öltima actividad: ${new Date(socialMentions[0].created_at).toLocaleString('es-ES')}`
            : "Base de datos operativa - sin actividad reciente"
      });

      // Check 5: Credentials
      const { data: credsStatus } = await supabase
        .rpc('get_org_meta_credentials_status', { 
          p_organization_id: organization.id 
        });

      const hasCredentials = credsStatus && credsStatus.length > 0 && credsStatus[0].has_credentials;

      checks.push({
        name: "Credenciales de Meta App",
        status: hasCredentials ? 'success' : 'warning',
        description: hasCredentials 
          ? "Credenciales configuradas correctamente" 
          : "Credenciales no configuradas o faltantes",
        action: !hasCredentials ? "Configurar credenciales" : undefined
      });

      // Check 6: Recent sync
      const lastSync = organization.last_instagram_sync;
      const syncStatus = lastSync 
        ? new Date(Date.now() - new Date(lastSync).getTime()).getTime() < 24 * 60 * 60 * 1000
        : false;

      checks.push({
        name: "Sincronizaci√≥n reciente",
        status: syncStatus ? 'success' : 'warning',
        description: lastSync 
          ? `√öltima sincronizaci√≥n: ${new Date(lastSync).toLocaleString('es-ES')}` 
          : "No se ha sincronizado nunca",
        action: "Sincronizar ahora"
      });

    } catch (error) {
      console.error('Error running system checks:', error);
      checks.push({
        name: "Error del sistema",
        status: 'error',
        description: `Error al ejecutar diagn√≥sticos: ${error instanceof Error ? error.message : 'Error desconocido'}`
      });
    }

    setSystemChecks(checks);
    setIsRunningSystemCheck(false);
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'success':
        return <CheckCircle className="w-5 h-5 text-green-500" />;
      case 'warning':
        return <AlertTriangle className="w-5 h-5 text-yellow-500" />;
      case 'error':
        return <XCircle className="w-5 h-5 text-red-500" />;
      default:
        return <Activity className="w-5 h-5 text-gray-500" />;
    }
  };

  const getStatusVariant = (status: string): "default" | "secondary" | "destructive" => {
    switch (status) {
      case 'success':
        return 'default';
      case 'warning':
        return 'secondary';
      case 'error':
        return 'destructive';
      default:
        return 'secondary';
    }
  };

  const handleAction = async (check: SystemCheck) => {
    switch (check.action) {
      case "Sincronizar ahora":
        await syncInstagramData();
        await runSystemChecks();
        break;
      case "Renovar token":
        await refreshToken();
        await refreshTokenStatus();
        await runSystemChecks();
        break;
      default:
        toast.info(`Acci√≥n: ${check.action}`);
    }
  };

  return (
    <MainLayout>
      <div className="space-y-6">
        <PageHeader 
          title="Diagn√≥sticos de Instagram" 
          description="Herramientas avanzadas para diagnosticar y solucionar problemas de integraci√≥n con Instagram"
        />

        {/* System Status Overview */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Database className="w-5 h-5" />
              Estado del Sistema
            </CardTitle>
            <CardDescription>
              Verificaci√≥n autom√°tica de todos los componentes del sistema
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium">
                  {systemChecks.length > 0 ? `${systemChecks.filter(c => c.status === 'success').length}/${systemChecks.length} componentes funcionando` : 'Ejecutando diagn√≥sticos...'}
                </span>
              </div>
              <Button 
                onClick={runSystemChecks}
                disabled={isRunningSystemCheck}
                variant="outline"
                size="sm"
              >
                <RefreshCw className={`w-4 h-4 mr-2 ${isRunningSystemCheck ? 'animate-spin' : ''}`} />
                Actualizar
              </Button>
            </div>

            {systemChecks.length > 0 && (
              <div className="space-y-3">
                {systemChecks.map((check, index) => (
                  <div 
                    key={index}
                    className="flex items-center justify-between p-4 border rounded-lg bg-background/50"
                  >
                    <div className="flex items-center gap-3">
                      {getStatusIcon(check.status)}
                      <div className="flex-1">
                        <div className="flex items-center gap-2">
                          <p className="font-medium">{check.name}</p>
                          <Badge variant={getStatusVariant(check.status)} className="text-xs">
                            {check.status === 'success' ? 'OK' : 
                             check.status === 'warning' ? 'Advertencia' : 'Error'}
                          </Badge>
                        </div>
                        <p className="text-sm text-muted-foreground mt-1">{check.description}</p>
                      </div>
                    </div>
                    {check.action && (
                      <Button
                        onClick={() => handleAction(check)}
                        size="sm"
                        variant="outline"
                        disabled={isSyncing || isRunningSystemCheck}
                      >
                        {check.action}
                      </Button>
                    )}
                  </div>
                ))}
              </div>
            )}
          </CardContent>
        </Card>

        <Separator />

        {/* Advanced Diagnostics */}
        {isConnected && <InstagramDiagnosticsPanel />}

        {/* Quick Actions */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Zap className="w-5 h-5" />
              Acciones R√°pidas
            </CardTitle>
            <CardDescription>
              Herramientas comunes para solucionar problemas
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              <Button
                onClick={() => refreshTokenStatus()}
                variant="outline"
                className="h-auto p-4 flex flex-col items-start gap-2"
              >
                <RefreshCw className="w-5 h-5" />
                <div className="text-left">
                  <div className="font-medium">Actualizar Estado</div>
                  <div className="text-sm text-muted-foreground">Refresca el estado de conexi√≥n</div>
                </div>
              </Button>

              <Button
                onClick={() => syncInstagramData()}
                disabled={isSyncing || !isConnected}
                variant="outline"
                className="h-auto p-4 flex flex-col items-start gap-2"
              >
                <Instagram className="w-5 h-5" />
                <div className="text-left">
                  <div className="font-medium">Forzar Sincronizaci√≥n</div>
                  <div className="text-sm text-muted-foreground">Sincroniza datos manualmente</div>
                </div>
              </Button>

              <Button
                onClick={() => window.open('/settings', '_blank')}
                variant="outline"
                className="h-auto p-4 flex flex-col items-start gap-2"
              >
                <Settings className="w-5 h-5" />
                <div className="text-left">
                  <div className="font-medium">Configuraci√≥n</div>
                  <div className="text-sm text-muted-foreground">Ir a configuraci√≥n de Instagram</div>
                </div>
              </Button>
            </div>
          </CardContent>
        </Card>

        {/* System Information */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Globe className="w-5 h-5" />
              Informaci√≥n del Sistema
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
              <div>
                <strong>Webhook URL:</strong>
                <code className="block mt-1 p-2 bg-muted rounded text-xs break-all">
                  https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-webhook
                </code>
              </div>
              <div>
                <strong>Funci√≥n de Sincronizaci√≥n:</strong>
                <code className="block mt-1 p-2 bg-muted rounded text-xs">
                  instagram-sync
                </code>
              </div>
              <div>
                <strong>Funci√≥n de Diagn√≥sticos:</strong>
                <code className="block mt-1 p-2 bg-muted rounded text-xs">
                  instagram-diagnostics
                </code>
              </div>
              <div>
                <strong>Organizaci√≥n ID:</strong>
                <code className="block mt-1 p-2 bg-muted rounded text-xs break-all">
                  {organization?.id || 'No disponible'}
                </code>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </MainLayout>
  );
}
</file>

<file path="src/pages/Mentions.tsx">
import { useState } from "react";
import { MainLayout } from "@/components/Layout/MainLayout";
import { PageHeader } from "@/components/Layout/PageHeader";
import { GlassPanel } from "@/components/Layout/GlassPanel";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Hash, Search, Filter, Calendar, TrendingUp, MessageCircle, ExternalLink } from "lucide-react";
import { useMentionsManagement } from "@/hooks/useMentionsManagement";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { Skeleton } from "@/components/ui/skeleton";

export default function Mentions() {
  const { mentions, stats, loading, error, filterMentions } = useMentionsManagement();
  const [searchTerm, setSearchTerm] = useState("");
  const [typeFilter, setTypeFilter] = useState("all");
  const [statusFilter, setStatusFilter] = useState("all");

  const filteredMentions = filterMentions(searchTerm, typeFilter, statusFilter);
  
  // Obtener fiestas √∫nicas para el filtro
  const uniqueFiestas = Array.from(new Set(mentions.map(m => m.fiesta_name).filter(Boolean)));

  const getMentionTypeColor = (type: string) => {
    switch (type) {
      case 'hashtag': return 'default';
      case 'mention': return 'secondary';
      case 'story': return 'outline';
      default: return 'secondary';
    }
  };

  const getMentionTypeLabel = (type: string) => {
    switch (type) {
      case 'hashtag': return 'Hashtag';
      case 'mention': return 'Menci√≥n';
      case 'story': return 'Historia';
      default: return type;
    }
  };

  const { organization } = useCurrentOrganization();

  if (loading) {
    return (
      <MainLayout>
        <PageHeader 
          title="Menciones" 
          description="Monitorea las menciones y hashtags de tu organizaci√≥n"
        />
        <GlassPanel>
          <div className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
              {[...Array(4)].map((_, i) => (
                <div key={i} className="p-4 bg-white/50 rounded-lg">
                  <Skeleton className="h-16 w-full" />
                </div>
              ))}
            </div>
          </div>
        </GlassPanel>
      </MainLayout>
    );
  }

  if (!organization) {
    return (
      <MainLayout>
        <PageHeader 
          title="Menciones" 
          description="Monitorea las menciones y hashtags de tu organizaci√≥n"
        />
        <GlassPanel className="flex items-center justify-center min-h-64">
          <div className="text-center">
            <h3 className="text-lg font-semibold mb-2">Organizaci√≥n requerida</h3>
            <p className="text-muted-foreground">
              Para ver las menciones, selecciona una organizaci√≥n.
            </p>
          </div>
        </GlassPanel>
      </MainLayout>
    );
  }

  if (error) {
    return (
      <MainLayout>
        <PageHeader 
          title="Menciones" 
          description="Monitorea las menciones y hashtags de tu organizaci√≥n"
        />
        <GlassPanel className="text-center py-12">
          <p className="text-destructive mb-4">{error}</p>
          <Button onClick={() => window.location.reload()}>
            Reintentar
          </Button>
        </GlassPanel>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <PageHeader 
        title="Menciones" 
        description={`Monitorea las menciones y hashtags de ${organization?.name}`}
      >
        <div className="flex items-center space-x-3 flex-wrap gap-2">
          <Button variant="outline" size="sm">
            <Filter className="w-4 h-4 mr-2" />
            Filtros Avanzados
          </Button>
          <Button size="sm">
            <Calendar className="w-4 h-4 mr-2" />
            Programar Reporte
          </Button>
        </div>
      </PageHeader>

      <div className="space-y-6">
        {/* Metrics */}
        <GlassPanel>
          <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
            <div className="p-4 bg-white/30 rounded-lg backdrop-blur-sm">
              <div className="flex items-center space-x-3">
                <div className="p-2 bg-primary/20 rounded-lg">
                  <Hash className="w-5 h-5 text-primary" />
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Total Menciones</p>
                  <p className="text-2xl font-bold">{stats.total.toLocaleString()}</p>
                </div>
              </div>
            </div>
            
            <div className="p-4 bg-white/30 rounded-lg backdrop-blur-sm">
              <div className="flex items-center space-x-3">
                <div className="p-2 bg-success/20 rounded-lg">
                  <TrendingUp className="w-5 h-5 text-success" />
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Alcance Total</p>
                  <p className="text-2xl font-bold">
                    {stats.reach > 1000 ? 
                      `${(stats.reach / 1000).toFixed(1)}K` : 
                      stats.reach.toLocaleString()
                    }
                  </p>
                </div>
              </div>
            </div>
            
            <div className="p-4 bg-white/30 rounded-lg backdrop-blur-sm">
              <div className="flex items-center space-x-3">
                <div className="p-2 bg-warning/20 rounded-lg">
                  <MessageCircle className="w-5 h-5 text-warning" />
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Engagement</p>
                  <p className="text-2xl font-bold">{stats.engagement}%</p>
                </div>
              </div>
            </div>
            
            <div className="p-4 bg-white/30 rounded-lg backdrop-blur-sm">
              <div className="flex items-center space-x-3">
                <div className="p-2 bg-blue-500/20 rounded-lg">
                  <Hash className="w-5 h-5 text-blue-500" />
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Sin Asignar</p>
                  <p className="text-2xl font-bold">{stats.unassigned}</p>
                </div>
              </div>
            </div>
          </div>
        </GlassPanel>

        {/* Search and Filters */}
        <GlassPanel>
          <div className="flex items-center space-x-4">
            <div className="flex-1 relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4" />
              <Input
                placeholder="Buscar menciones..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-10 bg-white/50"
              />
            </div>
            
            <Select value={typeFilter} onValueChange={setTypeFilter}>
              <SelectTrigger className="w-48 bg-white/50">
                <SelectValue placeholder="Filtrar por tipo" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Todos los tipos</SelectItem>
                <SelectItem value="hashtag">Hashtags</SelectItem>
                <SelectItem value="mention">Menciones</SelectItem>
                <SelectItem value="story">Historias</SelectItem>
              </SelectContent>
            </Select>

            <Select value={statusFilter} onValueChange={setStatusFilter}>
              <SelectTrigger className="w-48 bg-white/50">
                <SelectValue placeholder="Filtrar por estado" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Todos los estados</SelectItem>
                <SelectItem value="assigned">Asignadas</SelectItem>
                <SelectItem value="unassigned">Sin asignar</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </GlassPanel>

        {/* Mentions List */}
        <GlassPanel>
          <div className="space-y-4">
            <h3 className="text-xl font-semibold">Menciones Recientes</h3>
            {filteredMentions.length > 0 ? (
              filteredMentions.map((mention) => (
                 <div key={mention.id} className="p-4 bg-white/30 rounded-lg hover:bg-white/40 transition-colors">
                  <div className="flex items-start justify-between mb-3">
                    <div className="flex items-center space-x-3">
                      <div className="w-10 h-10 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full flex items-center justify-center">
                        <span className="text-white font-medium text-sm">
                          {mention.ambassador_name ? 
                            mention.ambassador_name.split(' ').map(n => n[0]).join('') :
                            mention.instagram_username.substring(0, 2).toUpperCase()
                          }
                        </span>
                      </div>
                      <div>
                        <h4 className="font-medium">
                          {mention.ambassador_name || `@${mention.instagram_username}`}
                        </h4>  
                        <p className="text-sm text-muted-foreground">@{mention.instagram_username}</p>
                        {mention.fiesta_name && (
                          <p className="text-xs text-muted-foreground">{mention.fiesta_name}</p>
                        )}
                      </div>
                    </div>
                    <div className="flex items-center space-x-2">
                      <Badge variant={getMentionTypeColor(mention.mention_type)}>
                        {getMentionTypeLabel(mention.mention_type)}
                      </Badge>
                      <Badge variant="outline">{mention.platform}</Badge>
                      <Badge variant={mention.processed ? 'default' : 'secondary'}>
                        {mention.processed ? 'Procesada' : 'Sin procesar'}
                      </Badge>
                      {mention.story_url && (
                        <Button variant="outline" size="sm" asChild>
                          <a href={mention.story_url} target="_blank" rel="noopener noreferrer">
                            <ExternalLink className="w-3 h-3" />
                          </a>
                        </Button>
                      )}
                    </div>
                  </div>
                  
                  <p className="text-sm mb-3 bg-white/40 p-3 rounded-lg">
                    {mention.content}
                    {mention.hashtag && (
                      <span className="text-primary font-medium"> #{mention.hashtag}</span>
                    )}
                  </p>
                  
                  <div className="flex items-center justify-between text-sm text-muted-foreground">
                    <div className="flex items-center space-x-4">
                      <span>Alcance: {mention.reach_count.toLocaleString()}</span>
                      <span>Engagement: {mention.engagement_score}%</span>
                    </div>
                    <span>{new Date(mention.created_at).toLocaleDateString('es-ES')}</span>
                  </div>
                </div>
              ))
            ) : (
              <div className="text-center py-8 text-muted-foreground">
                {searchTerm || typeFilter !== 'all' || statusFilter !== 'all' ? (
                  <>
                    <p className="mb-4">No se encontraron menciones con los filtros aplicados</p>
                    <Button 
                      variant="outline" 
                      onClick={() => {
                        setSearchTerm("");
                        setTypeFilter("all");
                        setStatusFilter("all");
                      }}
                    >
                      Limpiar Filtros
                    </Button>
                  </>
                ) : (
                  <>
                    <p className="mb-4">No hay menciones registradas a√∫n</p>
                    <p className="text-sm">Las menciones aparecer√°n cuando los embajadores completen sus tareas</p>
                  </>
                )}
              </div>
            )}
          </div>
        </GlassPanel>
      </div>
    </MainLayout>
  );
}
</file>

<file path="src/pages/MentionsOptimized.tsx">
import { useState, useMemo } from "react";
import { MainLayout } from "@/components/Layout/MainLayout";
import { PageHeader } from "@/components/Layout/PageHeader";
import { GlassPanel } from "@/components/Layout/GlassPanel";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Hash, Search, Filter, Calendar, TrendingUp, MessageCircle, ExternalLink } from "lucide-react";
import { useMentionsOptimized } from "@/hooks/useMentionsOptimized";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { Skeleton } from "@/components/ui/skeleton";

export default function MentionsOptimized() {
  const [searchTerm, setSearchTerm] = useState("");
  const [typeFilter, setTypeFilter] = useState("all");
  const [statusFilter, setStatusFilter] = useState("all");
  
  const { mentions, stats, loading, error } = useMentionsOptimized(
    searchTerm,
    typeFilter, 
    statusFilter
  );

  const getMentionTypeColor = (type: string): "default" | "secondary" | "outline" => {
    switch (type) {
      case 'hashtag': return 'default';
      case 'mention': return 'secondary';
      case 'story': return 'outline';
      default: return 'secondary';
    }
  };

  const getMentionTypeLabel = (type: string) => {
    switch (type) {
      case 'hashtag': return 'Hashtag';
      case 'mention': return 'Menci√≥n';
      case 'story': return 'Historia';
      default: return type;
    }
  };

  const { organization } = useCurrentOrganization();

  if (loading) {
    return (
      <MainLayout>
        <PageHeader 
          title="Menciones" 
          description="Monitorea las menciones y hashtags de tu organizaci√≥n"
        />
        <GlassPanel>
          <div className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
              {[...Array(4)].map((_, i) => (
                <div key={i} className="p-4 bg-white/50 rounded-lg">
                  <Skeleton className="h-16 w-full" />
                </div>
              ))}
            </div>
          </div>
        </GlassPanel>
      </MainLayout>
    );
  }

  if (!organization) {
    return (
      <MainLayout>
        <PageHeader 
          title="Menciones" 
          description="Monitorea las menciones y hashtags de tu organizaci√≥n"
        />
        <GlassPanel className="flex items-center justify-center min-h-64">
          <div className="text-center">
            <h3 className="text-lg font-semibold mb-2">Organizaci√≥n requerida</h3>
            <p className="text-muted-foreground">
              Para ver las menciones, selecciona una organizaci√≥n.
            </p>
          </div>
        </GlassPanel>
      </MainLayout>
    );
  }

  if (error) {
    return (
      <MainLayout>
        <PageHeader 
          title="Menciones" 
          description="Monitorea las menciones y hashtags de tu organizaci√≥n"
        />
        <GlassPanel className="text-center py-12">
          <p className="text-destructive mb-4">{error}</p>
          <Button onClick={() => window.location.reload()}>
            Reintentar
          </Button>
        </GlassPanel>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <PageHeader 
        title="Menciones" 
        description={`Monitorea las menciones y hashtags de ${organization?.name}`}
      >
        <div className="flex items-center space-x-3 flex-wrap gap-2">
          <Button variant="outline" size="sm">
            <Filter className="w-4 h-4 mr-2" />
            Filtros Avanzados
          </Button>
          <Button size="sm">
            <Calendar className="w-4 h-4 mr-2" />
            Programar Reporte
          </Button>
        </div>
      </PageHeader>

      <div className="space-y-6">
        {/* Metrics */}
        <GlassPanel>
          <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
            <div className="p-4 bg-white/30 rounded-lg backdrop-blur-sm">
              <div className="flex items-center space-x-3">
                <div className="p-2 bg-primary/20 rounded-lg">
                  <Hash className="w-5 h-5 text-primary" />
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Total Menciones</p>
                  <p className="text-2xl font-bold">{stats.total.toLocaleString()}</p>
                </div>
              </div>
            </div>
            
            <div className="p-4 bg-white/30 rounded-lg backdrop-blur-sm">
              <div className="flex items-center space-x-3">
                <div className="p-2 bg-success/20 rounded-lg">
                  <TrendingUp className="w-5 h-5 text-success" />
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Alcance Total</p>
                  <p className="text-2xl font-bold">
                    {stats.reach > 1000 ? 
                      `${(stats.reach / 1000).toFixed(1)}K` : 
                      stats.reach.toLocaleString()
                    }
                  </p>
                </div>
              </div>
            </div>
            
            <div className="p-4 bg-white/30 rounded-lg backdrop-blur-sm">
              <div className="flex items-center space-x-3">
                <div className="p-2 bg-warning/20 rounded-lg">
                  <MessageCircle className="w-5 h-5 text-warning" />
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Engagement</p>
                  <p className="text-2xl font-bold">{stats.engagement}%</p>
                </div>
              </div>
            </div>
            
            <div className="p-4 bg-white/30 rounded-lg backdrop-blur-sm">
              <div className="flex items-center space-x-3">
                <div className="p-2 bg-blue-500/20 rounded-lg">
                  <Hash className="w-5 h-5 text-blue-500" />
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Sin Asignar</p>
                  <p className="text-2xl font-bold">{stats.unassigned}</p>
                </div>
              </div>
            </div>
          </div>
        </GlassPanel>

        {/* Search and Filters */}
        <GlassPanel>
          <div className="flex items-center space-x-4">
            <div className="flex-1 relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4" />
              <Input
                placeholder="Buscar menciones..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-10 bg-white/50"
              />
            </div>
            
            <Select value={typeFilter} onValueChange={setTypeFilter}>
              <SelectTrigger className="w-48 bg-white/50">
                <SelectValue placeholder="Filtrar por tipo" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Todos los tipos</SelectItem>
                <SelectItem value="hashtag">Hashtags</SelectItem>
                <SelectItem value="mention">Menciones</SelectItem>
                <SelectItem value="story">Historias</SelectItem>
              </SelectContent>
            </Select>

            <Select value={statusFilter} onValueChange={setStatusFilter}>
              <SelectTrigger className="w-48 bg-white/50">
                <SelectValue placeholder="Filtrar por estado" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Todos los estados</SelectItem>
                <SelectItem value="assigned">Asignadas</SelectItem>
                <SelectItem value="unassigned">Sin asignar</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </GlassPanel>

        {/* Mentions List - Optimized with height constraint */}
        <GlassPanel>
          <div className="space-y-4">
            <h3 className="text-xl font-semibold">Menciones Recientes</h3>
            {mentions.length > 0 ? (
              <div className="max-h-[600px] overflow-y-auto space-y-4 pr-2">
                {mentions.map((mention) => (
                  <div key={mention.id} className="p-4 bg-white/30 rounded-lg hover:bg-white/40 transition-colors">
                    <div className="flex items-start justify-between mb-3">
                      <div className="flex items-center space-x-3">
                        <div className="w-10 h-10 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full flex items-center justify-center">
                          <span className="text-white font-medium text-sm">
                            {mention.ambassador_name ? 
                              mention.ambassador_name.split(' ').map(n => n[0]).join('') :
                              mention.instagram_username.substring(0, 2).toUpperCase()
                            }
                          </span>
                        </div>
                        <div>
                          <h4 className="font-medium">
                            {mention.ambassador_name || `@${mention.instagram_username}`}
                          </h4>  
                          <p className="text-sm text-muted-foreground">@{mention.instagram_username}</p>
                          {mention.fiesta_name && (
                            <p className="text-xs text-muted-foreground">{mention.fiesta_name}</p>
                          )}
                        </div>
                      </div>
                      <div className="flex items-center space-x-2">
                        <Badge variant={getMentionTypeColor(mention.mention_type)}>
                          {getMentionTypeLabel(mention.mention_type)}
                        </Badge>
                        <Badge variant="outline">{mention.platform}</Badge>
                        <Badge variant={mention.processed ? 'default' : 'secondary'}>
                          {mention.processed ? 'Procesada' : 'Sin procesar'}
                        </Badge>
                        {mention.story_url && (
                          <Button variant="outline" size="sm" asChild>
                            <a href={mention.story_url} target="_blank" rel="noopener noreferrer">
                              <ExternalLink className="w-3 h-3" />
                            </a>
                          </Button>
                        )}
                      </div>
                    </div>
                    
                    <p className="text-sm mb-3 bg-white/40 p-3 rounded-lg">
                      {mention.content}
                      {mention.hashtag && (
                        <span className="text-primary font-medium"> #{mention.hashtag}</span>
                      )}
                    </p>
                    
                    <div className="flex items-center justify-between text-sm text-muted-foreground">
                      <div className="flex items-center space-x-4">
                        <span>Alcance: {mention.reach_count.toLocaleString()}</span>
                        <span>Engagement: {mention.engagement_score}%</span>
                      </div>
                      <span>{new Date(mention.created_at).toLocaleDateString('es-ES')}</span>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center py-8 text-muted-foreground">
                {searchTerm || typeFilter !== 'all' || statusFilter !== 'all' ? (
                  <>
                    <p className="mb-4">No se encontraron menciones con los filtros aplicados</p>
                    <Button 
                      variant="outline" 
                      onClick={() => {
                        setSearchTerm("");
                        setTypeFilter("all");
                        setStatusFilter("all");
                      }}
                    >
                      Limpiar Filtros
                    </Button>
                  </>
                ) : (
                  <>
                    <p className="mb-4">No hay menciones registradas a√∫n</p>
                    <p className="text-sm">Las menciones aparecer√°n cuando los embajadores completen sus tareas</p>
                  </>
                )}
              </div>
            )}
          </div>
        </GlassPanel>
      </div>
    </MainLayout>
  );
}
</file>

<file path="src/pages/MetaOAuthProxy.tsx">
import { useEffect, useState } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';


const MetaOAuthProxy = () => {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');
  const [errorDetails, setErrorDetails] = useState<string>('');

  useEffect(() => {
    const handleCallback = async () => {
      const action = searchParams.get('action');
      const code = searchParams.get('code');
      const state = searchParams.get('state');
      
      // Check if this is an OAuth callback (has code and state, even without explicit action)
      if (action === 'callback' || action === 'refresh' || (code && state)) {
        // code and state already extracted above
       
        const error = searchParams.get('error');
        const errorCode = searchParams.get('error_code');
        const errorMessage = searchParams.get('error_message');

        console.log('=== META OAUTH PROXY DEBUG ===');
        console.log('Callback received:', {
          action,
          code: !!code,
          state: !!state,
          error,
          errorCode,
          errorMessage,
          fullUrl: window.location.href
        });

        // Handle Meta errors first
        if (error) {
          console.error('Meta OAuth error:', { error, errorCode, errorMessage });
          const errorMsg = errorMessage || `Meta OAuth error: ${error}`;
          setStatus('error');
          setErrorDetails(errorMsg);
          toast.error(errorMsg);
          
          // Try to determine connection type from state parameter to redirect properly
          const isAmbassadorConnection = state?.includes('_ambassador_');
          const errorRedirectPath = isAmbassadorConnection
            ? '/ambassadors?status=error&error=' + encodeURIComponent(errorMsg)
            : '/settings?tab=instagram&status=error&error=' + encodeURIComponent(errorMsg);
          setTimeout(() => navigate(errorRedirectPath), 2000);
          return;
        }

        // Validate required parameters
        if (!code || !state) {
          const missingMsg = `Missing required parameters: ${!code ? 'code' : ''} ${!state ? 'state' : ''}`.trim();
          console.error('Missing OAuth parameters:', { code: !!code, state: !!state });
          setStatus('error');
          setErrorDetails(missingMsg);
          toast.error(missingMsg);
          
          // Try to determine connection type from state parameter to redirect properly
          const isAmbassadorConnection = state?.includes('_ambassador_');
          const errorRedirectPath = isAmbassadorConnection
            ? '/ambassadors?status=error&error=' + encodeURIComponent(missingMsg)
            : '/settings?tab=instagram&status=error&error=' + encodeURIComponent(missingMsg);
          setTimeout(() => navigate(errorRedirectPath), 2000);
          return;
        }

        try {
          console.log('Invoking edge function with callback data...');
          
          // Use supabase.functions.invoke to call the edge function
          const { data, error: functionError } = await supabase.functions.invoke('meta-oauth?action=callback', {
            body: {
              action: 'callback',
              code,
              state,
              error,
              error_code: errorCode,
              error_message: errorMessage
            }
          });

          console.log('Edge function response:', { data, error: functionError });

          if (functionError) {
            console.error('Edge function error:', functionError);
            const errorMsg = functionError.message || 'Error en la funci‡∏£‡∏ìn de autenticaci‡∏£‡∏ìn';
            setStatus('error');
            setErrorDetails(errorMsg);
            toast.error('Error al conectar Instagram: ' + errorMsg);
            
            // Try to determine connection type from state parameter to redirect properly
            const isAmbassadorConnection = state?.includes('_ambassador_');
            const errorRedirectPath = isAmbassadorConnection
              ? '/ambassadors?status=error&error=' + encodeURIComponent(errorMsg)
              : '/settings?tab=instagram&status=error&error=' + encodeURIComponent(errorMsg);
            setTimeout(() => navigate(errorRedirectPath), 2000);
          } else if (data?.success === false || data?.error) {
            console.error('Callback processing error:', data);
            
            // Show specific error messages based on error type
            let userFriendlyMsg = 'Error procesando la autorizaci‡∏£‡∏ìn';
            if (data?.error === 'meta_api_error') {
              userFriendlyMsg = 'Error de configuraci‡∏£‡∏ìn de Meta/Facebook. Verifica las credenciales de tu aplicaci‡∏£‡∏ìn Meta.';
            } else if (data?.error === 'token_processing_error') {
              userFriendlyMsg = 'Error procesando datos de Meta. Intenta reconectar en unos minutos.';
            } else if (data?.error === 'database_error') {
              userFriendlyMsg = 'Error guardando la conexi‡∏£‡∏ìn. Contacta al soporte t‡∏£‡∏âcnico.';
            } else if (data?.error_description) {
              userFriendlyMsg = data.error_description;
            }
            
            setStatus('error');
            setErrorDetails(`${userFriendlyMsg} ${data?.debug_info ? `(Debug: ${data.debug_info})` : ''}`);
            toast.error(`Error al conectar Instagram: ${userFriendlyMsg}`);
            
            // Use type from response if available, otherwise check state parameter
            const isAmbassadorConnection = data?.type === 'ambassador' || state?.includes('_ambassador_');
            const errorRedirectPath = isAmbassadorConnection
              ? '/ambassadors?status=error&error=' + encodeURIComponent(userFriendlyMsg)
              : '/settings?tab=instagram&status=error&error=' + encodeURIComponent(userFriendlyMsg);
            setTimeout(() => navigate(errorRedirectPath), 2000);
          } else if (data?.success === true) {
            console.log('Instagram connection successful!');
            setStatus('success');
            toast.success('Instagram conectado exitosamente');
            
            // Determine redirect based on connection type
            const redirectPath = data?.type === 'ambassador' 
              ? '/ambassadors?status=success'
              : '/settings?tab=instagram&status=success';
            setTimeout(() => navigate(redirectPath), 1000);
          } else {
            // Fallback for unexpected response format
            console.warn('Unexpected response format:', data);
            const errorMsg = 'Respuesta inesperada del servidor';
            setStatus('error');
            setErrorDetails(errorMsg);
            toast.error('Error al conectar Instagram: ' + errorMsg);
            
            // Try to determine connection type from state parameter to redirect properly
            const isAmbassadorConnection = state?.includes('_ambassador_');
            const errorRedirectPath = isAmbassadorConnection
              ? '/ambassadors?status=error&error=' + encodeURIComponent(errorMsg)
              : '/settings?tab=instagram&status=error&error=' + encodeURIComponent(errorMsg);
            setTimeout(() => navigate(errorRedirectPath), 2000);
          }
        } catch (error) {
          console.error('=== PROXY EXCEPTION ===');
          console.error('Proxy error:', error);
          const errorMsg = error instanceof Error ? error.message : 'Error inesperado en la conexi‡∏£‡∏ìn';
          setStatus('error');
          setErrorDetails(errorMsg);
          toast.error('Error en la conexi‡∏£‡∏ìn: ' + errorMsg);
          
          // Try to determine connection type from state parameter to redirect properly
          const isAmbassadorConnection = state?.includes('_ambassador_');
          const errorRedirectPath = isAmbassadorConnection
            ? '/ambassadors?status=error&error=' + encodeURIComponent(errorMsg)
            : '/settings?tab=instagram&status=error&error=' + encodeURIComponent(errorMsg);
          setTimeout(() => navigate(errorRedirectPath), 2000);
        }
      } else {
        console.log('Not a callback action, redirecting to settings');
        navigate('/settings');
      }
    };

    handleCallback();
  }, [searchParams, navigate]);

  return (
    <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-background to-secondary/20">
      <div className="text-center max-w-md mx-auto p-6">
        {status === 'loading' && (
          <>
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto mb-4"></div>
            <p className="text-lg font-medium mb-2">Procesando conexi‡∏£‡∏ìn de Instagram...</p>
            <p className="text-sm text-muted-foreground">Esto puede tomar unos segundos</p>
          </>
        )}
        
        {status === 'success' && (
          <>
            <div className="w-12 h-12 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-4">
              <svg className="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
              </svg>
            </div>
            <p className="text-lg font-medium text-green-600 mb-2">‡∏¢‡∏ÅConexi‡∏£‡∏ìn exitosa!</p>
            <p className="text-sm text-muted-foreground">Redirigiendo a configuraciones...</p>
          </>
        )}
        
        {status === 'error' && (
          <>
            <div className="w-12 h-12 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4">
              <svg className="w-6 h-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </div>
            <p className="text-lg font-medium text-red-600 mb-2">Error en la conexi‡∏£‡∏ìn</p>
            <p className="text-sm text-muted-foreground mb-4">{errorDetails}</p>
            <p className="text-xs text-muted-foreground">Redirigiendo a configuraciones...</p>
          </>
        )}
      </div>
    </div>
  );
};

export default MetaOAuthProxy;
</file>

<file path="src/pages/NotFound.tsx">
import { useLocation, Link } from "react-router-dom";
import { useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Home } from "lucide-react";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    console.error(
      "404 Error: User attempted to access non-existent route:",
      location.pathname
    );
  }, [location.pathname]);

  return (
    <div className="min-h-screen flex items-center justify-center bg-background">
      <div className="text-center space-y-6">
        <div className="space-y-2">
          <h1 className="text-6xl font-bold bg-gradient-primary bg-clip-text text-transparent">404</h1>
          <h2 className="text-2xl font-semibold">P√°gina no encontrada</h2>
          <p className="text-muted-foreground">
            La p√°gina que buscas no existe o ha sido movida
          </p>
        </div>
        <Button asChild>
          <Link to="/">
            <Home className="w-4 h-4 mr-2" />
            Volver al inicio
          </Link>
        </Button>
      </div>
    </div>
  );
};

export default NotFound;
</file>

<file path="src/pages/Notifications.tsx">
import { MainLayout } from "@/components/Layout/MainLayout";
import { NotificationCenter } from "@/components/Notifications/NotificationCenter";

export default function Notifications() {
  return (
    <MainLayout>
      <NotificationCenter />
    </MainLayout>
  );
}
</file>

<file path="src/pages/Onboarding.tsx">
import { useAuth } from "@/hooks/useAuth";
import { useUserProfile } from "@/hooks/useUserProfile";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { useFiestas } from "@/hooks/useFiestas";
import { useInstagramConnection } from "@/hooks/useInstagramConnection";
import { useNavigate } from "react-router-dom";
import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { toast } from "sonner";
import { supabase } from "@/integrations/supabase/client";
import { 
  Building, 
  Users, 
  PartyPopper, 
  Instagram, 
  CheckCircle, 
  ArrowRight,
  Sparkles,
  Edit3,
  Loader2
} from "lucide-react";
import { GlassPanel } from "@/components/Layout/GlassPanel";
import { PageHeader } from "@/components/Layout/PageHeader";
import { AppBackground } from "@/components/Layout/AppBackground";

interface OnboardingStep {
  id: string;
  title: string;
  description: string;
  icon: React.ReactNode;
  completed: boolean;
  action?: () => void;
}

export default function Onboarding() {
  const { user, loading: authLoading } = useAuth();
  const { profile, loading: profileLoading } = useUserProfile();
  const { organization, updateOrganization, loading: orgLoading } = useCurrentOrganization();
  const { fiestas } = useFiestas();
  const { isConnected: instagramConnected, connectInstagram, isConnecting } = useInstagramConnection();
  const navigate = useNavigate();

  const [currentStep, setCurrentStep] = useState(0);
  const [editingOrg, setEditingOrg] = useState(false);
  const [orgName, setOrgName] = useState('');
  const [orgDescription, setOrgDescription] = useState('');
  const [savingOrg, setSavingOrg] = useState(false);
  const [ambassadorCount, setAmbassadorCount] = useState(0);
  const [checkingAmbassadors, setCheckingAmbassadors] = useState(true);

  // Check for ambassadors
  useEffect(() => {
    const checkAmbassadors = async () => {
      if (!organization?.id) return;

      try {
        const { count, error } = await supabase
          .from('embassadors')
          .select('*', { count: 'exact', head: true })
          .eq('organization_id', organization.id);

        if (error) {
          console.error('Error checking ambassadors:', error);
        } else {
          setAmbassadorCount(count || 0);
        }
      } catch (error) {
        console.error('Error checking ambassadors:', error);
      } finally {
        setCheckingAmbassadors(false);
      }
    };

    checkAmbassadors();
  }, [organization?.id]);

  // Set initial org values when organization loads
  useEffect(() => {
    if (organization) {
      setOrgName(organization.name || '');
      setOrgDescription(organization.description || '');
    }
  }, [organization]);

  // Redirect if not authenticated
  useEffect(() => {
    if (!authLoading && !user) {
      navigate('/');
    }
  }, [user, authLoading, navigate]);

  const handleSaveOrganization = async () => {
    if (!orgName.trim()) {
      toast.error('El nombre de la organizaci√≥n es requerido');
      return;
    }

    setSavingOrg(true);
    const success = await updateOrganization({
      name: orgName.trim(),
      description: orgDescription.trim() || null
    });

    if (success) {
      setEditingOrg(false);
      toast.success('Organizaci√≥n actualizada correctamente');
    }
    setSavingOrg(false);
  };

  const handleInstagramConnect = async () => {
    try {
      await connectInstagram();
    } catch (error) {
      console.error('Error connecting Instagram:', error);
      toast.error('Error al conectar Instagram');
    }
  };

  const handleCreateFiesta = () => {
    navigate('/events');
  };

  const handleAddAmbassadors = () => {
    navigate('/ambassadors');
  };

  const steps: OnboardingStep[] = [
    {
      id: "organization",
      title: "Configura tu Organizaci√≥n",
      description: "Dale un nombre y descripci√≥n a tu organizaci√≥n",
      icon: <Building className="h-6 w-6" />,
      completed: !!(organization?.name && organization.name !== 'Mi Organizaci√≥n'),
      action: () => setEditingOrg(true)
    },
    {
      id: "instagram",
      title: "Conecta Instagram",
      description: "Vincula tu cuenta de Instagram para gestionar embajadores",
      icon: <Instagram className="h-6 w-6" />,
      completed: instagramConnected,
      action: handleInstagramConnect
    },
    {
      id: "fiesta",
      title: "Crea tu Primera Fiesta",
      description: "Configura tu primer evento para comenzar a gestionar embajadores",
      icon: <PartyPopper className="h-6 w-6" />,
      completed: fiestas.length > 0,
      action: handleCreateFiesta
    },
    {
      id: "ambassadors",
      title: "Agrega Embajadores",
      description: "Invita o importa tus primeros embajadores",
      icon: <Users className="h-6 w-6" />,
      completed: ambassadorCount > 0,
      action: handleAddAmbassadors
    }
  ];

  const completedSteps = steps.filter(step => step.completed).length;
  const progress = (completedSteps / steps.length) * 100;

  // Verificar si se pueden completar los pasos requeridos para acceder al dashboard
  const requiredSteps = steps.filter(step => step.id === 'organization'); // Solo organizaci√≥n es requerida
  const canAccessDashboard = requiredSteps.every(step => step.completed);

  const handleFinishOnboarding = () => {
    navigate('/');
  };

  if (authLoading || profileLoading || orgLoading || checkingAmbassadors) {
    return (
      <AppBackground>
        <div className="min-h-screen flex items-center justify-center">
          <div className="flex items-center space-x-2">
            <Loader2 className="h-6 w-6 animate-spin" />
            <span>Configurando tu experiencia...</span>
          </div>
        </div>
      </AppBackground>
    );
  }

  return (
    <AppBackground>
      <div className="container mx-auto px-4 py-8">
        <PageHeader
          title="Configuraci√≥n Inicial"
          description="Te guiaremos paso a paso para configurar tu cuenta EVA System"
        />

        <div className="space-y-8">
          {/* Hero Section */}
          <GlassPanel size="lg" className="text-center">
            <div className="space-y-6">
              <div className="flex items-center justify-center">
                <div className="bg-gradient-to-r from-purple-600 to-blue-600 p-4 rounded-full">
                  <Sparkles className="h-12 w-12 text-white" />
                </div>
              </div>
              
              <div className="space-y-3">
                <h1 className="text-4xl font-bold bg-gradient-to-r from-purple-600 via-blue-600 to-cyan-500 bg-clip-text text-transparent">
                  ¬°Bienvenido a EVA System!
                </h1>
                <p className="text-xl text-muted-foreground max-w-2xl mx-auto">
                  Tu plataforma inteligente para gestionar embajadores y eventos. 
                  Comencemos configurando tu experiencia paso a paso.
                </p>
              </div>

              <div className="space-y-3">
                <div className="flex items-center justify-between text-sm">
                  <span className="text-muted-foreground">Progreso de configuraci√≥n</span>
                  <span className="font-medium">{completedSteps} de {steps.length} completados</span>
                </div>
                <Progress value={progress} className="h-3" />
              </div>
            </div>
          </GlassPanel>

          {/* Organization Edit Modal */}
          {editingOrg && (
            <GlassPanel className="border-purple-200 bg-purple-50/50">
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="text-lg font-semibold flex items-center">
                    <Edit3 className="h-5 w-5 mr-2" />
                    Configura tu Organizaci√≥n
                  </h3>
                </div>
                
                <div className="grid gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="orgName">Nombre de la Organizaci√≥n *</Label>
                    <Input
                      id="orgName"
                      value={orgName}
                      onChange={(e) => setOrgName(e.target.value)}
                      placeholder="Ej: Productora Eventos Chile"
                    />
                  </div>
                  
                  <div className="space-y-2">
                    <Label htmlFor="orgDescription">Descripci√≥n</Label>
                    <Textarea
                      id="orgDescription"
                      value={orgDescription}
                      onChange={(e) => setOrgDescription(e.target.value)}
                      placeholder="Descripci√≥n de tu organizaci√≥n..."
                      rows={3}
                    />
                  </div>
                </div>

                <div className="flex gap-3">
                  <Button 
                    onClick={handleSaveOrganization}
                    disabled={savingOrg || !orgName.trim()}
                    className="bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-500 hover:to-blue-500 text-white"
                  >
                    {savingOrg ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Guardando...
                      </>
                    ) : (
                      'Guardar'
                    )}
                  </Button>
                  <Button 
                    variant="outline" 
                    onClick={() => setEditingOrg(false)}
                    disabled={savingOrg}
                  >
                    Cancelar
                  </Button>
                </div>
              </div>
            </GlassPanel>
          )}

          {/* Steps Grid */}
          <div className="grid gap-6 md:grid-cols-2">
            {steps.map((step, index) => (
              <GlassPanel 
                key={step.id} 
                className={`relative transition-all duration-300 hover:shadow-xl ${
                  step.completed 
                    ? 'border-green-200 bg-green-50/50' 
                    : index === currentStep 
                      ? 'border-purple-200 bg-purple-50/50 ring-2 ring-purple-100' 
                      : 'hover:border-purple-100'
                }`}
              >
                {step.completed && (
                  <div className="absolute -top-2 -right-2">
                    <div className="bg-green-500 text-white p-1 rounded-full">
                      <CheckCircle className="h-4 w-4" />
                    </div>
                  </div>
                )}
                
                <div className="space-y-4">
                  <div className="flex items-start space-x-4">
                    <div className={`p-3 rounded-lg ${
                      step.completed 
                        ? 'bg-green-100 text-green-600' 
                        : 'bg-gradient-to-r from-purple-100 to-blue-100 text-purple-600'
                    }`}>
                      {step.icon}
                    </div>
                    
                    <div className="flex-1 space-y-2">
                      <div className="flex items-center justify-between">
                        <h3 className="text-lg font-semibold">{step.title}</h3>
                        <Badge variant={step.completed ? "default" : "secondary"}>
                          {step.completed ? "Completado" : `Paso ${index + 1}`}
                        </Badge>
                      </div>
                      
                      <p className="text-muted-foreground text-sm">
                        {step.description}
                      </p>
                    </div>
                  </div>

                  {!step.completed && (
                    <Button 
                      onClick={step.action}
                      disabled={step.id === 'instagram' && isConnecting}
                      className="w-full bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-500 hover:to-blue-500 text-white shadow-lg hover:shadow-xl transition-all duration-300"
                    >
                      {step.id === 'instagram' && isConnecting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Conectando...
                        </>
                      ) : (
                        <>
                          Configurar Ahora
                          <ArrowRight className="h-4 w-4 ml-2" />
                        </>
                      )}
                    </Button>
                  )}
                </div>
              </GlassPanel>
            ))}
          </div>

          {/* Call to Action - Dashboard Access */}
          {canAccessDashboard && (
            <GlassPanel className="text-center border-green-200 bg-green-50/50">
              <div className="space-y-4">
                <div className="bg-green-100 p-4 rounded-full w-fit mx-auto">
                  <CheckCircle className="h-12 w-12 text-green-600" />
                </div>
                
                <div className="space-y-2">
                  <h3 className="text-2xl font-bold text-green-800">¬°Configuraci√≥n Completada!</h3>
                  <p className="text-green-700">
                    Tu cuenta est√° lista. Ahora puedes comenzar a gestionar tus embajadores y eventos.
                  </p>
                </div>
                
                <Button 
                  size="lg"
                  onClick={handleFinishOnboarding}
                  className="bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white shadow-lg hover:shadow-xl transition-all duration-300"
                >
                  Explorar Dashboard
                </Button>
              </div>
            </GlassPanel>
          )}

          {/* Progress Message - Show when org is complete but other steps remain */}
          {canAccessDashboard && completedSteps < steps.length && (
            <GlassPanel className="text-center">
              <div className="space-y-4">
                <h3 className="text-xl font-semibold">¬°Excelente Progreso!</h3>
                <p className="text-muted-foreground">
                  Has completado {completedSteps} de {steps.length} pasos. 
                  Los pasos restantes son opcionales y pueden completarse m√°s tarde.
                </p>
              </div>
            </GlassPanel>
          )}
        </div>
      </div>
    </AppBackground>
  );
}
</file>

<file path="src/pages/Profile.tsx">
import { MainLayout } from "@/components/Layout/MainLayout";
import UserProfile from "@/components/Profile/UserProfile";
import { MembersManagement } from "@/components/Organizations/MembersManagement";
import { PageHeader } from "@/components/Layout/PageHeader";

const Profile = () => {
  return (
    <MainLayout>
      <div className="space-y-6">
        <PageHeader 
          title="Mi Perfil" 
          description="Gestiona tu informaci√≥n personal y configuraci√≥n de cuenta"
        />
        <UserProfile />
        <MembersManagement />
      </div>
    </MainLayout>
  );
};

export default Profile;
</file>

<file path="src/pages/Settings.tsx">
import { MainLayout } from "@/components/Layout/MainLayout";
import SettingsContent from "@/components/Settings/SettingsContent";
import { PageHeader } from "@/components/Layout/PageHeader";
import { ErrorBoundary } from "@/components/ErrorBoundary/ErrorBoundary";
import { ProtectedRoute } from "@/components/Auth/ProtectedRoute";

const Settings = () => {
  return (
    <ProtectedRoute>
      <ErrorBoundary>
        <MainLayout>
          <div className="space-y-6">
            <PageHeader 
              title="Configuraci√≥n" 
              description="Gestiona la configuraci√≥n de tu organizaci√≥n y conectividad"
            />
            <SettingsContent />
          </div>
        </MainLayout>
      </ErrorBoundary>
    </ProtectedRoute>
  );
};

export default Settings;
</file>

<file path="src/pages/Stories.tsx">
import { MainLayout } from "@/components/Layout/MainLayout";
import StoriesManagement from "@/components/Stories/StoriesManagement";
import { ProtectedRoute } from "@/components/Auth/ProtectedRoute";

const Stories = () => {
  return (
    <ProtectedRoute>
      <MainLayout>
        <StoriesManagement />
      </MainLayout>
    </ProtectedRoute>
  );
};

export default Stories;
</file>

<file path="src/pages/StoryMentions.tsx">
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { RefreshCw, AlertCircle, BookOpen, Play } from "lucide-react";
import { StoryMentionsList } from "@/components/StoryMentions/StoryMentionsList";
import { StoryMentionDetails } from "@/components/StoryMentions/StoryMentionDetails";
import { useStoryMentions } from "@/hooks/useStoryMentions";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { useToast } from "@/hooks/use-toast";
import { MainLayout } from "@/components/Layout/MainLayout";
import { StoryMention } from "@/types/storyMentions";
import { supabase } from "@/integrations/supabase/client";

export default function StoryMentions() {
  const [selectedMention, setSelectedMention] = useState<StoryMention | null>(null);
  const [detailsOpen, setDetailsOpen] = useState(false);
  const [runningWorker, setRunningWorker] = useState(false);
  
  const { organization } = useCurrentOrganization();
  const { mentions, loading, error, fetchStoryMentions, markAsProcessed, flagAsEarlyDelete, sendReply } = useStoryMentions();
  const { toast } = useToast();

  const handleViewDetails = (mention: StoryMention) => {
    setSelectedMention(mention);
    setDetailsOpen(true);
  };

  const handleMarkAsProcessed = async (mentionId: string) => {
    try {
      await markAsProcessed(mentionId);
    } catch (error) {
      // Error handling is done in the hook
    }
  };

  const handleFlagAsEarlyDelete = async (mentionId: string) => {
    try {
      await flagAsEarlyDelete(mentionId);
    } catch (error) {
      // Error handling is done in the hook
    }
  };

  const handleReply = async (mention: StoryMention, message?: string) => {
    if (message) {
      // Reply from details modal
      try {
        await sendReply(mention, message);
      } catch (error) {
        // Error handling is done in the hook
      }
    } else {
      // Show details modal to compose reply
      setSelectedMention(mention);
      setDetailsOpen(true);
    }
  };

  const handleCreateLead = (mention: StoryMention) => {
    // Placeholder for CRM integration
    toast({
      title: "Funci√≥n en desarrollo",
      description: "La integraci√≥n con CRM estar√° disponible pr√≥ximamente",
      variant: "default"
    });
  };

  const handleRefresh = () => {
    fetchStoryMentions();
    toast({
      title: "Actualizando",
      description: "Buscando nuevas menciones de historias..."
    });
  };

  const handleRunWorker = async () => {
    setRunningWorker(true);
    try {
      const { data, error } = await supabase.functions.invoke('story-mentions-state-worker');
      
      if (error) {
        throw error;
      }

      toast({
        title: "Worker ejecutado",
        description: `Procesadas: ${data.processed || 0} menciones, Notificaciones: ${data.notifications_sent || 0}`
      });

      // Refresh the mentions list
      fetchStoryMentions();
    } catch (error) {
      console.error('Error running worker:', error);
      toast({
        title: "Error",
        description: "No se pudo ejecutar el worker de estados",
        variant: "destructive"
      });
    } finally {
      setRunningWorker(false);
    }
  };

  if (!organization) {
    return (
      <MainLayout>
        <div className="container mx-auto px-4 py-8">
          <Card>
            <CardContent className="pt-6">
              <div className="text-center text-muted-foreground">
                <AlertCircle className="w-12 h-12 mx-auto mb-4 opacity-50" />
                <p>Selecciona una organizaci√≥n para ver las menciones de historias</p>
              </div>
            </CardContent>
          </Card>
        </div>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <div className="container mx-auto px-4 py-8 space-y-6">
        {/* Header */}
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
          <div>
            <h1 className="text-3xl font-bold tracking-tight">Menciones de Historias</h1>
            <p className="text-muted-foreground">
              Gestiona las menciones provenientes de historias de Instagram
            </p>
          </div>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={async () => {
                // First, try to resolve story mentions
                try {
                  const { data: resolveData, error: resolveError } = await supabase.functions.invoke('resolve-story-mentions', {
                    body: {
                      organizationId: organization.id
                    }
                  });

                  if (resolveError) {
                    console.error('Error resolving story mentions:', resolveError);
                  } else {
                    console.log('Story mentions resolved:', resolveData);
                  }
                } catch (error) {
                  console.error('Error calling resolve function:', error);
                }

                // Then run the state worker
                handleRunWorker();
              }}
              disabled={runningWorker}
              className="flex items-center gap-2"
            >
              <Play className={`w-4 h-4 ${runningWorker ? 'animate-spin' : ''}`} />
              {runningWorker ? "Ejecutando..." : "Resolver y Verificar"}
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={handleRefresh}
              disabled={loading}
              className="flex items-center gap-2"
            >
              <RefreshCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
              Actualizar
            </Button>
          </div>
        </div>

        {/* Info Card */}
        <Card className="border-primary/20 bg-primary/5">
          <CardHeader>
            <CardTitle className="text-base flex items-center gap-2">
              <BookOpen className="w-5 h-5 text-primary" />
              ¬øQu√© son las menciones de historias?
            </CardTitle>
          </CardHeader>
          <CardContent>
            <CardDescription>
              Las menciones de historias ocurren cuando alguien te menciona en su historia de Instagram 
              y un usuario hace clic en la menci√≥n, siendo redirigido a un mensaje directo contigo. 
              Estas interacciones representan alto valor de engagement y oportunidades de negocio.
              <br /><br />
              <strong>Estados:</strong> Nueva (primeras 24h), Completada (expir√≥ naturalmente), 
              Borrada temprano (marcada manualmente si se elimina antes de las 24h).
            </CardDescription>
          </CardContent>
        </Card>

        {/* Error State */}
        {error && (
          <Card className="border-destructive/50 bg-destructive/10">
            <CardContent className="pt-6">
              <div className="flex items-center gap-2 text-destructive">
                <AlertCircle className="w-5 h-5" />
                <p>Error al cargar las menciones: {error}</p>
              </div>
            </CardContent>
          </Card>
        )}

        {/* Main Content */}
        <StoryMentionsList
          mentions={mentions}
          loading={loading}
          onViewDetails={handleViewDetails}
          onMarkAsProcessed={handleMarkAsProcessed}
          onFlagAsEarlyDelete={handleFlagAsEarlyDelete}
          onReply={handleReply}
          onCreateLead={handleCreateLead}
        />

        {/* Details Modal */}
        <StoryMentionDetails
          mention={selectedMention}
          open={detailsOpen}
          onClose={() => {
            setDetailsOpen(false);
            setSelectedMention(null);
          }}
          onMarkAsProcessed={handleMarkAsProcessed}
          onFlagAsEarlyDelete={handleFlagAsEarlyDelete}
          onReply={async (mention, message) => {
            await sendReply(mention, message);
          }}
          onCreateLead={handleCreateLead}
        />
      </div>
    </MainLayout>
  );
}
</file>

<file path="src/pages/SystemConfig.tsx">
import { MainLayout } from "@/components/Layout/MainLayout";
import N8nIntegration from "@/components/N8n/N8nIntegration";
import { SystemHealthDashboard } from "@/components/System/SystemHealthDashboard";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Settings, Webhook, Database, Shield, Activity } from "lucide-react";

export default function SystemConfig() {
  return (
    <MainLayout>
      <div className="p-6 space-y-6">
        <div className="flex items-center gap-3">
          <Settings className="w-8 h-8 text-primary" />
          <div>
            <h1 className="text-3xl font-bold text-gradient">Configuraci√≥n del Sistema</h1>
            <p className="text-muted-foreground">
              Configuraci√≥n avanzada de EVA System v1.1
            </p>
          </div>
        </div>

        <Tabs defaultValue="health" className="space-y-6">
          <TabsList className="grid w-full grid-cols-5">
            <TabsTrigger value="health" className="flex items-center gap-2">
              <Activity className="w-4 h-4" />
              System Health
            </TabsTrigger>
            <TabsTrigger value="n8n" className="flex items-center gap-2">
              <Webhook className="w-4 h-4" />
              n8n
            </TabsTrigger>
            <TabsTrigger value="database" className="flex items-center gap-2">
              <Database className="w-4 h-4" />
              Base de Datos
            </TabsTrigger>
            <TabsTrigger value="security" className="flex items-center gap-2">
              <Shield className="w-4 h-4" />
              Seguridad
            </TabsTrigger>
            <TabsTrigger value="logs" className="flex items-center gap-2">
              <Settings className="w-4 h-4" />
              Logs
            </TabsTrigger>
          </TabsList>

          <TabsContent value="health">
            <SystemHealthDashboard />
          </TabsContent>

          <TabsContent value="n8n">
            <N8nIntegration />
          </TabsContent>

          <TabsContent value="database">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Database className="w-5 h-5" />
                  Estado de la Base de Datos
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="grid grid-cols-2 gap-4">
                    <div className="p-4 border rounded-lg">
                      <h4 className="font-semibold mb-2">Tablas Principales</h4>
                      <ul className="text-sm space-y-1 text-muted-foreground">
                        <li>‚úÖ users</li>
                        <li>‚úÖ profiles</li>
                        <li>‚úÖ events</li>
                        <li>‚úÖ embassadors</li>
                        <li>‚úÖ cards</li>
                        <li>‚úÖ event_logs</li>
                      </ul>
                    </div>
                    <div className="p-4 border rounded-lg">
                      <h4 className="font-semibold mb-2">Pol√≠ticas RLS</h4>
                      <ul className="text-sm space-y-1 text-muted-foreground">
                        <li>‚úÖ Habilitadas en todas las tablas</li>
                        <li>‚úÖ Pol√≠ticas por organizaci√≥n</li>
                        <li>‚úÖ Funciones de seguridad</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="security">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Shield className="w-5 h-5" />
                  Configuraci√≥n de Seguridad
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="p-4 border rounded-lg">
                    <h4 className="font-semibold mb-2">Estado de Seguridad</h4>
                    <div className="space-y-2 text-sm">
                      <div className="flex items-center justify-between">
                        <span>Row Level Security (RLS)</span>
                        <span className="text-green-600 font-medium">‚úÖ Habilitado</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span>Funciones SECURITY DEFINER</span>
                        <span className="text-green-600 font-medium">‚úÖ Configuradas</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span>Search Path Seguro</span>
                        <span className="text-green-600 font-medium">‚úÖ Configurado</span>
                      </div>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="logs">
            <Card>
              <CardHeader>
                <CardTitle>Sistema de Logs</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <p className="text-sm text-muted-foreground">
                    El sistema de logs est√° completamente configurado y registra todas las acciones importantes:
                  </p>
                  <ul className="text-sm space-y-1">
                    <li>‚Ä¢ Creaci√≥n de eventos</li>
                    <li>‚Ä¢ Agregado de embajadores</li>
                    <li>‚Ä¢ Importaci√≥n/Exportaci√≥n de datos</li>
                    <li>‚Ä¢ Configuraci√≥n de Instagram</li>
                    <li>‚Ä¢ Cambios en perfiles de usuario</li>
                  </ul>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>
      </div>
    </MainLayout>
  );
}
</file>

<file path="src/types/storyMentions.ts">
export interface StoryMention {
  id: string;
  instagram_username: string;
  instagram_user_id: string;
  content: string;
  created_at: string;
  processed: boolean;
  ambassador_name?: string;
  raw_data?: any;
  recipient_page_id?: string;
  external_event_id?: string;
  story_url?: string;
  instagram_story_id?: string;
  // Nuevos campos para la detecci√≥n de historias
  mentioned_at: string;
  expires_at?: string;
  state: 'new' | 'flagged_early_delete' | 'completed' | 'expired_unknown';
  deep_link?: string;
  // Campos para seguimiento de verificaciones
  checks_count?: number;
  last_check_at?: string;
  // Campos para bandeja de entrada
  conversation_id?: string;
  inbox_link?: string;
}
</file>

<file path="src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* EVA System Design System - Instagram-inspired SaaS for ambassador management */

@layer base {
  :root {
    /* Base colors */
    --background: 0 0% 100%;
    --foreground: 269 100% 18%;

    /* Brand colors - Clean white background with strategic purple */
    --primary: 269 100% 18%; /* #2e005e */
    --primary-foreground: 0 0% 100%;
    --primary-glow: 269 100% 25%;
    
    --secondary: 220 13% 96%; /* Light gray instead of purple */
    --secondary-foreground: 215 25% 27%;

    --accent: 220 13% 95%; /* Clean light gray for active states */
    --accent-foreground: 215 25% 27%;

    --muted: 220 13% 96%;
    --muted-foreground: 215 16% 47%;

    /* Instagram gradient colors */
    --ig-orange: 25 95% 53%; /* #F58529 */
    --ig-pink: 333 69% 61%; /* #DD2A7B */
    --ig-purple: 264 52% 47%; /* #8134AF */
    --ig-blue: 229 64% 56%; /* #515BD4 */

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 269 25% 90%;
    --input: 269 25% 90%;
    --ring: 269 100% 18%;

    /* Card and popover backgrounds */
    --card: 0 0% 100%;
    --card-foreground: 269 100% 18%;
    --popover: 0 0% 100%;
    --popover-foreground: 269 100% 18%;

    /* Special colors for EVA System */
    --success: 142 76% 36%;
    --success-foreground: 0 0% 100%;
    
    --warning: 38 92% 50%;
    --warning-foreground: 0 0% 100%;
    
    --info: 221 83% 53%;
    --info-foreground: 0 0% 100%;

    /* Brand gradients */
    --gradient-primary: linear-gradient(135deg, hsl(269 100% 18%) 0%, hsl(269 100% 25%) 100%);
    --gradient-card: linear-gradient(135deg, hsl(269 100% 18% / 0.05) 0%, hsl(269 100% 25% / 0.05) 100%);
    --gradient-border: linear-gradient(135deg, hsl(269 100% 18% / 0.2) 0%, hsl(269 100% 25% / 0.2) 100%);
    
    /* Instagram gradient */
    --gradient-instagram: linear-gradient(135deg, 
      hsl(var(--ig-orange)) 0%, 
      hsl(var(--ig-pink)) 25%, 
      hsl(var(--ig-purple)) 50%, 
      hsl(var(--ig-blue)) 100%);
    
    /* Shadows and effects */
    --shadow-elegant: 0 10px 30px -10px hsl(269 100% 18% / 0.15);
    --shadow-glow: 0 0 40px hsl(269 100% 18% / 0.2);
    --shadow-card: 0 2px 20px hsl(269 100% 18% / 0.08);

    /* Animations */
    --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    --transition-bounce: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);

    --radius: 12px;

    --sidebar-background: 0 0% 98%;

    --sidebar-foreground: 240 5.3% 26.1%;

    --sidebar-primary: 240 5.9% 10%;

    --sidebar-primary-foreground: 0 0% 98%;

    --sidebar-accent: 240 4.8% 95.9%;

    --sidebar-accent-foreground: 240 5.9% 10%;

    --sidebar-border: 220 13% 91%;

    --sidebar-ring: 217.2 91.2% 59.8%;
  }

  .dark {
    --background: 269 100% 18%;
    --foreground: 0 0% 100%;

    /* Brand dark mode */
    --primary: 269 100% 25%;
    --primary-foreground: 0 0% 100%;
    --primary-glow: 269 100% 30%;
    
    --secondary: 240 4% 16%; /* Dark gray instead of purple */
    --secondary-foreground: 0 0% 100%;

    --accent: 240 4% 20%; /* Dark gray for active states */
    --accent-foreground: 0 0% 100%;

    --muted: 240 4% 16%;
    --muted-foreground: 240 5% 84%;

    --destructive: 0 62.8% 50.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 269 30% 25%;
    --input: 269 30% 25%;
    --ring: 269 100% 25%;

    /* Dark mode card and popover backgrounds */
    --card: 240 4% 16%;
    --card-foreground: 0 0% 100%;
    --popover: 240 4% 16%;
    --popover-foreground: 0 0% 100%;

    /* Dark mode colors */
    --success: 142 76% 46%;
    --success-foreground: 0 0% 100%;
    
    --warning: 38 92% 60%;
    --warning-foreground: 0 0% 100%;
    
    --info: 221 83% 63%;
    --info-foreground: 0 0% 100%;

    /* Dark mode gradients */
    --gradient-primary: linear-gradient(135deg, hsl(269 100% 25%) 0%, hsl(269 100% 30%) 100%);
    --gradient-card: linear-gradient(135deg, hsl(269 100% 25% / 0.1) 0%, hsl(269 100% 30% / 0.1) 100%);
    --gradient-border: linear-gradient(135deg, hsl(269 100% 25% / 0.3) 0%, hsl(269 100% 30% / 0.3) 100%);
    
    /* Dark mode shadows */
    --shadow-elegant: 0 10px 30px -10px hsl(269 100% 25% / 0.25);
    --shadow-glow: 0 0 40px hsl(269 100% 25% / 0.3);
    --shadow-card: 0 2px 20px hsl(269 100% 25% / 0.15);

    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 315 75% 65%;
    --sidebar-primary-foreground: 222.2 84% 4.9%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 315 75% 65%;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground font-sans antialiased;
  }

  html {
    scroll-behavior: smooth;
  }
}

@layer components {
  /* Custom scrollbar */
  .scrollbar-thin {
    scrollbar-width: thin;
    scrollbar-color: hsl(var(--primary) / 0.3) transparent;
  }

  .scrollbar-thin::-webkit-scrollbar {
    width: 6px;
  }

  .scrollbar-thin::-webkit-scrollbar-track {
    background: transparent;
  }

  .scrollbar-thin::-webkit-scrollbar-thumb {
    background: hsl(var(--primary) / 0.3);
    border-radius: 3px;
  }

  .scrollbar-thin::-webkit-scrollbar-thumb:hover {
    background: hsl(var(--primary) / 0.5);
  }

  /* Glass effect */
  .glass {
    backdrop-filter: blur(16px) saturate(180%);
    background-color: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  /* Gradient text animation */
  .animate-gradient {
    background-size: 400% 400%;
    animation: gradient 3s ease infinite;
  }

  @keyframes gradient {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }

  /* Pulse glow effect */
  .pulse-glow {
    animation: pulse-glow 2s infinite;
  }

  @keyframes pulse-glow {
    0%, 100% {
      box-shadow: 0 0 20px hsl(var(--primary) / 0.3);
    }
    50% {
      box-shadow: 0 0 40px hsl(var(--primary) / 0.6);
    }
  }

  /* Instagram gradient utilities */
  .ig-gradient-btn {
    background: var(--gradient-instagram);
    color: white;
    border: none;
    transition: var(--transition-smooth);
  }

  .ig-gradient-btn:hover {
    transform: translateY(-1px);
    box-shadow: var(--shadow-glow);
  }

  .ig-gradient-text {
    background: var(--gradient-instagram);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  /* Clean sidebar active state */
  .sidebar-item-active {
    background-color: hsl(var(--accent));
    color: hsl(var(--accent-foreground));
    border-left: 3px solid hsl(var(--primary));
    font-weight: 500;
  }

  .sidebar-item-hover {
    background-color: hsl(var(--accent) / 0.5);
    transition: var(--transition-smooth);
  }
}
</file>

<file path="src/main.tsx">
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById("root")!).render(<App />);
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="supabase/functions/cleanup-oauth-states/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Initialize Supabase client with service role for cleanup operations
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )

    console.log('Starting OAuth states cleanup...');

    // Delete expired OAuth states
    const { data, error } = await supabaseClient
      .from('oauth_states')
      .delete()
      .lt('expires_at', new Date().toISOString())
      .select('id');

    if (error) {
      console.error('Error cleaning up OAuth states:', error);
      throw error;
    }

    const deletedCount = data?.length || 0;
    console.log(`Cleaned up ${deletedCount} expired OAuth states`);

    return new Response(
      JSON.stringify({
        success: true,
        message: `Cleaned up ${deletedCount} expired OAuth states`,
        deleted_count: deletedCount
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      },
    )

  } catch (error) {
    console.error('OAuth cleanup error:', error)
    const errorMessage = error instanceof Error ? error.message : String(error);
    return new Response(
      JSON.stringify({
        success: false,
        error: errorMessage
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      },
    )
  }
})
</file>

<file path="supabase/functions/create-ambassador/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    const { ambassadorData } = await req.json()
    
    // Get auth header
    const authHeader = req.headers.get('Authorization')
    if (!authHeader) {
      throw new Error('Authorization header required')
    }

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY')!
    const supabase = createClient(supabaseUrl, supabaseAnonKey, {
      global: {
        headers: { Authorization: authHeader }
      }
    })

    // Get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser()
    if (userError || !user) {
      throw new Error('Invalid authentication')
    }

    // Get user record
    const { data: userData, error: userDataError } = await supabase
      .from('users')
      .select('id, organization_id')
      .eq('auth_user_id', user.id)
      .single()

    if (userDataError) {
      throw new Error('User not found')
    }

    // Check for existing ambassador with same email or RUT
    const { data: existingAmbassador } = await supabase
      .from('embassadors')
      .select('id, email, rut')
      .eq('organization_id', userData.organization_id)
      .or(`email.eq.${ambassadorData.email},rut.eq.${ambassadorData.rut}`)
      .single()

    if (existingAmbassador) {
      throw new Error('Ya existe un embajador con ese email o RUT')
    }

    // Create ambassador
    const { data: ambassadorResult, error: ambassadorError } = await supabase
      .from('embassadors')
      .insert({
        first_name: ambassadorData.first_name,
        last_name: ambassadorData.last_name,
        email: ambassadorData.email,
        rut: ambassadorData.rut,
        date_of_birth: ambassadorData.date_of_birth,
        instagram_user: ambassadorData.instagram_user,
        follower_count: ambassadorData.follower_count || 0,
        organization_id: userData.organization_id,
        created_by_user_id: userData.id,
        status: 'pending',
        global_category: 'bronze',
        performance_status: 'cumple',
        profile_public: true,
        global_points: 0,
        events_participated: 0,
        completed_tasks: 0,
        failed_tasks: 0
      })
      .select()
      .single()

    if (ambassadorError) {
      throw new Error(`Error creating ambassador: ${ambassadorError.message}`)
    }

    // Create success feedback card
    await supabase.rpc('create_feedback_card', {
      p_user_id: userData.id,
      p_event_id: null,
      p_type: 'success',
      p_message: `Embajador "${ambassadorData.first_name} ${ambassadorData.last_name}" creado exitosamente. Estado: Pendiente de aprobaci√≥n.`
    })

    // Create ambassador log
    await supabase.rpc('create_event_log', {
      p_user_id: userData.id,
      p_event_id: null,
      p_action: 'ambassador_created',
      p_details: {
        ambassador_name: `${ambassadorData.first_name} ${ambassadorData.last_name}`,
        instagram_user: ambassadorData.instagram_user,
        email: ambassadorData.email,
        created_timestamp: new Date().toISOString()
      }
    })

    return new Response(
      JSON.stringify({
        success: true,
        message: 'Embajador creado exitosamente',
        data: ambassadorResult
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 201
      }
    )

  } catch (error) {
    console.error('Error in create-ambassador:', error)
    const errorMessage = error instanceof Error ? error.message : String(error);
    
    return new Response(
      JSON.stringify({
        success: false,
        message: 'Error al crear embajador',
        error: errorMessage
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400
      }
    )
  }
})
</file>

<file path="supabase/functions/create-event/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    const { eventData } = await req.json()
    
    // Get auth header
    const authHeader = req.headers.get('Authorization')
    if (!authHeader) {
      throw new Error('Authorization header required')
    }

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY')!
    const supabase = createClient(supabaseUrl, supabaseAnonKey, {
      global: {
        headers: { Authorization: authHeader }
      }
    })

    // Get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser()
    if (userError || !user) {
      throw new Error('Invalid authentication')
    }

    // Get user record
    const { data: userData, error: userDataError } = await supabase
      .from('users')
      .select('id, organization_id')
      .eq('auth_user_id', user.id)
      .single()

    if (userDataError) {
      throw new Error('User not found')
    }

    // Create event
    const { data: eventResult, error: eventError } = await supabase
      .from('events')
      .insert({
        name: eventData.name,
        description: eventData.description,
        event_date: eventData.event_date,
        start_time: eventData.start_time,
        end_time: eventData.end_time,
        location: eventData.location,
        event_type: eventData.event_type || 'otro',
        client_name: eventData.client_name,
        objective: eventData.objective,
        budget_estimate: eventData.budget_estimate,
        main_hashtag: eventData.main_hashtag,
        instagram_account: eventData.instagram_account,
        organization_id: userData.organization_id,
        active: true
      })
      .select()
      .single()

    if (eventError) {
      throw new Error(`Error creating event: ${eventError.message}`)
    }

    // Create success feedback card
    await supabase.rpc('create_feedback_card', {
      p_user_id: userData.id,
      p_event_id: eventResult.id,
      p_type: 'success',
      p_message: `Evento "${eventData.name}" creado exitosamente`
    })

    // Create event log
    await supabase.rpc('create_event_log', {
      p_user_id: userData.id,
      p_event_id: eventResult.id,
      p_action: 'event_created',
      p_details: {
        event_name: eventData.name,
        event_type: eventData.event_type,
        hashtag: eventData.main_hashtag,
        created_timestamp: new Date().toISOString()
      }
    })

    return new Response(
      JSON.stringify({
        success: true,
        message: 'Evento creado exitosamente',
        data: eventResult
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 201
      }
    )

  } catch (error) {
    console.error('Error in create-event:', error)
    const errorMessage = error instanceof Error ? error.message : String(error);
    
    return new Response(
      JSON.stringify({
        success: false,
        message: 'Error al crear evento',
        error: errorMessage
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400
      }
    )
  }
})
</file>

<file path="supabase/functions/export-organization-data/index.ts">
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // Get user from JWT
    const authHeader = req.headers.get('Authorization')!;
    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabaseClient.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const { organizationId, format = 'json', tables = 'all' } = await req.json();

    console.log('Starting organization export:', { organizationId, format, tables });

    // Verify user owns this organization
    const { data: org, error: orgError } = await supabaseClient
      .from('organizations')
      .select('*')
      .eq('id', organizationId)
      .eq('created_by', user.id)
      .single();

    if (orgError || !org) {
      return new Response(
        JSON.stringify({ error: 'Organization not found or access denied' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const exportData: Record<string, any> = {
      metadata: {
        organization_id: organizationId,
        organization_name: org.name,
        export_timestamp: new Date().toISOString(),
        export_format: format,
        exported_by: user.id
      }
    };

    // Define what tables to export
    const availableTables = ['embassadors', 'fiestas', 'events', 'tasks', 'leaderboards', 'organization_settings', 'notifications'];
    const tablesToExport = tables === 'all' ? availableTables : (Array.isArray(tables) ? tables : [tables]);

    // Export organization data
    exportData.organization = org;

    // Export embassadors
    if (tablesToExport.includes('embassadors')) {
      const { data: embassadors } = await supabaseClient
        .from('embassadors')
        .select('*')
        .eq('organization_id', organizationId);
      exportData.embassadors = embassadors || [];
    }

    // Export fiestas
    if (tablesToExport.includes('fiestas')) {
      const { data: fiestas } = await supabaseClient
        .from('fiestas')
        .select('*')
        .eq('organization_id', organizationId);
      exportData.fiestas = fiestas || [];

      // Export events for these fiestas
      if (tablesToExport.includes('events') && exportData.fiestas.length > 0) {
        const fiestaIds = exportData.fiestas.map((f: any) => f.id);
        const { data: events } = await supabaseClient
          .from('events')
          .select('*')
          .in('fiesta_id', fiestaIds);
        exportData.events = events || [];
      }
    }

    // Export tasks
    if (tablesToExport.includes('tasks') && exportData.embassadors?.length > 0) {
      const embassadorIds = exportData.embassadors.map((e: any) => e.id);
      const { data: tasks } = await supabaseClient
        .from('tasks')
        .select('*')
        .in('embassador_id', embassadorIds);
      exportData.tasks = tasks || [];
    }

    // Export leaderboards
    if (tablesToExport.includes('leaderboards') && exportData.events?.length > 0) {
      const eventIds = exportData.events.map((e: any) => e.id);
      const { data: leaderboards } = await supabaseClient
        .from('leaderboards')
        .select('*')
        .in('event_id', eventIds);
      exportData.leaderboards = leaderboards || [];
    }

    // Export organization settings
    if (tablesToExport.includes('organization_settings')) {
      const { data: settings } = await supabaseClient
        .from('organization_settings')
        .select('*')
        .eq('organization_id', organizationId);
      exportData.organization_settings = settings || [];
    }

// Export notifications
if (tablesToExport.includes('notifications')) {
  const { data: notifications } = await supabaseClient
    .from('notifications')
    .select('*')
    .eq('organization_id', organizationId);
  exportData.notifications = notifications || [];
}

// Sanitize sensitive fields before packaging
if (exportData.organization) {
  const { meta_token, token_expiry, ...safeOrg } = exportData.organization as any;
  exportData.organization = safeOrg;
}
if (Array.isArray(exportData.embassadors)) {
  exportData.embassadors = exportData.embassadors.map((a: any) => {
    const { instagram_access_token, token_expires_at, ...safe } = a; return safe;
  });
}

    // Log the export operation
    await supabaseClient
      .from('import_logs')
      .insert({
        user_id: user.id,
        organization_id: organizationId,
        type: 'export',
        source: 'api',
        file_name: `export-${org.name}-${new Date().toISOString().split('T')[0]}`,
        status: 'completed',
        result_json: {
          tables_exported: tablesToExport,
          record_counts: Object.keys(exportData).reduce((acc, key) => {
            if (Array.isArray(exportData[key])) {
              acc[key] = exportData[key].length;
            }
            return acc;
          }, {} as Record<string, number>),
          timestamp: new Date().toISOString()
        }
      });

    let responseContent: string;
    let contentType: string;
    let fileName: string;

    if (format === 'csv') {
      // Convert to CSV format (simplified, only embassadors table)
      const csvData = exportData.embassadors || [];
      if (csvData.length > 0) {
        const headers = Object.keys(csvData[0]).join(',');
        const rows = csvData.map((row: any) => 
          Object.values(row).map(val => 
            typeof val === 'string' ? `"${val.replace(/"/g, '""')}"` : val
          ).join(',')
        );
        responseContent = [headers, ...rows].join('\n');
      } else {
        responseContent = '';
      }
      contentType = 'text/csv';
      fileName = `eva-export-${org.name}-${new Date().toISOString().split('T')[0]}.csv`;
    } else {
      // JSON format
      responseContent = JSON.stringify(exportData, null, 2);
      contentType = 'application/json';
      fileName = `eva-export-${org.name}-${new Date().toISOString().split('T')[0]}.json`;
    }

    console.log('Export completed successfully for organization:', organizationId);

    return new Response(
      responseContent,
      { 
        status: 200, 
        headers: { 
          ...corsHeaders, 
          'Content-Type': contentType,
          'Content-Disposition': `attachment; filename="${fileName}"`
        } 
      }
    );

  } catch (error) {
    console.error('Error during export:', error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return new Response(
      JSON.stringify({ error: 'Error exporting data', details: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
</file>

<file path="supabase/functions/facebook-data-deletion/index.ts">
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const META_APP_SECRET = Deno.env.get('META_APP_SECRET');

function base64UrlDecode(input: string) {
  input = input.replace(/-/g, '+').replace(/_/g, '/');
  const pad = input.length % 4;
  if (pad) input += '='.repeat(4 - pad);
  const decoded = atob(input);
  const bytes = new Uint8Array([...decoded].map(c => c.charCodeAt(0)));
  const decoder = new TextDecoder();
  return decoder.decode(bytes);
}

async function verifySignedRequest(signedRequest: string) {
  if (!META_APP_SECRET) throw new Error('Missing META_APP_SECRET');
  const [sig, payload] = signedRequest.split('.');
  if (!sig || !payload) throw new Error('Invalid signed_request');

  const enc = new TextEncoder();
  const key = await crypto.subtle.importKey('raw', enc.encode(META_APP_SECRET), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
  const mac = await crypto.subtle.sign('HMAC', key, enc.encode(payload));
  const bytes = new Uint8Array(mac);
  let binary = '';
  bytes.forEach(b => binary += String.fromCharCode(b));
  const expectedB64Url = btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/,'');
  if (expectedB64Url !== sig) throw new Error('Signature mismatch');

  const json = JSON.parse(base64UrlDecode(payload));
  return json;
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    if (req.method === 'POST') {
      const contentType = req.headers.get('content-type') || '';
      let signedRequest: string | null = null;

      if (contentType.includes('application/x-www-form-urlencoded')) {
        const formBody = await req.text();
        const params = new URLSearchParams(formBody);
        signedRequest = params.get('signed_request');
      } else {
        const body = await req.json().catch(() => ({}));
        signedRequest = body.signed_request || null;
      }

      let userRef = 'unknown';
      try {
        if (signedRequest) {
          const parsed = await verifySignedRequest(signedRequest);
          userRef = parsed.user_id || parsed.user?.id || 'unknown';
        }
      } catch (e) {
        const errorMessage = e instanceof Error ? e.message : String(e);
        console.warn('Could not verify signed_request:', errorMessage);
      }

      const code = crypto.randomUUID();
      const statusUrl = `https://awpfslcepylnipaolmvv.functions.supabase.co/functions/v1/facebook-data-deletion?code=${code}`;

      // TODO: Optionally mark records for deletion for this userRef
      return new Response(JSON.stringify({ url: statusUrl, confirmation_code: code }), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    if (req.method === 'GET') {
      // Simple status endpoint
      const url = new URL(req.url);
      const code = url.searchParams.get('code') || 'unknown';
      return new Response(JSON.stringify({ status: 'pending', confirmation_code: code }), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    return new Response('Method not allowed', { status: 405, headers: corsHeaders });
  } catch (e) {
    console.error('facebook-data-deletion error:', e);
    const errorMessage = e instanceof Error ? e.message : String(e);
    return new Response(JSON.stringify({ error: errorMessage }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
});
</file>

<file path="supabase/functions/handle-user-registration/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    const { 
      email, 
      password, 
      name, 
      organizationName, 
      organizationDescription,
      mainInstagramAccount,
      authUserId 
    } = await req.json()

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabase = createClient(supabaseUrl, supabaseServiceKey)

    let userData;
    let authData;

    // Si viene authUserId, es un usuario existente creando una organizaci√≥n
    if (authUserId) {
      // Verificar si el usuario ya existe en la tabla users
      const { data: existingUser, error: existingUserError } = await supabase
        .from('users')
        .select('*')
        .eq('auth_user_id', authUserId)
        .single();

      if (existingUserError && existingUserError.code !== 'PGRST116') {
        throw new Error(`Error checking existing user: ${existingUserError.message}`)
      }

      authData = { user: { id: authUserId, email } };
      
      if (existingUser) {
        userData = existingUser;
      }
    } else {
      // Crear nuevo usuario en auth
      const { data: newAuthData, error: authError } = await supabase.auth.admin.createUser({
        email,
        password,
        email_confirm: true
      })

      if (authError) {
        throw new Error(`Error creating user: ${authError.message}`)
      }

      authData = newAuthData;
    }

    // Crear organizaci√≥n
    const { data: orgData, error: orgError } = await supabase
      .from('organizations')
      .insert({
        name: organizationName,
        description: organizationDescription || `Organizaci√≥n de ${name}`,
        created_by: authData.user.id
      })
      .select()
      .single()

    if (orgError) {
      throw new Error(`Error creating organization: ${orgError.message}`)
    }

    // Si no hay userData, crear el registro del usuario
    if (!userData) {
      const { data: newUserData, error: userError } = await supabase
        .from('users')
        .insert({
          auth_user_id: authData.user.id,
          email,
          name,
          organization_id: orgData.id,
          role: 'user'
        })
        .select()
        .single()

      if (userError) {
        throw new Error(`Error creating user record: ${userError.message}`)
      }

      userData = newUserData;
    } else {
      // For existing users creating a new organization, add them as member
      // Don't update their primary organization_id, just add membership
      const { error: memberError } = await supabase
        .from('organization_members')
        .insert({
          organization_id: orgData.id,
          user_id: authData.user.id,
          role: 'owner',
          status: 'active',
          permissions: {
            manage_ambassadors: true,
            manage_events: true,
            manage_instagram: true,
            view_analytics: true,
            manage_members: true
          }
        })

      if (memberError) {
        console.log('Membership may already exist:', memberError.message)
        // Don't throw error if membership already exists
      }
      
      // Update user's current organization to the new one
      const { data: updatedUserData, error: updateError } = await supabase
        .from('users')
        .update({
          organization_id: orgData.id
        })
        .eq('id', userData.id)
        .select()
        .single()

      if (updateError) {
        throw new Error(`Error updating user record: ${updateError.message}`)
      }

      userData = updatedUserData;
    }

    // Create welcome feedback card
    await supabase.rpc('create_feedback_card', {
      p_user_id: userData.id,
      p_event_id: null,
      p_type: 'success',
      p_message: `¬°Bienvenido a EVA System, ${name}! Tu organizaci√≥n ${organizationName} ha sido creada exitosamente.`
    })

    // Create registration log
    await supabase.rpc('create_event_log', {
      p_user_id: userData.id,
      p_event_id: null,
      p_action: authUserId ? 'organization_creation' : 'user_registration',
      p_details: {
        email,
        organization_name: organizationName,
        timestamp: new Date().toISOString()
      }
    })

    return new Response(
      JSON.stringify({
        success: true,
        message: 'Organizaci√≥n creada exitosamente',
        data: {
          user: userData,
          organization: orgData
        }
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 201
      }
    )

  } catch (error) {
    console.error('Error in handle-user-registration:', error)
    const errorMessage = error instanceof Error ? error.message : String(error);
    
    return new Response(
      JSON.stringify({
        success: false,
        message: 'Error al procesar solicitud',
        error: errorMessage
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400
      }
    )
  }
})
</file>

<file path="supabase/functions/import-ambassadors/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    const { ambassadors, organizationId } = await req.json()
    
    // Get auth header
    const authHeader = req.headers.get('Authorization')
    if (!authHeader) {
      throw new Error('Authorization header required')
    }

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY')!
    const supabase = createClient(supabaseUrl, supabaseAnonKey, {
      global: {
        headers: { Authorization: authHeader }
      }
    })

    // Get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser()
    if (userError || !user) {
      throw new Error('Invalid authentication')
    }

    // Get user record
    const { data: userData, error: userDataError } = await supabase
      .from('users')
      .select('id, organization_id')
      .eq('auth_user_id', user.id)
      .single()

    if (userDataError) {
      throw new Error('User not found')
    }

    // Validate organization access
    if (userData.organization_id !== organizationId) {
      throw new Error('No tienes permiso para importar embajadores a esta organizaci√≥n')
    }

    // Get existing ambassadors to check for duplicates
    const { data: existingAmbassadors } = await supabase
      .from('embassadors')
      .select('email, rut')
      .eq('organization_id', organizationId)

    const existingEmails = new Set(existingAmbassadors?.map(a => a.email) || [])
    const existingRuts = new Set(existingAmbassadors?.map(a => a.rut) || [])

  const results: {
    successful: number;
    failed: number;
    duplicates: number;
    errors: string[];
  } = {
    successful: 0,
    failed: 0,
    duplicates: 0,
    errors: []
  };

    const validAmbassadors = []

    for (const ambassador of ambassadors) {
      // Check for duplicates
      if (existingEmails.has(ambassador.email) || existingRuts.has(ambassador.rut)) {
        results.duplicates++
        results.errors.push(`Duplicado: ${ambassador.first_name} ${ambassador.last_name} (${ambassador.email})`)
        continue
      }

      // Validate required fields
      if (!ambassador.first_name || !ambassador.last_name || !ambassador.email || !ambassador.rut) {
        results.failed++
        results.errors.push(`Campos requeridos faltantes: ${ambassador.first_name} ${ambassador.last_name}`)
        continue
      }

      validAmbassadors.push({
        first_name: ambassador.first_name,
        last_name: ambassador.last_name,
        email: ambassador.email,
        rut: ambassador.rut,
        date_of_birth: ambassador.date_of_birth,
        instagram_user: ambassador.instagram_user || `@${ambassador.first_name.toLowerCase()}`,
        follower_count: ambassador.follower_count || 0,
        organization_id: organizationId,
        created_by_user_id: userData.id,
        status: 'pending',
        global_category: 'bronze',
        performance_status: 'cumple',
        profile_public: true,
        global_points: 0,
        events_participated: 0,
        completed_tasks: 0,
        failed_tasks: 0
      })

      // Add to existing sets to prevent duplicates within the same import
      existingEmails.add(ambassador.email)
      existingRuts.add(ambassador.rut)
    }

    // Bulk insert valid ambassadors
    if (validAmbassadors.length > 0) {
      const { data: insertResult, error: insertError } = await supabase
        .from('embassadors')
        .insert(validAmbassadors)
        .select()

      if (insertError) {
        throw new Error(`Error en importaci√≥n masiva: ${insertError.message}`)
      }

      results.successful = insertResult.length
    }

    // Create import log
    await supabase
      .from('import_logs')
      .insert({
        user_id: userData.id,
        organization_id: organizationId,
        type: 'embassadors',
        source: 'manual_import',
        file_name: 'bulk_import.json',
        status: 'completed',
        result_json: results
      })

    // Create feedback card
    await supabase.rpc('create_feedback_card', {
      p_user_id: userData.id,
      p_event_id: null,
      p_type: results.failed > 0 ? 'warning' : 'success',
      p_message: `Importaci√≥n completada: ${results.successful} exitosos, ${results.failed} fallidos, ${results.duplicates} duplicados`
    })

    // Create event log
    await supabase.rpc('create_event_log', {
      p_user_id: userData.id,
      p_event_id: null,
      p_action: 'ambassadors_imported',
      p_details: {
        total_processed: ambassadors.length,
        successful: results.successful,
        failed: results.failed,
        duplicates: results.duplicates,
        import_timestamp: new Date().toISOString()
      }
    })

    return new Response(
      JSON.stringify({
        success: true,
        message: 'Importaci√≥n de embajadores completada',
        data: results
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200
      }
    )

  } catch (error) {
    console.error('Error in import-ambassadors:', error)
    const errorMessage = error instanceof Error ? error.message : String(error);
    
    return new Response(
      JSON.stringify({
        success: false,
        message: 'Error en importaci√≥n de embajadores',
        error: errorMessage
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400
      }
    )
  }
})
</file>

<file path="supabase/functions/restore-organization-data/index.ts">
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // Get user from JWT
    const authHeader = req.headers.get('Authorization')!;
    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabaseClient.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const { backupData, options } = await req.json();
    const { overwriteExisting = false, selectiveTables = [] } = options || {};

    console.log('Starting data restoration for user:', user.id);
    console.log('Restore options:', { overwriteExisting, selectiveTables });

    const results = {
      success: true,
      restored: {} as Record<string, number>,
      errors: [] as string[],
      summary: ''
    };

// Helper function to restore table data with org-boundary enforcement and sanitization
const restoreTable = async (tableName: string, data: any[], foreignKeyMap?: Record<string, string>) => {
  if (!data || data.length === 0) return 0;

  try {
    // Map foreign keys if needed
    let processedData = data;
    if (foreignKeyMap) {
      processedData = data.map(item => {
        const mappedItem = { ...item };
        Object.entries(foreignKeyMap).forEach(([oldKey, newKey]) => {
          if (mappedItem[oldKey]) {
            mappedItem[newKey] = mappedItem[oldKey];
            delete mappedItem[oldKey];
          }
        });
        return mappedItem;
      });
    }

    // Fetch user's organizations for boundary enforcement
    const { data: userOrgs } = await supabaseClient
      .from('organizations')
      .select('id')
      .eq('created_by', user.id);
    const allowedOrgIds = new Set((userOrgs || []).map((o: any) => o.id));

    // Table-specific sanitization and scoping
    if (tableName === 'organizations') {
      processedData = processedData.map((org: any) => {
        const { meta_token, token_expiry, created_by, ...rest } = org;
        return { ...rest, created_by: user.id };
      });
    } else if (tableName === 'users') {
      processedData = processedData.map((u: any) => {
        const { role, auth_user_id, ...rest } = u;
        return { ...rest, auth_user_id: user.id };
      });
    } else {
      // If the table has organization_id, enforce org boundary
      if (processedData[0] && 'organization_id' in processedData[0]) {
        processedData = processedData
          .filter((row: any) => allowedOrgIds.has(row.organization_id))
          .map((row: any) => {
            // Remove secrets possibly present in child tables
            const sanitized = { ...row };
            if ('instagram_access_token' in sanitized) delete sanitized.instagram_access_token;
            if ('token_expires_at' in sanitized) delete sanitized.token_expires_at;
            return sanitized;
          });
      }
    }

    if (processedData.length === 0) return 0;

    if (overwriteExisting) {
      // For organizations, delete only caller-owned records in payload
      if (tableName === 'organizations') {
        const orgIds = processedData.map((org: any) => org.id);
        await supabaseClient.from(tableName).delete().in('id', orgIds).eq('created_by', user.id);
      } else if (tableName === 'users') {
        await supabaseClient.from(tableName).delete().eq('auth_user_id', user.id);
      } else if (processedData[0] && 'organization_id' in processedData[0]) {
        await supabaseClient
          .from(tableName)
          .delete()
          .in('organization_id', Array.from(allowedOrgIds));
      }
    }

    const { data: insertedData, error } = await supabaseClient
      .from(tableName)
      .insert(processedData)
      .select();

    if (error) {
      throw error;
    }

    return insertedData?.length || 0;
  } catch (error: any) {
    results.errors.push(`Error restoring ${tableName}: ${error.message}`);
    return 0;
  }
};

    // Restore data in proper order (respecting foreign key dependencies)
    const restoreOrder = [
      'organizations',
      'users', 
      'organization_settings',
      'fiestas',
      'events',
      'embassadors',
      'tasks',
      'leaderboards',
      'notifications',
      'task_logs',
      'import_logs'
    ];

    for (const tableName of restoreOrder) {
      if (selectiveTables.length > 0 && !selectiveTables.includes(tableName)) {
        continue;
      }

      if (backupData[tableName]) {
        console.log(`Restoring ${tableName}...`);
        const restored = await restoreTable(tableName, backupData[tableName]);
        results.restored[tableName] = restored;
        console.log(`Restored ${restored} records in ${tableName}`);
      }
    }

    // Create restore log
    await supabaseClient
      .from('import_logs')
      .insert({
        user_id: user.id,
        organization_id: backupData.organizations?.[0]?.id || null,
        type: 'restore',
        source: 'backup_file',
        file_name: `restore-${new Date().toISOString()}`,
        status: results.errors.length > 0 ? 'partial' : 'completed',
        result_json: {
          restored: results.restored,
          errors: results.errors,
          timestamp: new Date().toISOString()
        }
      });

    results.summary = `Restoration completed. ${Object.values(results.restored).reduce((a, b) => a + b, 0)} total records restored.`;
    
    if (results.errors.length > 0) {
      results.success = false;
      results.summary += ` ${results.errors.length} errors occurred.`;
    }

    console.log('Restoration completed:', results);

    return new Response(
      JSON.stringify(results),
      { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('Error during restoration:', error);
    return new Response(
      JSON.stringify({ 
        success: false, 
        error: 'Error restoring data', 
        details: error.message 
      }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
</file>

<file path="supabase/functions/secure-webhook-proxy/index.ts">
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Initialize Supabase client
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )

    // Get the user from the Authorization header
    const authHeader = req.headers.get('Authorization')
    if (!authHeader) {
      throw new Error('No authorization header')
    }

    const { data: { user }, error: authError } = await supabaseClient.auth.getUser(
      authHeader.replace('Bearer ', '')
    )

    if (authError || !user) {
      throw new Error('Unauthorized')
    }

    // Get user's organization
    const { data: userData, error: userError } = await supabaseClient
      .from('users')
      .select('organization_id')
      .eq('auth_user_id', user.id)
      .single()

    if (userError || !userData) {
      throw new Error('User not found')
    }

    // Parse request body with size limit (2MB max)
    const MAX_PAYLOAD_SIZE = 2 * 1024 * 1024; // 2MB
    const contentLength = req.headers.get('content-length');
    if (contentLength && parseInt(contentLength) > MAX_PAYLOAD_SIZE) {
      throw new Error('Payload too large');
    }

    const body = await req.json()
    const { webhookUrl, data } = body

    if (!webhookUrl || !data) {
      throw new Error('Missing webhookUrl or data')
    }

    // Enhanced URL validation - enforce HTTPS and whitelist
    const allowedDomains = [
      'hooks.zapier.com',
      'webhook.site', 
      'n8n.cloud',
      'pipedream.com',
      'rquevedos.app.n8n.cloud' // Add specific n8n instance
    ];

    let url: URL;
    try {
      url = new URL(webhookUrl);
    } catch {
      throw new Error('Invalid webhook URL format');
    }

    // Security checks
    if (url.protocol !== 'https:') {
      throw new Error('Only HTTPS URLs are allowed');
    }

    // Reject IP addresses and non-standard ports
    if (/^\d+\.\d+\.\d+\.\d+$/.test(url.hostname)) {
      throw new Error('IP addresses are not allowed');
    }

    if (url.port && !['80', '443', ''].includes(url.port)) {
      throw new Error('Non-standard ports are not allowed');
    }

    // Check if domain is in allowlist
    const isAllowed = allowedDomains.some(domain => 
      url.hostname === domain || url.hostname.endsWith('.' + domain)
    );

    if (!isAllowed) {
      throw new Error(`Domain ${url.hostname} is not in the allowed list`);
    }

    // Generate request ID for observability
    const requestId = crypto.randomUUID();
    
    // Prepare payload with organization and user context
    const payload = {
      ...data,
      organization_id: userData.organization_id,
      user_id: user.id,
      timestamp: new Date().toISOString(),
      request_id: requestId
    }

    console.log(`[${requestId}] Proxying request to:`, webhookUrl);

    console.log('Proxying request to:', webhookUrl);

    // Make the webhook request with timeout and proper error handling
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

    try {
      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'EVA-System-Webhook-Proxy/1.0'
        },
        body: JSON.stringify(payload),
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      const responseText = await response.text();
      let responseData;
      try {
        responseData = JSON.parse(responseText);
      } catch {
        responseData = { message: responseText };
      }

      console.log('Webhook response status:', response.status);

      return new Response(
        JSON.stringify({
          success: response.ok,
          status: response.status,
          data: responseData
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: response.ok ? 200 : 400,
        },
      )
    } catch (fetchError) {
      clearTimeout(timeoutId);
      if (fetchError.name === 'AbortError') {
        throw new Error('Webhook request timed out');
      }
      throw new Error(`Webhook request failed: ${fetchError.message}`);
    }

  } catch (error) {
    console.error('Webhook proxy error:', error)
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      },
    )
  }
})
</file>

<file path="supabase/functions/shared/error-handler.ts">
/**
 * Error Handling Utilities
 * Standardized error handling for all edge functions
 */

import { errorResponse } from './responses.ts';
import { InstagramApiError } from './instagram-api.ts';

/**
 * Handle and format errors consistently
 */
export function handleError(error: unknown): Response {
  console.error('Function error:', error);
  
  // Instagram API errors
  if (error instanceof InstagramApiError) {
    console.error('Instagram API error:', {
      message: error.message,
      statusCode: error.statusCode,
      fbError: error.fbError
    });
    return errorResponse(error.message, error.statusCode || 500);
  }
  
  // Standard Error objects
  if (error instanceof Error) {
    const message = error.message;
    
    // Common error patterns
    if (message.includes('Unauthorized') || message.includes('Invalid authentication')) {
      return errorResponse(message, 401);
    }
    if (message.includes('Forbidden') || message.includes('Access denied')) {
      return errorResponse(message, 403);
    }
    if (message.includes('Not found')) {
      return errorResponse(message, 404);
    }
    if (message.includes('Bad request') || message.includes('Invalid')) {
      return errorResponse(message, 400);
    }
    
    return errorResponse(message, 500);
  }
  
  // Unknown error type
  return errorResponse('An unexpected error occurred', 500);
}

/**
 * Wrap async function with error handling
 */
export function withErrorHandling<T extends unknown[], R>(
  fn: (...args: T) => Promise<R>
): (...args: T) => Promise<R | Response> {
  return async (...args: T): Promise<R | Response> => {
    try {
      return await fn(...args);
    } catch (error) {
      return handleError(error);
    }
  };
}

/**
 * Assert condition or throw error
 */
export function assert(
  condition: unknown,
  message: string,
  statusCode = 400
): asserts condition {
  if (!condition) {
    const error = new Error(message);
    (error as Error & { statusCode: number }).statusCode = statusCode;
    throw error;
  }
}

/**
 * Validate required fields in request body
 */
export function validateRequired<T extends Record<string, unknown>>(
  data: T,
  fields: (keyof T)[]
): void {
  const missing = fields.filter(field => !data[field]);
  
  if (missing.length > 0) {
    throw new Error(`Missing required fields: ${missing.join(', ')}`);
  }
}
</file>

<file path="supabase/functions/shared/responses.ts">
/**
 * HTTP Response Utilities
 * Standardized response creation for consistent API responses
 */

import { corsHeaders } from './constants.ts';

export interface JsonResponseOptions {
  status?: number;
  headers?: HeadersInit;
}

/**
 * Create a JSON response with CORS headers
 */
export function jsonResponse(
  data: unknown,
  options: JsonResponseOptions = {}
): Response {
  const { status = 200, headers = {} } = options;
  
  return new Response(
    JSON.stringify(data),
    {
      status,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
        ...headers
      }
    }
  );
}

/**
 * Create an error response
 */
export function errorResponse(
  error: string | Error,
  status = 500
): Response {
  const message = typeof error === 'string' ? error : error.message;
  return jsonResponse({ error: message }, { status });
}

/**
 * Create a success response with data
 */
export function successResponse(data: unknown): Response {
  return jsonResponse({ success: true, ...data });
}

/**
 * Create an unauthorized (401) response
 */
export function unauthorizedResponse(message = 'Authentication required'): Response {
  return errorResponse(message, 401);
}

/**
 * Create a forbidden (403) response
 */
export function forbiddenResponse(message = 'Access denied'): Response {
  return errorResponse(message, 403);
}

/**
 * Create a not found (404) response
 */
export function notFoundResponse(message = 'Resource not found'): Response {
  return errorResponse(message, 404);
}

/**
 * Create a bad request (400) response
 */
export function badRequestResponse(message = 'Bad request'): Response {
  return errorResponse(message, 400);
}

/**
 * Handle CORS preflight requests
 */
export function corsPreflightResponse(): Response {
  return new Response(null, { headers: corsHeaders });
}
</file>

<file path="supabase/functions/shared/test-crypto.sh">
#!/bin/bash
# Quick test script for crypto functions
# Usage: ./test-crypto.sh

deno run --allow-env --allow-net supabase/functions/shared/crypto.test.ts
</file>

<file path="supabase/functions/deno.json">
{
  "compilerOptions": {
    "allowJs": true,
    "lib": ["deno.window"],
    "strict": true
  },
  "importMap": "./import_map.json"
}
</file>

<file path="supabase/functions/import_map.json">
{
  "imports": {
    "supabase": "https://esm.sh/@supabase/supabase-js@2",
    "@/shared/": "./shared/",
    "@/constants": "./shared/constants.ts",
    "@/types": "./shared/types.ts",
    "@/responses": "./shared/responses.ts",
    "@/crypto": "./shared/crypto.ts",
    "@/auth": "./shared/auth.ts",
    "@/instagram-api": "./shared/instagram-api.ts",
    "@/error-handler": "./shared/error-handler.ts"
  }
}
</file>

<file path="supabase/migrations/20250101000000_add_story_referral_to_mention_type.sql">
-- Add 'story_referral' to the mention_type constraint
-- This is needed for the Story Insights Cron feature

ALTER TABLE public.social_mentions 
DROP CONSTRAINT IF EXISTS social_mentions_mention_type_check;

ALTER TABLE public.social_mentions 
ADD CONSTRAINT social_mentions_mention_type_check 
CHECK (mention_type IN ('mention', 'tag', 'hashtag', 'story', 'comment', 'story_referral'));
</file>

<file path="supabase/migrations/20250729023524-9842c490-c174-43d9-a909-c10b66c00968.sql">
-- Create custom types
CREATE TYPE public.user_role AS ENUM ('admin', 'rrpp');
CREATE TYPE public.user_status AS ENUM ('active', 'inactive');
CREATE TYPE public.embassador_category AS ENUM ('bronze', 'silver', 'gold', 'diamond');
CREATE TYPE public.embassador_status AS ENUM ('pending', 'approved', 'rejected');
CREATE TYPE public.task_status AS ENUM ('uploaded', 'invalid', 'completed', 'in_progress');
CREATE TYPE public.notification_type AS ENUM ('story_deleted', 'task_expired', 'token_expiry');
CREATE TYPE public.invitation_status AS ENUM ('active', 'expired', 'used');

-- Create organizations table
CREATE TABLE public.organizations (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    main_instagram_account TEXT,
    instagram_token TEXT,
    token_expiry TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create users table (Staff y RRPP)
CREATE TABLE public.users (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    auth_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES public.organizations(id) ON DELETE CASCADE NOT NULL,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    role public.user_role NOT NULL DEFAULT 'rrpp',
    status public.user_status NOT NULL DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create embassadors table
CREATE TABLE public.embassadors (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    organization_id UUID REFERENCES public.organizations(id) ON DELETE CASCADE NOT NULL,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    rut TEXT NOT NULL,
    email TEXT NOT NULL,
    date_of_birth DATE NOT NULL,
    instagram_user TEXT NOT NULL,
    follower_count INTEGER DEFAULT 0,
    profile_public BOOLEAN DEFAULT true,
    global_points INTEGER DEFAULT 0,
    global_category public.embassador_category DEFAULT 'bronze',
    status public.embassador_status DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    UNIQUE(organization_id, email),
    UNIQUE(organization_id, rut)
);

-- Create events table
CREATE TABLE public.events (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    organization_id UUID REFERENCES public.organizations(id) ON DELETE CASCADE NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    location TEXT,
    event_date DATE NOT NULL,
    start_time TIME,
    end_time TIME,
    instagram_account TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create tasks table
CREATE TABLE public.tasks (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    embassador_id UUID REFERENCES public.embassadors(id) ON DELETE CASCADE NOT NULL,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE NOT NULL,
    instagram_story_id TEXT,
    story_url TEXT,
    status public.task_status DEFAULT 'uploaded',
    upload_time TIMESTAMP WITH TIME ZONE,
    expiry_time TIMESTAMP WITH TIME ZONE,
    points_earned INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create notifications table
CREATE TABLE public.notifications (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES public.organizations(id) ON DELETE CASCADE NOT NULL,
    message TEXT NOT NULL,
    type public.notification_type NOT NULL,
    read_status BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create invitation_tokens table
CREATE TABLE public.invitation_tokens (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    organization_id UUID REFERENCES public.organizations(id) ON DELETE CASCADE NOT NULL,
    email TEXT NOT NULL,
    token TEXT UNIQUE NOT NULL,
    expiry TIMESTAMP WITH TIME ZONE NOT NULL,
    status public.invitation_status DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable RLS on all tables
ALTER TABLE public.organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.embassadors ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invitation_tokens ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for organizations
CREATE POLICY "Users can view their organization" ON public.organizations
    FOR SELECT USING (
        id IN (
            SELECT organization_id FROM public.users 
            WHERE auth_user_id = auth.uid()
        )
    );

CREATE POLICY "Authenticated users can create organizations" ON public.organizations
    FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);

CREATE POLICY "Admins can update their organization" ON public.organizations
    FOR UPDATE USING (
        id IN (
            SELECT organization_id FROM public.users 
            WHERE auth_user_id = auth.uid() AND role = 'admin'
        )
    );

-- Create RLS policies for users
CREATE POLICY "Users can view org users" ON public.users
    FOR SELECT USING (
        organization_id IN (
            SELECT organization_id FROM public.users 
            WHERE auth_user_id = auth.uid()
        )
    );

CREATE POLICY "Admins can manage users" ON public.users
    FOR ALL USING (
        organization_id IN (
            SELECT organization_id FROM public.users 
            WHERE auth_user_id = auth.uid() AND role = 'admin'
        )
    );

-- Create RLS policies for embassadors
CREATE POLICY "Users can view org embassadors" ON public.embassadors
    FOR SELECT USING (
        organization_id IN (
            SELECT organization_id FROM public.users 
            WHERE auth_user_id = auth.uid()
        )
    );

CREATE POLICY "Users can manage embassadors" ON public.embassadors
    FOR ALL USING (
        organization_id IN (
            SELECT organization_id FROM public.users 
            WHERE auth_user_id = auth.uid()
        )
    );

-- Create RLS policies for events
CREATE POLICY "Users can view org events" ON public.events
    FOR SELECT USING (
        organization_id IN (
            SELECT organization_id FROM public.users 
            WHERE auth_user_id = auth.uid()
        )
    );

CREATE POLICY "Users can manage events" ON public.events
    FOR ALL USING (
        organization_id IN (
            SELECT organization_id FROM public.users 
            WHERE auth_user_id = auth.uid()
        )
    );

-- Create RLS policies for tasks
CREATE POLICY "Users can view org tasks" ON public.tasks
    FOR SELECT USING (
        embassador_id IN (
            SELECT e.id FROM public.embassadors e
            JOIN public.users u ON e.organization_id = u.organization_id
            WHERE u.auth_user_id = auth.uid()
        )
    );

CREATE POLICY "Users can manage tasks" ON public.tasks
    FOR ALL USING (
        embassador_id IN (
            SELECT e.id FROM public.embassadors e
            JOIN public.users u ON e.organization_id = u.organization_id
            WHERE u.auth_user_id = auth.uid()
        )
    );

-- Create RLS policies for notifications
CREATE POLICY "Users can view their notifications" ON public.notifications
    FOR SELECT USING (
        user_id IN (
            SELECT id FROM public.users 
            WHERE auth_user_id = auth.uid()
        )
    );

CREATE POLICY "System can create notifications" ON public.notifications
    FOR INSERT WITH CHECK (true);

-- Create RLS policies for invitation_tokens
CREATE POLICY "Admins can manage invitations" ON public.invitation_tokens
    FOR ALL USING (
        organization_id IN (
            SELECT organization_id FROM public.users 
            WHERE auth_user_id = auth.uid() AND role = 'admin'
        )
    );

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create indexes for better performance
CREATE INDEX idx_users_auth_user_id ON public.users(auth_user_id);
CREATE INDEX idx_users_organization_id ON public.users(organization_id);
CREATE INDEX idx_embassadors_organization_id ON public.embassadors(organization_id);
CREATE INDEX idx_events_organization_id ON public.events(organization_id);
CREATE INDEX idx_tasks_embassador_id ON public.tasks(embassador_id);
CREATE INDEX idx_tasks_event_id ON public.tasks(event_id);
CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
CREATE INDEX idx_notifications_organization_id ON public.notifications(organization_id);
</file>

<file path="supabase/migrations/20250729141810-f50a6199-f737-4438-adcf-b709b22811b8.sql">
-- Add new fields to embassadors table
ALTER TABLE public.embassadors 
ADD COLUMN performance_status performance_status DEFAULT 'cumple'::performance_status,
ADD COLUMN profile_picture_url TEXT,
ADD COLUMN created_by_user_id UUID,
ADD COLUMN updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
ADD COLUMN events_participated INTEGER DEFAULT 0,
ADD COLUMN completed_tasks INTEGER DEFAULT 0,
ADD COLUMN failed_tasks INTEGER DEFAULT 0,
ADD COLUMN approved_by UUID;

-- Create performance_status enum
CREATE TYPE performance_status AS ENUM ('no_cumple', 'cumple', 'advertencia', 'exclusivo');

-- Add new fields to events table
ALTER TABLE public.events 
ADD COLUMN is_cyclic BOOLEAN DEFAULT false,
ADD COLUMN cyclic_type cyclic_type,
ADD COLUMN main_hashtag TEXT,
ADD COLUMN active BOOLEAN DEFAULT true,
ADD COLUMN stats_json JSONB DEFAULT '{}';

-- Create cyclic_type enum
CREATE TYPE cyclic_type AS ENUM ('semanal', 'mensual', 'personalizado');

-- Add new fields to tasks table
ALTER TABLE public.tasks
ADD COLUMN task_type task_type DEFAULT 'story'::task_type,
ADD COLUMN reposted_from_story_id TEXT,
ADD COLUMN time_in_air INTEGER DEFAULT 0,
ADD COLUMN last_status_update TIMESTAMP WITH TIME ZONE DEFAULT now();

-- Create task_type enum
CREATE TYPE task_type AS ENUM ('story', 'repost');

-- Add new fields to notifications table
ALTER TABLE public.notifications
ADD COLUMN target_type target_type DEFAULT 'user'::target_type,
ADD COLUMN target_id UUID,
ADD COLUMN priority notification_priority DEFAULT 'normal'::notification_priority;

-- Create target_type enum
CREATE TYPE target_type AS ENUM ('user', 'rrpp', 'admin');

-- Create notification_priority enum
CREATE TYPE notification_priority AS ENUM ('low', 'normal', 'high');

-- Add settings_json to organizations table
ALTER TABLE public.organizations
ADD COLUMN settings_json JSONB DEFAULT '{"scoring_rules": {"story_uploaded": 1, "story_completed": 2, "story_invalid": -1}, "categories": {"bronze": 0, "silver": 50, "gold": 150, "diamond": 300}}';

-- Create leaderboards table
CREATE TABLE public.leaderboards (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE,
    embassador_id UUID REFERENCES public.embassadors(id) ON DELETE CASCADE,
    points INTEGER DEFAULT 0,
    rank INTEGER,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    UNIQUE(event_id, embassador_id)
);

-- Create import_logs table
CREATE TABLE public.import_logs (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    organization_id UUID REFERENCES public.organizations(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
    type import_export_type NOT NULL,
    source import_source NOT NULL,
    file_name TEXT,
    result_json JSONB DEFAULT '{}',
    status import_status DEFAULT 'pending'::import_status,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create import_export_type enum
CREATE TYPE import_export_type AS ENUM ('import', 'export');

-- Create import_source enum
CREATE TYPE import_source AS ENUM ('manual', 'google_drive', 'excel', 'csv');

-- Create import_status enum
CREATE TYPE import_status AS ENUM ('pending', 'processing', 'completed', 'failed');

-- Create embassador_events junction table
CREATE TABLE public.embassador_events (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    embassador_id UUID REFERENCES public.embassadors(id) ON DELETE CASCADE NOT NULL,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE NOT NULL,
    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    assigned_by UUID REFERENCES public.users(id) ON DELETE SET NULL,
    UNIQUE(embassador_id, event_id)
);

-- Create event_instagram_accounts table
CREATE TABLE public.event_instagram_accounts (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE NOT NULL,
    instagram_account TEXT NOT NULL,
    is_primary BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create user_organization_roles table
CREATE TABLE public.user_organization_roles (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
    organization_id UUID REFERENCES public.organizations(id) ON DELETE CASCADE NOT NULL,
    role user_role NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    UNIQUE(user_id, organization_id)
);

-- Enable RLS on new tables
ALTER TABLE public.leaderboards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.import_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.embassador_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_instagram_accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_organization_roles ENABLE ROW LEVEL SECURITY;

-- RLS Policies for leaderboards
CREATE POLICY "Users can view org leaderboards" 
ON public.leaderboards 
FOR SELECT 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

CREATE POLICY "Users can manage leaderboards" 
ON public.leaderboards 
FOR ALL 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

-- RLS Policies for import_logs
CREATE POLICY "Users can view org import logs" 
ON public.import_logs 
FOR SELECT 
USING (organization_id IN (
    SELECT organization_id FROM users WHERE auth_user_id = auth.uid()
));

CREATE POLICY "Users can create import logs" 
ON public.import_logs 
FOR INSERT 
WITH CHECK (organization_id IN (
    SELECT organization_id FROM users WHERE auth_user_id = auth.uid()
));

-- RLS Policies for embassador_events
CREATE POLICY "Users can view org embassador events" 
ON public.embassador_events 
FOR SELECT 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

CREATE POLICY "Users can manage embassador events" 
ON public.embassador_events 
FOR ALL 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

-- RLS Policies for event_instagram_accounts
CREATE POLICY "Users can view org event instagram accounts" 
ON public.event_instagram_accounts 
FOR SELECT 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

CREATE POLICY "Users can manage event instagram accounts" 
ON public.event_instagram_accounts 
FOR ALL 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

-- RLS Policies for user_organization_roles
CREATE POLICY "Users can view their org roles" 
ON public.user_organization_roles 
FOR SELECT 
USING (organization_id IN (
    SELECT organization_id FROM users WHERE auth_user_id = auth.uid()
));

CREATE POLICY "Admins can manage org roles" 
ON public.user_organization_roles 
FOR ALL 
USING (organization_id IN (
    SELECT organization_id FROM users 
    WHERE auth_user_id = auth.uid() AND role = 'admin'
));

-- Create triggers for updated_at columns
CREATE TRIGGER update_embassadors_updated_at
    BEFORE UPDATE ON public.embassadors
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_leaderboards_updated_at
    BEFORE UPDATE ON public.leaderboards
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_tasks_last_status_update
    BEFORE UPDATE ON public.tasks
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();
</file>

<file path="supabase/migrations/20250729142148-b68c29e6-6e84-4bdd-98f4-9a087c62f65e.sql">
-- Create all enums first
CREATE TYPE performance_status AS ENUM ('no_cumple', 'cumple', 'advertencia', 'exclusivo');
CREATE TYPE cyclic_type AS ENUM ('semanal', 'mensual', 'personalizado');
CREATE TYPE task_type AS ENUM ('story', 'repost');
CREATE TYPE target_type AS ENUM ('user', 'rrpp', 'admin');
CREATE TYPE notification_priority AS ENUM ('low', 'normal', 'high');
CREATE TYPE import_export_type AS ENUM ('import', 'export');
CREATE TYPE import_source AS ENUM ('manual', 'google_drive', 'excel', 'csv');
CREATE TYPE import_status AS ENUM ('pending', 'processing', 'completed', 'failed');

-- Add new fields to embassadors table
ALTER TABLE public.embassadors 
ADD COLUMN performance_status performance_status DEFAULT 'cumple'::performance_status,
ADD COLUMN profile_picture_url TEXT,
ADD COLUMN created_by_user_id UUID,
ADD COLUMN updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
ADD COLUMN events_participated INTEGER DEFAULT 0,
ADD COLUMN completed_tasks INTEGER DEFAULT 0,
ADD COLUMN failed_tasks INTEGER DEFAULT 0,
ADD COLUMN approved_by UUID;

-- Add new fields to events table
ALTER TABLE public.events 
ADD COLUMN is_cyclic BOOLEAN DEFAULT false,
ADD COLUMN cyclic_type cyclic_type,
ADD COLUMN main_hashtag TEXT,
ADD COLUMN active BOOLEAN DEFAULT true,
ADD COLUMN stats_json JSONB DEFAULT '{}';

-- Add new fields to tasks table
ALTER TABLE public.tasks
ADD COLUMN task_type task_type DEFAULT 'story'::task_type,
ADD COLUMN reposted_from_story_id TEXT,
ADD COLUMN time_in_air INTEGER DEFAULT 0,
ADD COLUMN last_status_update TIMESTAMP WITH TIME ZONE DEFAULT now();

-- Add new fields to notifications table
ALTER TABLE public.notifications
ADD COLUMN target_type target_type DEFAULT 'user'::target_type,
ADD COLUMN target_id UUID,
ADD COLUMN priority notification_priority DEFAULT 'normal'::notification_priority;

-- Add settings_json to organizations table
ALTER TABLE public.organizations
ADD COLUMN settings_json JSONB DEFAULT '{"scoring_rules": {"story_uploaded": 1, "story_completed": 2, "story_invalid": -1}, "categories": {"bronze": 0, "silver": 50, "gold": 150, "diamond": 300}}';

-- Create leaderboards table
CREATE TABLE public.leaderboards (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE,
    embassador_id UUID REFERENCES public.embassadors(id) ON DELETE CASCADE,
    points INTEGER DEFAULT 0,
    rank INTEGER,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    UNIQUE(event_id, embassador_id)
);

-- Create import_logs table
CREATE TABLE public.import_logs (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    organization_id UUID REFERENCES public.organizations(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
    type import_export_type NOT NULL,
    source import_source NOT NULL,
    file_name TEXT,
    result_json JSONB DEFAULT '{}',
    status import_status DEFAULT 'pending'::import_status,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create embassador_events junction table
CREATE TABLE public.embassador_events (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    embassador_id UUID REFERENCES public.embassadors(id) ON DELETE CASCADE NOT NULL,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE NOT NULL,
    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    assigned_by UUID REFERENCES public.users(id) ON DELETE SET NULL,
    UNIQUE(embassador_id, event_id)
);

-- Create event_instagram_accounts table
CREATE TABLE public.event_instagram_accounts (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE NOT NULL,
    instagram_account TEXT NOT NULL,
    is_primary BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create user_organization_roles table
CREATE TABLE public.user_organization_roles (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
    organization_id UUID REFERENCES public.organizations(id) ON DELETE CASCADE NOT NULL,
    role user_role NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    UNIQUE(user_id, organization_id)
);

-- Enable RLS on new tables
ALTER TABLE public.leaderboards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.import_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.embassador_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_instagram_accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_organization_roles ENABLE ROW LEVEL SECURITY;

-- RLS Policies for leaderboards
CREATE POLICY "Users can view org leaderboards" 
ON public.leaderboards 
FOR SELECT 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

CREATE POLICY "Users can manage leaderboards" 
ON public.leaderboards 
FOR ALL 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

-- RLS Policies for import_logs
CREATE POLICY "Users can view org import logs" 
ON public.import_logs 
FOR SELECT 
USING (organization_id IN (
    SELECT organization_id FROM users WHERE auth_user_id = auth.uid()
));

CREATE POLICY "Users can create import logs" 
ON public.import_logs 
FOR INSERT 
WITH CHECK (organization_id IN (
    SELECT organization_id FROM users WHERE auth_user_id = auth.uid()
));

-- RLS Policies for embassador_events
CREATE POLICY "Users can view org embassador events" 
ON public.embassador_events 
FOR SELECT 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

CREATE POLICY "Users can manage embassador events" 
ON public.embassador_events 
FOR ALL 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

-- RLS Policies for event_instagram_accounts
CREATE POLICY "Users can view org event instagram accounts" 
ON public.event_instagram_accounts 
FOR SELECT 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

CREATE POLICY "Users can manage event instagram accounts" 
ON public.event_instagram_accounts 
FOR ALL 
USING (event_id IN (
    SELECT e.id FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

-- RLS Policies for user_organization_roles
CREATE POLICY "Users can view their org roles" 
ON public.user_organization_roles 
FOR SELECT 
USING (organization_id IN (
    SELECT organization_id FROM users WHERE auth_user_id = auth.uid()
));

CREATE POLICY "Admins can manage org roles" 
ON public.user_organization_roles 
FOR ALL 
USING (organization_id IN (
    SELECT organization_id FROM users 
    WHERE auth_user_id = auth.uid() AND role = 'admin'
));

-- Create triggers for updated_at columns
CREATE TRIGGER update_embassadors_updated_at
    BEFORE UPDATE ON public.embassadors
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_leaderboards_updated_at
    BEFORE UPDATE ON public.leaderboards
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();
</file>

<file path="supabase/migrations/20250730022244-040c1408-8ec0-4177-9a8d-3ef292ac3adf.sql">
-- Create enum types for new functionality
CREATE TYPE public.event_type AS ENUM ('lanzamiento', 'feria', 'campa√±a_digital', 'activacion', 'otro');
CREATE TYPE public.checklist_status AS ENUM ('pending', 'in_progress', 'done');
CREATE TYPE public.user_role_extended AS ENUM ('admin', 'rrpp', 'cliente_viewer');

-- Create event_phases table
CREATE TABLE public.event_phases (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    event_id UUID NOT NULL,
    name TEXT NOT NULL,
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create event_checklists table
CREATE TABLE public.event_checklists (
    id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    event_id UUID NOT NULL,
    description TEXT NOT NULL,
    assigned_to UUID,
    status checklist_status NOT NULL DEFAULT 'pending',
    deadline TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Add new columns to events table
ALTER TABLE public.events 
ADD COLUMN budget_estimate NUMERIC,
ADD COLUMN objective TEXT,
ADD COLUMN client_name TEXT,
ADD COLUMN event_type event_type DEFAULT 'otro';

-- Add new columns to notifications table
ALTER TABLE public.notifications 
ADD COLUMN seen_at TIMESTAMP WITH TIME ZONE;

-- Add new columns to embassadors table
ALTER TABLE public.embassadors 
ADD COLUMN last_activity_at TIMESTAMP WITH TIME ZONE DEFAULT now();

-- Enable RLS on new tables
ALTER TABLE public.event_phases ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_checklists ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for event_phases
CREATE POLICY "Users can view org event phases" 
ON public.event_phases 
FOR SELECT 
USING (event_id IN (
    SELECT e.id 
    FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

CREATE POLICY "Users can manage event phases" 
ON public.event_phases 
FOR ALL 
USING (event_id IN (
    SELECT e.id 
    FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

-- Create RLS policies for event_checklists
CREATE POLICY "Users can view org event checklists" 
ON public.event_checklists 
FOR SELECT 
USING (event_id IN (
    SELECT e.id 
    FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

CREATE POLICY "Users can manage event checklists" 
ON public.event_checklists 
FOR ALL 
USING (event_id IN (
    SELECT e.id 
    FROM events e 
    JOIN users u ON e.organization_id = u.organization_id 
    WHERE u.auth_user_id = auth.uid()
));

-- Create triggers for updated_at columns
CREATE TRIGGER update_event_phases_updated_at
    BEFORE UPDATE ON public.event_phases
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_event_checklists_updated_at
    BEFORE UPDATE ON public.event_checklists
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

-- Add indexes for better performance
CREATE INDEX idx_event_phases_event_id ON public.event_phases(event_id);
CREATE INDEX idx_event_phases_dates ON public.event_phases(start_date, end_date);
CREATE INDEX idx_event_checklists_event_id ON public.event_checklists(event_id);
CREATE INDEX idx_event_checklists_assigned_to ON public.event_checklists(assigned_to);
CREATE INDEX idx_event_checklists_status ON public.event_checklists(status);
CREATE INDEX idx_notifications_seen_at ON public.notifications(seen_at);
CREATE INDEX idx_embassadors_last_activity ON public.embassadors(last_activity_at);
</file>

<file path="supabase/migrations/20250731021231_13122cbb-6a33-404c-ae82-ff1287b53390.sql">
-- Crear tabla profiles para datos extendidos de usuarios
CREATE TABLE public.profiles (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  phone text,
  social_links jsonb DEFAULT '{}',
  bio text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  UNIQUE(user_id)
);

-- Crear tabla cards para feedback UX
CREATE TABLE public.cards (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  event_id uuid REFERENCES public.events(id) ON DELETE CASCADE,
  type text NOT NULL CHECK (type IN ('success', 'error', 'warning', 'info')),
  message text NOT NULL,
  read_status boolean DEFAULT false,
  created_at timestamp with time zone NOT NULL DEFAULT now()
);

-- Crear tabla event_logs para historial de acciones
CREATE TABLE public.event_logs (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  event_id uuid REFERENCES public.events(id) ON DELETE CASCADE,
  action text NOT NULL,
  details jsonb DEFAULT '{}',
  created_at timestamp with time zone NOT NULL DEFAULT now()
);

-- Habilitar RLS en todas las tablas
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_logs ENABLE ROW LEVEL SECURITY;

-- Pol√≠ticas para profiles
CREATE POLICY "Users can view their own profile" 
ON public.profiles 
FOR SELECT 
USING (user_id IN (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

CREATE POLICY "Users can update their own profile" 
ON public.profiles 
FOR UPDATE 
USING (user_id IN (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

CREATE POLICY "Users can insert their own profile" 
ON public.profiles 
FOR INSERT 
WITH CHECK (user_id IN (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

-- Pol√≠ticas para cards
CREATE POLICY "Users can view their own cards" 
ON public.cards 
FOR SELECT 
USING (user_id IN (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

CREATE POLICY "System can create cards" 
ON public.cards 
FOR INSERT 
WITH CHECK (true);

CREATE POLICY "Users can update their own cards" 
ON public.cards 
FOR UPDATE 
USING (user_id IN (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

-- Pol√≠ticas para event_logs
CREATE POLICY "Users can view org event logs" 
ON public.event_logs 
FOR SELECT 
USING (user_id IN (SELECT id FROM public.users WHERE auth_user_id = auth.uid() AND organization_id IN (SELECT organization_id FROM public.users WHERE auth_user_id = auth.uid())));

CREATE POLICY "Users can create event logs" 
ON public.event_logs 
FOR INSERT 
WITH CHECK (user_id IN (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

-- Triggers para updated_at
CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON public.profiles
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();

-- Funci√≥n para crear logs autom√°ticamente
CREATE OR REPLACE FUNCTION public.create_event_log(
  p_user_id uuid,
  p_event_id uuid,
  p_action text,
  p_details jsonb DEFAULT '{}'
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.event_logs (user_id, event_id, action, details)
  VALUES (p_user_id, p_event_id, p_action, p_details);
END;
$$;

-- Funci√≥n para crear cards de feedback
CREATE OR REPLACE FUNCTION public.create_feedback_card(
  p_user_id uuid,
  p_event_id uuid,
  p_type text,
  p_message text
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.cards (user_id, event_id, type, message)
  VALUES (p_user_id, p_event_id, p_type, p_message);
END;
$$;
</file>

<file path="supabase/migrations/20250731021320_fbba82a6-30ba-49a1-b3f7-80ce436002ca.sql">
-- Habilitar RLS en tablas que lo necesitan
ALTER TABLE public.instagram_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.meta_sync_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.social_insights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.social_pages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.story_links ENABLE ROW LEVEL SECURITY;

-- Corregir funciones con search_path
CREATE OR REPLACE FUNCTION public.create_event_log(
  p_user_id uuid,
  p_event_id uuid,
  p_action text,
  p_details jsonb DEFAULT '{}'
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.event_logs (user_id, event_id, action, details)
  VALUES (p_user_id, p_event_id, p_action, p_details);
END;
$$;

CREATE OR REPLACE FUNCTION public.create_feedback_card(
  p_user_id uuid,
  p_event_id uuid,
  p_type text,
  p_message text
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.cards (user_id, event_id, type, message)
  VALUES (p_user_id, p_event_id, p_type, p_message);
END;
$$;

-- Pol√≠ticas b√°sicas para tablas sin RLS
CREATE POLICY "Public read access" ON public.instagram_profiles FOR SELECT USING (true);
CREATE POLICY "System can manage instagram profiles" ON public.instagram_profiles FOR ALL USING (true);

CREATE POLICY "System can manage meta sync logs" ON public.meta_sync_logs FOR ALL USING (true);

CREATE POLICY "System can manage social insights" ON public.social_insights FOR ALL USING (true);

CREATE POLICY "System can manage social pages" ON public.social_pages FOR ALL USING (true);

CREATE POLICY "System can manage story links" ON public.story_links FOR ALL USING (true);
</file>

<file path="supabase/migrations/20250731021347_23254cae-680e-4da3-adab-540d93726138.sql">
-- Corregir la funci√≥n update_updated_at_column con search_path
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;
</file>

<file path="supabase/migrations/20250805155412_1b2a65fd-49fd-4baf-afee-177d112872c2.sql">
-- Fix infinite recursion in users table RLS policies
-- First, drop existing problematic policies
DROP POLICY IF EXISTS "Users can access own data" ON public.users;
DROP POLICY IF EXISTS "Users can view own profile" ON public.users;
DROP POLICY IF EXISTS "Users can update own profile" ON public.users;

-- Create new non-recursive policies for users table
CREATE POLICY "Users can view own data"
ON public.users FOR SELECT
USING (auth_user_id = auth.uid());

CREATE POLICY "Users can update own data"
ON public.users FOR UPDATE
USING (auth_user_id = auth.uid());

-- Allow users to insert their own record (for registration)
CREATE POLICY "Users can insert own record"
ON public.users FOR INSERT
WITH CHECK (auth_user_id = auth.uid());
</file>

<file path="supabase/migrations/20250806153145_b3fec699-78c3-4da8-85a6-f2086f2647f3.sql">
-- Fix infinite recursion in embassadors table RLS policies
-- Drop existing policies that cause recursion
DROP POLICY IF EXISTS "Users can manage embassadors" ON public.embassadors;
DROP POLICY IF EXISTS "Users can view org embassadors" ON public.embassadors;

-- Create a security definer function to get user's organization safely
CREATE OR REPLACE FUNCTION public.get_user_organization_id()
RETURNS UUID
LANGUAGE SQL
SECURITY DEFINER
STABLE
AS $$
  SELECT organization_id FROM public.users WHERE auth_user_id = auth.uid() LIMIT 1;
$$;

-- Create new non-recursive policies for embassadors table
CREATE POLICY "Users can view org embassadors" 
ON public.embassadors 
FOR SELECT 
USING (organization_id = public.get_user_organization_id());

CREATE POLICY "Users can insert embassadors" 
ON public.embassadors 
FOR INSERT 
WITH CHECK (organization_id = public.get_user_organization_id());

CREATE POLICY "Users can update org embassadors" 
ON public.embassadors 
FOR UPDATE 
USING (organization_id = public.get_user_organization_id());

CREATE POLICY "Users can delete org embassadors" 
ON public.embassadors 
FOR DELETE 
USING (organization_id = public.get_user_organization_id());
</file>

<file path="supabase/migrations/20250806153214_ef5be62d-c47e-4398-a76b-a452789108cc.sql">
-- Fix security definer function with proper search path
CREATE OR REPLACE FUNCTION public.get_user_organization_id()
RETURNS UUID
LANGUAGE SQL
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT organization_id FROM public.users WHERE auth_user_id = auth.uid() LIMIT 1;
$$;
</file>

<file path="supabase/migrations/20250806154620_3fd6529b-393c-42a0-9bde-a19105b7915c.sql">
-- Fix the infinite recursion issue in users table RLS policies
-- Remove the problematic policy that causes recursion
DROP POLICY IF EXISTS "Users can view org users" ON public.users;

-- Create a new policy that avoids recursion by using the security definer function
CREATE POLICY "Users can view org users" ON public.users
FOR SELECT USING (
  organization_id = get_user_organization_id()
);
</file>

<file path="supabase/migrations/20250806164708_28757176-ea58-41dc-965e-c451e29c8b8e.sql">
-- Drop the problematic policy and recreate it properly
DROP POLICY IF EXISTS "Users can view org users" ON public.users;

-- Create the corrected policy using the security definer function
CREATE POLICY "Users can view org users" 
ON public.users 
FOR SELECT 
USING (organization_id = get_user_organization_id());
</file>

<file path="supabase/migrations/20250806183309_421c28cc-30a4-44db-8603-695d413ea43b.sql">
-- Agregar constraint √∫nico para evitar cards duplicadas del mismo usuario con el mismo mensaje
ALTER TABLE cards ADD CONSTRAINT unique_user_message UNIQUE (user_id, message);

-- Opcional: Funci√≥n para generar cards autom√°ticas de datos existentes
CREATE OR REPLACE FUNCTION generate_auto_cards_for_user(p_user_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO ''
AS $function$
BEGIN
  -- Generar cards para organizaciones existentes
  INSERT INTO public.cards (user_id, type, message, read_status, created_at)
  SELECT 
    p_user_id,
    'info',
    'Organizaci√≥n "' || o.name || '" est√° activa en el sistema',
    false,
    o.created_at
  FROM organizations o
  JOIN users u ON u.organization_id = o.id
  WHERE u.id = p_user_id
  ON CONFLICT (user_id, message) DO NOTHING;

  -- Generar cards para embajadores aprobados
  INSERT INTO public.cards (user_id, type, message, read_status, created_at)
  SELECT 
    p_user_id,
    'success',
    'Embajador ' || e.first_name || ' ' || e.last_name || ' est√° activo',
    false,
    e.created_at
  FROM embassadors e
  JOIN users u ON u.organization_id = e.organization_id
  WHERE u.id = p_user_id AND e.status = 'approved'
  ON CONFLICT (user_id, message) DO NOTHING;

  -- Generar cards para eventos activos
  INSERT INTO public.cards (user_id, event_id, type, message, read_status, created_at)
  SELECT 
    p_user_id,
    ev.id,
    'achievement',
    'Evento "' || ev.name || '" est√° en progreso',
    false,
    ev.created_at
  FROM events ev
  JOIN users u ON u.organization_id = ev.organization_id
  WHERE u.id = p_user_id AND ev.active = true
  ON CONFLICT (user_id, message) DO NOTHING;
END;
$function$;
</file>

<file path="supabase/migrations/20250806183820_195c0f0d-3bce-4a2b-a12c-4556632bc536.sql">
-- Limpiar todas las tablas para empezar desde cero
DELETE FROM cards;
DELETE FROM event_logs;
DELETE FROM tasks;
DELETE FROM embassador_events;
DELETE FROM event_checklists;
DELETE FROM event_instagram_accounts;
DELETE FROM event_phases;
DELETE FROM leaderboards;
DELETE FROM embassadors;
DELETE FROM events;
DELETE FROM import_logs;
DELETE FROM notifications;
DELETE FROM invitation_tokens;
DELETE FROM user_organization_roles;
DELETE FROM profiles;
DELETE FROM users;
DELETE FROM organizations;

-- Reiniciar las secuencias si las hay
DELETE FROM meta_sync_logs;
DELETE FROM social_insights;
ALTER SEQUENCE IF EXISTS meta_sync_logs_id_seq RESTART WITH 1;
ALTER SEQUENCE IF EXISTS social_insights_id_seq RESTART WITH 1;

-- Limpiar tambi√©n las tablas de Instagram y social
DELETE FROM instagram_profiles;
DELETE FROM social_pages;
DELETE FROM story_links;
</file>

<file path="supabase/migrations/20250806185931_90869d09-cef0-4941-a2a0-a139e2f98a3b.sql">
-- Eliminar todas las tablas existentes (en orden para evitar errores de dependencias)
DROP TABLE IF EXISTS cards CASCADE;
DROP TABLE IF EXISTS notifications CASCADE;
DROP TABLE IF EXISTS event_logs CASCADE;
DROP TABLE IF EXISTS import_logs CASCADE;
DROP TABLE IF EXISTS meta_sync_logs CASCADE;
DROP TABLE IF EXISTS social_insights CASCADE;
DROP TABLE IF EXISTS social_pages CASCADE;
DROP TABLE IF EXISTS instagram_profiles CASCADE;
DROP TABLE IF EXISTS story_links CASCADE;
DROP TABLE IF EXISTS tasks CASCADE;
DROP TABLE IF EXISTS leaderboards CASCADE;
DROP TABLE IF EXISTS embassador_events CASCADE;
DROP TABLE IF EXISTS event_checklists CASCADE;
DROP TABLE IF EXISTS event_instagram_accounts CASCADE;
DROP TABLE IF EXISTS event_phases CASCADE;
DROP TABLE IF EXISTS invitation_tokens CASCADE;
DROP TABLE IF EXISTS user_organization_roles CASCADE;
DROP TABLE IF EXISTS profiles CASCADE;
DROP TABLE IF EXISTS embassadors CASCADE;
DROP TABLE IF EXISTS events CASCADE;
DROP TABLE IF EXISTS users CASCADE;
DROP TABLE IF EXISTS organizations CASCADE;

-- Eliminar funciones existentes
DROP FUNCTION IF EXISTS get_user_organization_id() CASCADE;
DROP FUNCTION IF EXISTS generate_auto_cards_for_user(uuid) CASCADE;
DROP FUNCTION IF EXISTS create_event_log(uuid, uuid, text, jsonb) CASCADE;
DROP FUNCTION IF EXISTS create_feedback_card(uuid, uuid, text, text) CASCADE;
DROP FUNCTION IF EXISTS update_updated_at_column() CASCADE;

-- Eliminar tipos personalizados existentes
DROP TYPE IF EXISTS embassador_category CASCADE;
DROP TYPE IF EXISTS embassador_status CASCADE;
DROP TYPE IF EXISTS performance_status CASCADE;
DROP TYPE IF EXISTS checklist_status CASCADE;
DROP TYPE IF EXISTS user_role CASCADE;
DROP TYPE IF EXISTS user_status CASCADE;
DROP TYPE IF EXISTS event_type CASCADE;
DROP TYPE IF EXISTS cyclic_type CASCADE;
DROP TYPE IF EXISTS task_status CASCADE;
DROP TYPE IF EXISTS task_type CASCADE;
DROP TYPE IF EXISTS import_status CASCADE;
DROP TYPE IF EXISTS import_source CASCADE;
DROP TYPE IF EXISTS import_type CASCADE;
DROP TYPE IF EXISTS invitation_status CASCADE;
DROP TYPE IF EXISTS notification_type CASCADE;
DROP TYPE IF EXISTS notification_priority CASCADE;
DROP TYPE IF EXISTS target_type CASCADE;

-- PASO 1: Crear estructura b√°sica para organizaciones
-- Una organizaci√≥n representa una productora de eventos
CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_by UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Habilitar RLS para organizaciones
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;

-- Solo usuarios autenticados pueden crear organizaciones
CREATE POLICY "Users can create organizations" 
ON organizations FOR INSERT 
WITH CHECK (auth.uid() = created_by);

-- Los usuarios pueden ver solo las organizaciones que crearon
CREATE POLICY "Users can view own organizations" 
ON organizations FOR SELECT 
USING (auth.uid() = created_by);

-- Los usuarios pueden actualizar solo las organizaciones que crearon
CREATE POLICY "Users can update own organizations" 
ON organizations FOR UPDATE 
USING (auth.uid() = created_by);

-- PASO 2: Crear tabla de usuarios del sistema (perfil extendido)
-- Esto complementa auth.users con informaci√≥n espec√≠fica del sistema
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  auth_user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  name TEXT NOT NULL,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Habilitar RLS para usuarios
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Los usuarios pueden crear su propio perfil
CREATE POLICY "Users can create own profile" 
ON users FOR INSERT 
WITH CHECK (auth.uid() = auth_user_id);

-- Los usuarios pueden ver su propio perfil
CREATE POLICY "Users can view own profile" 
ON users FOR SELECT 
USING (auth.uid() = auth_user_id);

-- Los usuarios pueden actualizar su propio perfil
CREATE POLICY "Users can update own profile" 
ON users FOR UPDATE 
USING (auth.uid() = auth_user_id);

-- PASO 3: Crear tabla de eventos/fiestas
CREATE TABLE events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  event_date DATE NOT NULL,
  location TEXT,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  active BOOLEAN DEFAULT true
);

-- Habilitar RLS para eventos
ALTER TABLE events ENABLE ROW LEVEL SECURITY;

-- Solo los usuarios pueden crear eventos para sus organizaciones
CREATE POLICY "Users can create events for own organization" 
ON events FOR INSERT 
WITH CHECK (
  organization_id IN (
    SELECT id FROM organizations WHERE created_by = auth.uid()
  )
);

-- Los usuarios pueden ver eventos de sus organizaciones
CREATE POLICY "Users can view own organization events" 
ON events FOR SELECT 
USING (
  organization_id IN (
    SELECT id FROM organizations WHERE created_by = auth.uid()
  )
);

-- Los usuarios pueden actualizar eventos de sus organizaciones
CREATE POLICY "Users can update own organization events" 
ON events FOR UPDATE 
USING (
  organization_id IN (
    SELECT id FROM organizations WHERE created_by = auth.uid()
  )
);

-- PASO 4: Crear tabla b√°sica de embajadores
CREATE TABLE embassadors (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  email TEXT NOT NULL,
  instagram_user TEXT NOT NULL,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  status TEXT DEFAULT 'active'
);

-- Habilitar RLS para embajadores
ALTER TABLE embassadors ENABLE ROW LEVEL SECURITY;

-- Los usuarios pueden crear embajadores para sus organizaciones
CREATE POLICY "Users can create embassadors for own organization" 
ON embassadors FOR INSERT 
WITH CHECK (
  organization_id IN (
    SELECT id FROM organizations WHERE created_by = auth.uid()
  )
);

-- Los usuarios pueden ver embajadores de sus organizaciones
CREATE POLICY "Users can view own organization embassadors" 
ON embassadors FOR SELECT 
USING (
  organization_id IN (
    SELECT id FROM organizations WHERE created_by = auth.uid()
  )
);

-- Los usuarios pueden actualizar embajadores de sus organizaciones
CREATE POLICY "Users can update own organization embassadors" 
ON embassadors FOR UPDATE 
USING (
  organization_id IN (
    SELECT id FROM organizations WHERE created_by = auth.uid()
  )
);
</file>

<file path="supabase/migrations/20250806201357_1dda40d3-8ce6-4ee6-8d57-022c56948c9d.sql">
-- Expansi√≥n conservativa de la tabla organizations
ALTER TABLE public.organizations 
ADD COLUMN IF NOT EXISTS timezone TEXT DEFAULT 'America/Santiago',
ADD COLUMN IF NOT EXISTS logo_url TEXT,
ADD COLUMN IF NOT EXISTS meta_token TEXT,
ADD COLUMN IF NOT EXISTS token_expiry TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS plan_type TEXT DEFAULT 'free' CHECK (plan_type IN ('free', 'basic', 'intermediate', 'advanced', 'elite'));

-- Expansi√≥n conservativa de la tabla users
ALTER TABLE public.users 
ADD COLUMN IF NOT EXISTS full_name TEXT,
ADD COLUMN IF NOT EXISTS role TEXT DEFAULT 'admin' CHECK (role IN ('admin', 'viewer')),
ADD COLUMN IF NOT EXISTS last_login TIMESTAMP WITH TIME ZONE;

-- Expansi√≥n conservativa de la tabla embassadors
ALTER TABLE public.embassadors 
ADD COLUMN IF NOT EXISTS rut TEXT,
ADD COLUMN IF NOT EXISTS date_of_birth DATE,
ADD COLUMN IF NOT EXISTS follower_count INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS global_category TEXT DEFAULT 'bronze' CHECK (global_category IN ('bronze', 'plata', 'oro', 'diamante')),
ADD COLUMN IF NOT EXISTS performance_status TEXT DEFAULT 'cumple' CHECK (performance_status IN ('no_cumple', 'cumple', 'advertencia', 'exclusivo')),
ADD COLUMN IF NOT EXISTS profile_picture_url TEXT,
ADD COLUMN IF NOT EXISTS profile_public BOOLEAN DEFAULT true,
ADD COLUMN IF NOT EXISTS global_points INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS events_participated INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS completed_tasks INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS failed_tasks INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS created_by_user_id UUID REFERENCES public.users(id);

-- Expansi√≥n conservativa de la tabla events
ALTER TABLE public.events 
ADD COLUMN IF NOT EXISTS start_date DATE,
ADD COLUMN IF NOT EXISTS end_date DATE,
ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'active' CHECK (status IN ('active', 'completed', 'cancelled')),
ADD COLUMN IF NOT EXISTS main_hashtag TEXT,
ADD COLUMN IF NOT EXISTS secondary_hashtags TEXT[],
ADD COLUMN IF NOT EXISTS created_by_user_id UUID REFERENCES public.users(id);

-- Crear tabla tasks para gesti√≥n de historias y menciones
CREATE TABLE IF NOT EXISTS public.tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  embassador_id UUID NOT NULL REFERENCES public.embassadors(id) ON DELETE CASCADE,
  event_id UUID NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
  task_type TEXT NOT NULL CHECK (task_type IN ('story', 'mention', 'repost')),
  platform TEXT DEFAULT 'instagram',
  expected_hashtag TEXT,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'uploaded', 'in_progress', 'completed', 'invalid', 'expired')),
  instagram_story_id TEXT,
  story_url TEXT,
  upload_time TIMESTAMP WITH TIME ZONE,
  expiry_time TIMESTAMP WITH TIME ZONE,
  completion_method TEXT DEFAULT '24h_validation' CHECK (completion_method IN ('24h_validation', 'manual')),
  engagement_score FLOAT DEFAULT 0,
  reach_count INTEGER DEFAULT 0,
  verified_through_api BOOLEAN DEFAULT false,
  points_earned INTEGER DEFAULT 0,
  last_status_update TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Crear tabla task_logs para auditor√≠a
CREATE TABLE IF NOT EXISTS public.task_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
  timestamp_checked TIMESTAMP WITH TIME ZONE DEFAULT now(),
  was_active BOOLEAN,
  story_status TEXT,
  api_response JSONB,
  details TEXT,
  checked_by TEXT DEFAULT 'system'
);

-- Crear tabla plans para configuraci√≥n de l√≠mites
CREATE TABLE IF NOT EXISTS public.plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  price DECIMAL(10,2) DEFAULT 0,
  max_ambassadors INTEGER,
  max_events INTEGER,
  max_users INTEGER,
  features JSONB DEFAULT '{}',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Crear tabla leaderboards para rankings
CREATE TABLE IF NOT EXISTS public.leaderboards (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id UUID NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
  embassador_id UUID NOT NULL REFERENCES public.embassadors(id) ON DELETE CASCADE,
  points INTEGER DEFAULT 0,
  rank INTEGER,
  last_updated TIMESTAMP WITH TIME ZONE DEFAULT now(),
  UNIQUE(event_id, embassador_id)
);

-- Crear tabla notifications para sistema de notificaciones
CREATE TABLE IF NOT EXISTS public.notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,
  type TEXT NOT NULL,
  message TEXT NOT NULL,
  priority TEXT DEFAULT 'normal' CHECK (priority IN ('low', 'normal', 'high', 'critical')),
  target_type TEXT,
  target_id UUID,
  read_status BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Crear tabla import_logs para auditor√≠a de importaciones
CREATE TABLE IF NOT EXISTS public.import_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id),
  organization_id UUID NOT NULL REFERENCES public.organizations(id),
  type TEXT NOT NULL,
  source TEXT,
  file_name TEXT,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  result_json JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Insertar planes predefinidos
INSERT INTO public.plans (name, slug, price, max_ambassadors, max_events, max_users, features) 
VALUES 
  ('Free', 'free', 0, 10, 2, 1, '{"analytics": "basic", "export": "csv", "support": "community"}'),
  ('Basic', 'basic', 29.99, 50, 5, 3, '{"analytics": "advanced", "export": "csv,pdf", "support": "email"}'),
  ('Intermediate', 'intermediate', 59.99, 100, 10, 5, '{"analytics": "advanced", "export": "csv,pdf", "support": "priority"}'),
  ('Advanced', 'advanced', 99.99, 250, 25, 10, '{"analytics": "advanced", "export": "all", "support": "priority", "custom_branding": true}'),
  ('Elite', 'elite', 199.99, 500, 50, 25, '{"analytics": "advanced", "export": "all", "support": "dedicated", "custom_branding": true, "api_access": true}')
ON CONFLICT (slug) DO NOTHING;

-- RLS Policies para las nuevas tablas
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.task_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.leaderboards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.import_logs ENABLE ROW LEVEL SECURITY;

-- Pol√≠ticas RLS para tasks
CREATE POLICY "Users can view tasks from own organization" ON public.tasks
  FOR SELECT USING (
    embassador_id IN (
      SELECT e.id FROM public.embassadors e
      INNER JOIN public.organizations o ON e.organization_id = o.id
      WHERE o.created_by = auth.uid()
    )
  );

CREATE POLICY "Users can create tasks for own organization" ON public.tasks
  FOR INSERT WITH CHECK (
    embassador_id IN (
      SELECT e.id FROM public.embassadors e
      INNER JOIN public.organizations o ON e.organization_id = o.id
      WHERE o.created_by = auth.uid()
    )
  );

CREATE POLICY "Users can update tasks from own organization" ON public.tasks
  FOR UPDATE USING (
    embassador_id IN (
      SELECT e.id FROM public.embassadors e
      INNER JOIN public.organizations o ON e.organization_id = o.id
      WHERE o.created_by = auth.uid()
    )
  );

-- Pol√≠ticas similares para las dem√°s tablas
CREATE POLICY "Users can view own organization task logs" ON public.task_logs
  FOR SELECT USING (
    task_id IN (
      SELECT t.id FROM public.tasks t
      INNER JOIN public.embassadors e ON t.embassador_id = e.id
      INNER JOIN public.organizations o ON e.organization_id = o.id
      WHERE o.created_by = auth.uid()
    )
  );

CREATE POLICY "Users can view all plans" ON public.plans
  FOR SELECT USING (true);

CREATE POLICY "Users can view own organization leaderboards" ON public.leaderboards
  FOR SELECT USING (
    event_id IN (
      SELECT ev.id FROM public.events ev
      INNER JOIN public.organizations o ON ev.organization_id = o.id
      WHERE o.created_by = auth.uid()
    )
  );

CREATE POLICY "Users can view own organization notifications" ON public.notifications
  FOR SELECT USING (
    organization_id IN (
      SELECT id FROM public.organizations WHERE created_by = auth.uid()
    )
  );

CREATE POLICY "Users can update own organization notifications" ON public.notifications
  FOR UPDATE USING (
    organization_id IN (
      SELECT id FROM public.organizations WHERE created_by = auth.uid()
    )
  );

CREATE POLICY "Users can view own import logs" ON public.import_logs
  FOR SELECT USING (user_id = auth.uid());

-- √çndices para optimizaci√≥n
CREATE INDEX IF NOT EXISTS idx_tasks_embassador_event ON public.tasks(embassador_id, event_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status_expiry ON public.tasks(status, expiry_time);
CREATE INDEX IF NOT EXISTS idx_task_logs_task_timestamp ON public.task_logs(task_id, timestamp_checked);
CREATE INDEX IF NOT EXISTS idx_leaderboards_event_rank ON public.leaderboards(event_id, rank);
CREATE INDEX IF NOT EXISTS idx_notifications_org_read ON public.notifications(organization_id, read_status);
</file>

<file path="supabase/migrations/20250806211038_0bdafee0-d226-42c4-8df0-558b061cfe40.sql">
-- Create table for OAuth state management
CREATE TABLE IF NOT EXISTS oauth_states (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  state TEXT NOT NULL UNIQUE,
  user_id UUID,
  organization_id UUID,
  type TEXT NOT NULL CHECK (type IN ('ambassador', 'organization')),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL
);

-- Add Instagram fields to embassadors table
ALTER TABLE embassadors 
ADD COLUMN IF NOT EXISTS instagram_access_token TEXT,
ADD COLUMN IF NOT EXISTS instagram_user_id TEXT,
ADD COLUMN IF NOT EXISTS token_expires_at TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS last_instagram_sync TIMESTAMP WITH TIME ZONE;

-- Add Instagram sync field to organizations table  
ALTER TABLE organizations
ADD COLUMN IF NOT EXISTS last_instagram_sync TIMESTAMP WITH TIME ZONE;

-- Enable RLS on oauth_states
ALTER TABLE oauth_states ENABLE ROW LEVEL SECURITY;

-- Create policy for oauth_states
CREATE POLICY "Users can manage own oauth states" 
ON oauth_states 
FOR ALL 
USING (user_id = auth.uid() OR user_id IN (
  SELECT u.id FROM users u WHERE u.auth_user_id = auth.uid()
));

-- Create index for oauth_states cleanup
CREATE INDEX IF NOT EXISTS idx_oauth_states_expires_at ON oauth_states(expires_at);

-- Create function to cleanup expired oauth states
CREATE OR REPLACE FUNCTION cleanup_expired_oauth_states()
RETURNS void AS $$
BEGIN
  DELETE FROM oauth_states WHERE expires_at < now();
END;
$$ LANGUAGE plpgsql;
</file>

<file path="supabase/migrations/20250806214309_4c3840a5-6346-4e17-9050-6e41b0778e83.sql">
-- Create oauth_states table for managing OAuth flow security
CREATE TABLE IF NOT EXISTS public.oauth_states (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  state TEXT NOT NULL UNIQUE,
  user_id UUID,
  organization_id UUID,
  type TEXT NOT NULL CHECK (type IN ('ambassador', 'organization')),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL
);

-- Enable RLS
ALTER TABLE public.oauth_states ENABLE ROW LEVEL SECURITY;

-- Create policy for users to manage their own OAuth states
CREATE POLICY "Users can manage own oauth states" 
ON public.oauth_states 
FOR ALL 
USING (
  user_id = auth.uid() OR 
  user_id IN (
    SELECT u.id FROM users u WHERE u.auth_user_id = auth.uid()
  )
);

-- Create index for performance
CREATE INDEX IF NOT EXISTS idx_oauth_states_state ON public.oauth_states(state);
CREATE INDEX IF NOT EXISTS idx_oauth_states_expires_at ON public.oauth_states(expires_at);
</file>

<file path="supabase/migrations/20250806215231_15fbcf86-e644-411b-a436-c1ce909393f5.sql">
-- Add DELETE policy for organizations
CREATE POLICY "Users can delete own organizations" 
ON public.organizations 
FOR DELETE 
USING (auth.uid() = created_by);
</file>

<file path="supabase/migrations/20250807151547_b253ceec-da49-4a46-a790-5e6fecbe393a.sql">
-- Add hierarchical organization support
ALTER TABLE organizations 
ADD COLUMN parent_organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
ADD COLUMN is_main_account BOOLEAN DEFAULT false,
ADD COLUMN organization_type TEXT DEFAULT 'sub_brand' CHECK (organization_type IN ('main', 'sub_brand'));

-- Create index for parent organization lookups
CREATE INDEX idx_organizations_parent_id ON organizations(parent_organization_id);

-- Update existing organizations to be main accounts if they don't have a parent
UPDATE organizations 
SET organization_type = 'main', is_main_account = true 
WHERE parent_organization_id IS NULL;

-- Create function to get organization hierarchy
CREATE OR REPLACE FUNCTION get_organization_hierarchy(org_id UUID)
RETURNS TABLE (
  id UUID,
  name TEXT,
  description TEXT,
  organization_type TEXT,
  is_main_account BOOLEAN,
  level INTEGER
) AS $$
WITH RECURSIVE hierarchy AS (
  -- Base case: start with the given organization
  SELECT 
    o.id,
    o.name,
    o.description,
    o.organization_type,
    o.is_main_account,
    0 as level
  FROM organizations o
  WHERE o.id = org_id
  
  UNION ALL
  
  -- Recursive case: find children
  SELECT 
    o.id,
    o.name,
    o.description,
    o.organization_type,
    o.is_main_account,
    h.level + 1
  FROM organizations o
  JOIN hierarchy h ON o.parent_organization_id = h.id
)
SELECT * FROM hierarchy ORDER BY level, name;
$$ LANGUAGE sql;

-- Create RLS policy for hierarchical access
CREATE POLICY "Users can view organization hierarchy" 
ON organizations 
FOR SELECT 
USING (
  -- Users can see their own organizations
  created_by = auth.uid() 
  OR 
  -- Users can see sub-organizations of their main organizations
  parent_organization_id IN (
    SELECT id FROM organizations WHERE created_by = auth.uid()
  )
);

-- Update existing policies to handle hierarchy
DROP POLICY IF EXISTS "Users can view own organizations" ON organizations;

-- Allow creating sub-organizations
CREATE POLICY "Users can create sub-organizations" 
ON organizations 
FOR INSERT 
WITH CHECK (
  auth.uid() = created_by 
  AND (
    parent_organization_id IS NULL 
    OR 
    parent_organization_id IN (
      SELECT id FROM organizations WHERE created_by = auth.uid()
    )
  )
);
</file>

<file path="supabase/migrations/20250807151617_14907565-74b5-4ba3-b29a-c01e8383fc91.sql">
-- Fix security warnings by setting proper search_path for functions

-- Drop and recreate the function with secure search_path
DROP FUNCTION IF EXISTS get_organization_hierarchy(UUID);

CREATE OR REPLACE FUNCTION get_organization_hierarchy(org_id UUID)
RETURNS TABLE (
  id UUID,
  name TEXT,
  description TEXT,
  organization_type TEXT,
  is_main_account BOOLEAN,
  level INTEGER
)
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
WITH RECURSIVE hierarchy AS (
  -- Base case: start with the given organization
  SELECT 
    o.id,
    o.name,
    o.description,
    o.organization_type,
    o.is_main_account,
    0 as level
  FROM public.organizations o
  WHERE o.id = org_id
  
  UNION ALL
  
  -- Recursive case: find children
  SELECT 
    o.id,
    o.name,
    o.description,
    o.organization_type,
    o.is_main_account,
    h.level + 1
  FROM public.organizations o
  JOIN hierarchy h ON o.parent_organization_id = h.id
)
SELECT * FROM hierarchy ORDER BY level, name;
$$;

-- Also fix the cleanup function search path
DROP FUNCTION IF EXISTS cleanup_expired_oauth_states();

CREATE OR REPLACE FUNCTION cleanup_expired_oauth_states()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  DELETE FROM public.oauth_states WHERE expires_at < now();
END;
$$;
</file>

<file path="supabase/migrations/20250807152416_4fb6e41c-d38f-4f15-8721-fe33bd86c285.sql">
-- Fix infinite recursion in organizations RLS policies
-- Step 1: Create a security definer function to get user organizations safely
CREATE OR REPLACE FUNCTION public.get_user_organization_ids(user_id UUID)
RETURNS TABLE(organization_id UUID)
LANGUAGE SQL
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT id FROM organizations WHERE created_by = user_id;
$$;

-- Step 2: Drop existing problematic RLS policies
DROP POLICY IF EXISTS "Users can view organization hierarchy" ON public.organizations;
DROP POLICY IF EXISTS "Users can create sub-organizations" ON public.organizations;

-- Step 3: Create safe RLS policies without recursion
CREATE POLICY "Users can view own organizations" 
ON public.organizations 
FOR SELECT 
USING (created_by = auth.uid());

CREATE POLICY "Users can view sub-organizations" 
ON public.organizations 
FOR SELECT 
USING (parent_organization_id IN (SELECT organization_id FROM public.get_user_organization_ids(auth.uid())));

CREATE POLICY "Users can create main organizations" 
ON public.organizations 
FOR INSERT 
WITH CHECK (created_by = auth.uid() AND parent_organization_id IS NULL);

CREATE POLICY "Users can create sub-organizations" 
ON public.organizations 
FOR INSERT 
WITH CHECK (
  created_by = auth.uid() 
  AND parent_organization_id IN (SELECT organization_id FROM public.get_user_organization_ids(auth.uid()))
);
</file>

<file path="supabase/migrations/20250807154354_e0cdea1b-e345-415b-90b3-3c7ff566116d.sql">
-- Create fiestas table (previously organizations concept)
CREATE TABLE public.fiestas (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  organization_id UUID NOT NULL,
  event_date DATE,
  location TEXT,
  main_hashtag TEXT,
  secondary_hashtags TEXT[],
  status TEXT DEFAULT 'active',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Migrate existing events data to fiestas
INSERT INTO public.fiestas (id, name, description, organization_id, event_date, location, main_hashtag, secondary_hashtags, status, created_at)
SELECT 
  id,
  name,
  description,
  organization_id,
  event_date,
  location,
  main_hashtag,
  secondary_hashtags,
  status,
  created_at
FROM public.events;

-- Update events table to reference fiestas instead of organizations
ALTER TABLE public.events DROP COLUMN organization_id;
ALTER TABLE public.events ADD COLUMN fiesta_id UUID REFERENCES public.fiestas(id);

-- Update events with fiesta references
UPDATE public.events SET fiesta_id = id;

-- Update embassadors to reference organizations directly (not through events)
-- Keep organization_id in embassadors as is

-- Update tasks to work with new structure
-- Tasks will reference events, which reference fiestas, which reference organizations

-- Enable RLS for fiestas
ALTER TABLE public.fiestas ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for fiestas
CREATE POLICY "Users can view own organization fiestas" 
ON public.fiestas 
FOR SELECT 
USING (organization_id IN (
  SELECT organizations.id
  FROM organizations
  WHERE organizations.created_by = auth.uid()
));

CREATE POLICY "Users can create fiestas for own organization" 
ON public.fiestas 
FOR INSERT 
WITH CHECK (organization_id IN (
  SELECT organizations.id
  FROM organizations
  WHERE organizations.created_by = auth.uid()
));

CREATE POLICY "Users can update own organization fiestas" 
ON public.fiestas 
FOR UPDATE 
USING (organization_id IN (
  SELECT organizations.id
  FROM organizations
  WHERE organizations.created_by = auth.uid()
));

-- Update events RLS policies to work with fiestas
DROP POLICY IF EXISTS "Users can view own organization events" ON public.events;
DROP POLICY IF EXISTS "Users can create events for own organization" ON public.events;
DROP POLICY IF EXISTS "Users can update own organization events" ON public.events;

CREATE POLICY "Users can view events from own organization fiestas"
ON public.events
FOR SELECT
USING (fiesta_id IN (
  SELECT f.id
  FROM fiestas f
  JOIN organizations o ON f.organization_id = o.id
  WHERE o.created_by = auth.uid()
));

CREATE POLICY "Users can create events for own organization fiestas"
ON public.events
FOR INSERT
WITH CHECK (fiesta_id IN (
  SELECT f.id
  FROM fiestas f
  JOIN organizations o ON f.organization_id = o.id
  WHERE o.created_by = auth.uid()
));

CREATE POLICY "Users can update events from own organization fiestas"
ON public.events
FOR UPDATE
USING (fiesta_id IN (
  SELECT f.id
  FROM fiestas f
  JOIN organizations o ON f.organization_id = o.id
  WHERE o.created_by = auth.uid()
));

-- Remove problematic columns from events that were duplicated in fiestas
ALTER TABLE public.events DROP COLUMN IF EXISTS name;
ALTER TABLE public.events DROP COLUMN IF EXISTS description;
ALTER TABLE public.events DROP COLUMN IF EXISTS main_hashtag;
ALTER TABLE public.events DROP COLUMN IF EXISTS secondary_hashtags;
ALTER TABLE public.events DROP COLUMN IF EXISTS location;
ALTER TABLE public.events DROP COLUMN IF EXISTS status;

-- Keep only event-specific fields in events table
-- events now represents individual activities within a fiesta

-- Simplify organizations table - remove fields that belonged to fiestas concept
ALTER TABLE public.organizations DROP COLUMN IF EXISTS parent_organization_id;
ALTER TABLE public.organizations DROP COLUMN IF EXISTS organization_type;
ALTER TABLE public.organizations DROP COLUMN IF EXISTS is_main_account;

-- Organizations is now just the production company
-- One organization per user, multiple fiestas per organization
</file>

<file path="supabase/migrations/20250807154439_665bd0c2-4a3e-4920-ae95-e576ddd88cff.sql">
-- Step 1: Drop dependent policies first
DROP POLICY IF EXISTS "Users can view own organization events" ON public.events;
DROP POLICY IF EXISTS "Users can create events for own organization" ON public.events;
DROP POLICY IF EXISTS "Users can update own organization events" ON public.events;
DROP POLICY IF EXISTS "Users can view own organization leaderboards" ON public.leaderboards;

-- Step 2: Create fiestas table
CREATE TABLE IF NOT EXISTS public.fiestas (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  organization_id UUID NOT NULL,
  event_date DATE,
  location TEXT,
  main_hashtag TEXT,
  secondary_hashtags TEXT[],
  status TEXT DEFAULT 'active',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Step 3: Migrate existing events data to fiestas (only if data exists)
INSERT INTO public.fiestas (id, name, description, organization_id, event_date, location, main_hashtag, secondary_hashtags, status, created_at)
SELECT 
  id,
  COALESCE(name, 'Fiesta ' || id::text),
  description,
  organization_id,
  event_date,
  location,
  main_hashtag,
  secondary_hashtags,
  COALESCE(status, 'active'),
  created_at
FROM public.events
WHERE NOT EXISTS (SELECT 1 FROM public.fiestas WHERE fiestas.id = events.id);

-- Step 4: Add fiesta_id to events table
ALTER TABLE public.events ADD COLUMN IF NOT EXISTS fiesta_id UUID;

-- Step 5: Update events with fiesta references
UPDATE public.events SET fiesta_id = id WHERE fiesta_id IS NULL;

-- Step 6: Make fiesta_id a foreign key
ALTER TABLE public.events ADD CONSTRAINT events_fiesta_id_fkey FOREIGN KEY (fiesta_id) REFERENCES public.fiestas(id);

-- Step 7: Drop the organization_id column from events
ALTER TABLE public.events DROP COLUMN IF EXISTS organization_id CASCADE;

-- Step 8: Remove duplicate columns from events
ALTER TABLE public.events DROP COLUMN IF EXISTS name CASCADE;
ALTER TABLE public.events DROP COLUMN IF EXISTS description CASCADE;
ALTER TABLE public.events DROP COLUMN IF EXISTS main_hashtag CASCADE;
ALTER TABLE public.events DROP COLUMN IF EXISTS secondary_hashtags CASCADE;
ALTER TABLE public.events DROP COLUMN IF EXISTS location CASCADE;
ALTER TABLE public.events DROP COLUMN IF EXISTS status CASCADE;

-- Step 9: Enable RLS for fiestas
ALTER TABLE public.fiestas ENABLE ROW LEVEL SECURITY;

-- Step 10: Create RLS policies for fiestas
CREATE POLICY "Users can view own organization fiestas" 
ON public.fiestas 
FOR SELECT 
USING (organization_id IN (
  SELECT organizations.id
  FROM organizations
  WHERE organizations.created_by = auth.uid()
));

CREATE POLICY "Users can create fiestas for own organization" 
ON public.fiestas 
FOR INSERT 
WITH CHECK (organization_id IN (
  SELECT organizations.id
  FROM organizations
  WHERE organizations.created_by = auth.uid()
));

CREATE POLICY "Users can update own organization fiestas" 
ON public.fiestas 
FOR UPDATE 
USING (organization_id IN (
  SELECT organizations.id
  FROM organizations
  WHERE organizations.created_by = auth.uid()
));

-- Step 11: Create new events policies
CREATE POLICY "Users can view events from own organization fiestas"
ON public.events
FOR SELECT
USING (fiesta_id IN (
  SELECT f.id
  FROM fiestas f
  JOIN organizations o ON f.organization_id = o.id
  WHERE o.created_by = auth.uid()
));

CREATE POLICY "Users can create events for own organization fiestas"
ON public.events
FOR INSERT
WITH CHECK (fiesta_id IN (
  SELECT f.id
  FROM fiestas f
  JOIN organizations o ON f.organization_id = o.id
  WHERE o.created_by = auth.uid()
));

CREATE POLICY "Users can update events from own organization fiestas"
ON public.events
FOR UPDATE
USING (fiesta_id IN (
  SELECT f.id
  FROM fiestas f
  JOIN organizations o ON f.organization_id = o.id
  WHERE o.created_by = auth.uid()
));

-- Step 12: Update leaderboards policy
CREATE POLICY "Users can view own organization leaderboards"
ON public.leaderboards
FOR SELECT
USING (event_id IN (
  SELECT e.id
  FROM events e
  JOIN fiestas f ON e.fiesta_id = f.id
  JOIN organizations o ON f.organization_id = o.id
  WHERE o.created_by = auth.uid()
));

-- Step 13: Simplify organizations table
ALTER TABLE public.organizations DROP COLUMN IF EXISTS parent_organization_id CASCADE;
ALTER TABLE public.organizations DROP COLUMN IF EXISTS organization_type CASCADE;
ALTER TABLE public.organizations DROP COLUMN IF EXISTS is_main_account CASCADE;
</file>

<file path="supabase/migrations/20250807160052_65ee9f18-dfdc-4c38-8238-d7bf14919b85.sql">
-- Limpieza de organizaciones duplicadas
-- Mantener solo la organizaci√≥n m√°s reciente por usuario
DELETE FROM organizations 
WHERE id NOT IN (
  SELECT DISTINCT ON (created_by) id
  FROM organizations 
  ORDER BY created_by, created_at DESC
);

-- Verificar que fiestas est√©n asociadas a organizaciones v√°lidas
UPDATE fiestas 
SET organization_id = (
  SELECT id FROM organizations WHERE created_by = '3b790b1f-8a3c-4ff0-bf54-daa45bc8e164' LIMIT 1
)
WHERE organization_id NOT IN (SELECT id FROM organizations);

-- Verificar que embajadores est√©n asociados a organizaciones v√°lidas  
UPDATE embassadors 
SET organization_id = (
  SELECT id FROM organizations WHERE created_by = '3b790b1f-8a3c-4ff0-bf54-daa45bc8e164' LIMIT 1
)
WHERE organization_id NOT IN (SELECT id FROM organizations);
</file>

<file path="supabase/migrations/20250807163200_44622a60-f761-4be2-a519-828ed531041f.sql">
-- Create organization_settings table for persistent configuration
CREATE TABLE IF NOT EXISTS public.organization_settings (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  organization_id UUID NOT NULL,
  
  -- General Settings
  general_settings JSONB DEFAULT '{
    "timezone": "America/Santiago",
    "language": "es",
    "logo_url": null,
    "description": null
  }'::jsonb,
  
  -- Instagram Settings
  instagram_settings JSONB DEFAULT '{
    "auto_sync": true,
    "sync_interval": "hourly",
    "auto_validate_tasks": false,
    "story_validation_24h": true
  }'::jsonb,
  
  -- Notification Settings
  notification_settings JSONB DEFAULT '{
    "email_notifications": true,
    "push_notifications": true,
    "token_expiry_alerts": true,
    "weekly_reports": false
  }'::jsonb,
  
  -- Permission Settings
  permission_settings JSONB DEFAULT '{
    "allow_ambassador_self_registration": false,
    "require_approval_for_tasks": true,
    "auto_validate_tasks": false
  }'::jsonb,
  
  -- Appearance Settings
  appearance_settings JSONB DEFAULT '{
    "theme": "system",
    "compact_mode": false
  }'::jsonb,
  
  -- Integration Settings
  integration_settings JSONB DEFAULT '{
    "google_drive_enabled": false,
    "zapier_enabled": false,
    "n8n_webhook_url": null
  }'::jsonb,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  CONSTRAINT fk_organization_settings_organization 
    FOREIGN KEY (organization_id) REFERENCES organizations(id) ON DELETE CASCADE,
  CONSTRAINT unique_organization_settings 
    UNIQUE (organization_id)
);

-- Enable RLS
ALTER TABLE public.organization_settings ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own organization settings" 
ON public.organization_settings 
FOR SELECT 
USING (organization_id IN (
  SELECT id FROM organizations WHERE created_by = auth.uid()
));

CREATE POLICY "Users can create settings for own organization" 
ON public.organization_settings 
FOR INSERT 
WITH CHECK (organization_id IN (
  SELECT id FROM organizations WHERE created_by = auth.uid()
));

CREATE POLICY "Users can update own organization settings" 
ON public.organization_settings 
FOR UPDATE 
USING (organization_id IN (
  SELECT id FROM organizations WHERE created_by = auth.uid()
));

-- Function to update timestamp
CREATE OR REPLACE FUNCTION public.update_organization_settings_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-update timestamp
CREATE TRIGGER update_organization_settings_updated_at
  BEFORE UPDATE ON public.organization_settings
  FOR EACH ROW
  EXECUTE FUNCTION public.update_organization_settings_updated_at();

-- Create default settings for existing organizations
INSERT INTO public.organization_settings (organization_id)
SELECT id FROM public.organizations
WHERE id NOT IN (SELECT organization_id FROM public.organization_settings);

-- Update embassadors table to exclude deleted ones from default queries
CREATE INDEX IF NOT EXISTS idx_embassadors_status ON public.embassadors(status);
CREATE INDEX IF NOT EXISTS idx_embassadors_organization_id ON public.embassadors(organization_id);
</file>

<file path="supabase/migrations/20250807164711_086b8727-ab9c-4968-9130-bcf6c188430c.sql">
-- Crear datos de prueba para Analytics
-- Primero, insertar embajadores de ejemplo
INSERT INTO public.embassadors (
  first_name, 
  last_name, 
  email, 
  instagram_user, 
  organization_id,
  status,
  global_points,
  global_category,
  performance_status,
  events_participated,
  completed_tasks,
  failed_tasks,
  follower_count
) VALUES 
-- Embajadores de alto rendimiento
('Mar√≠a', 'Gonz√°lez', 'maria.gonzalez@example.com', '@maria_glez', 
 (SELECT id FROM organizations LIMIT 1), 'active', 156, 'gold', 'exclusivo', 3, 12, 1, 8500),

('Carlos', 'Rodr√≠guez', 'carlos.rodriguez@example.com', '@carlos_rod', 
 (SELECT id FROM organizations LIMIT 1), 'active', 134, 'silver', 'cumple', 2, 10, 2, 5200),

('Ana', 'Mart√≠nez', 'ana.martinez@example.com', '@ana_mart', 
 (SELECT id FROM organizations LIMIT 1), 'active', 89, 'silver', 'cumple', 2, 7, 3, 3800),

-- Embajadores de rendimiento medio
('Diego', 'L√≥pez', 'diego.lopez@example.com', '@diego_lp', 
 (SELECT id FROM organizations LIMIT 1), 'active', 67, 'bronze', 'advertencia', 1, 5, 4, 2100),

('Sof√≠a', 'Hern√°ndez', 'sofia.hernandez@example.com', '@sofia_hdz', 
 (SELECT id FROM organizations LIMIT 1), 'active', 45, 'bronze', 'cumple', 1, 4, 2, 1900),

-- Embajadores de bajo rendimiento
('Luis', 'Torres', 'luis.torres@example.com', '@luis_torres', 
 (SELECT id FROM organizations LIMIT 1), 'active', 23, 'bronze', 'no_cumple', 1, 2, 6, 890),

('Carmen', 'Vega', 'carmen.vega@example.com', '@carmen_vg', 
 (SELECT id FROM organizations LIMIT 1), 'active', 34, 'bronze', 'advertencia', 1, 3, 4, 1200),

('Roberto', 'S√°nchez', 'roberto.sanchez@example.com', '@rob_sanchez', 
 (SELECT id FROM organizations LIMIT 1), 'active', 78, 'silver', 'cumple', 2, 6, 2, 4100);

-- Crear tareas de ejemplo para estos embajadores
INSERT INTO public.tasks (
  embassador_id,
  event_id,
  task_type,
  status,
  points_earned,
  reach_count,
  engagement_score,
  created_at,
  upload_time,
  platform
) 
SELECT 
  e.id as embassador_id,
  ev.id as event_id,
  (ARRAY['story', 'post', 'reel'])[floor(random() * 3 + 1)] as task_type,
  (ARRAY['completed', 'pending', 'invalid'])[floor(random() * 3 + 1)] as status,
  floor(random() * 5 + 1) as points_earned,
  floor(random() * 2000 + 100) as reach_count,
  random() * 10 as engagement_score,
  now() - (random() * interval '30 days') as created_at,
  now() - (random() * interval '25 days') as upload_time,
  'instagram'
FROM 
  embassadors e 
  CROSS JOIN events ev
  CROSS JOIN generate_series(1, 3) -- 3 tareas por embajador
WHERE 
  e.organization_id = (SELECT id FROM organizations LIMIT 1)
  AND ev.fiesta_id = (SELECT id FROM fiestas LIMIT 1);

-- Actualizar estad√≠sticas de tareas completadas/fallidas basadas en las tareas creadas
UPDATE embassadors 
SET 
  completed_tasks = (
    SELECT COUNT(*) 
    FROM tasks t 
    WHERE t.embassador_id = embassadors.id 
    AND t.status = 'completed'
  ),
  failed_tasks = (
    SELECT COUNT(*) 
    FROM tasks t 
    WHERE t.embassador_id = embassadors.id 
    AND t.status = 'invalid'
  ),
  global_points = (
    SELECT COALESCE(SUM(t.points_earned), 0)
    FROM tasks t 
    WHERE t.embassador_id = embassadors.id 
    AND t.status = 'completed'
  )
WHERE organization_id = (SELECT id FROM organizations LIMIT 1);

-- Crear algunas tareas adicionales para generar mejores datos hist√≥ricos
INSERT INTO public.tasks (
  embassador_id,
  event_id,
  task_type,
  status,
  points_earned,
  reach_count,
  engagement_score,
  created_at,
  upload_time,
  platform
) 
SELECT 
  e.id as embassador_id,
  ev.id as event_id,
  'story' as task_type,
  'completed' as status,
  2 as points_earned,
  floor(random() * 1500 + 500) as reach_count,
  random() * 8 + 2 as engagement_score,
  now() - (random() * interval '7 days') as created_at,
  now() - (random() * interval '5 days') as upload_time,
  'instagram'
FROM 
  embassadors e 
  CROSS JOIN events ev
  CROSS JOIN generate_series(1, 2) -- 2 tareas adicionales recientes
WHERE 
  e.organization_id = (SELECT id FROM organizations LIMIT 1)
  AND ev.fiesta_id = (SELECT id FROM fiestas LIMIT 1)
  AND e.performance_status IN ('cumple', 'exclusivo');
</file>

<file path="supabase/migrations/20250807164805_a4b04746-29cf-428a-88f7-68a37b433d15.sql">
-- Crear datos de prueba para Analytics con valores v√°lidos
-- Primero, insertar embajadores de ejemplo
INSERT INTO public.embassadors (
  first_name, 
  last_name, 
  email, 
  instagram_user, 
  organization_id,
  status,
  global_points,
  global_category,
  performance_status,
  events_participated,
  completed_tasks,
  failed_tasks,
  follower_count
) VALUES 
-- Embajadores de alto rendimiento
('Mar√≠a', 'Gonz√°lez', 'maria.gonzalez@example.com', '@maria_glez', 
 (SELECT id FROM organizations LIMIT 1), 'active', 156, 'diamond', 'exclusivo', 3, 12, 1, 8500),

('Carlos', 'Rodr√≠guez', 'carlos.rodriguez@example.com', '@carlos_rod', 
 (SELECT id FROM organizations LIMIT 1), 'active', 134, 'gold', 'cumple', 2, 10, 2, 5200),

('Ana', 'Mart√≠nez', 'ana.martinez@example.com', '@ana_mart', 
 (SELECT id FROM organizations LIMIT 1), 'active', 89, 'silver', 'cumple', 2, 7, 3, 3800),

-- Embajadores de rendimiento medio
('Diego', 'L√≥pez', 'diego.lopez@example.com', '@diego_lp', 
 (SELECT id FROM organizations LIMIT 1), 'active', 67, 'bronze', 'advertencia', 1, 5, 4, 2100),

('Sof√≠a', 'Hern√°ndez', 'sofia.hernandez@example.com', '@sofia_hdz', 
 (SELECT id FROM organizations LIMIT 1), 'active', 45, 'bronze', 'cumple', 1, 4, 2, 1900),

-- Embajadores de bajo rendimiento
('Luis', 'Torres', 'luis.torres@example.com', '@luis_torres', 
 (SELECT id FROM organizations LIMIT 1), 'active', 23, 'bronze', 'no_cumple', 1, 2, 6, 890),

('Carmen', 'Vega', 'carmen.vega@example.com', '@carmen_vg', 
 (SELECT id FROM organizations LIMIT 1), 'active', 34, 'bronze', 'advertencia', 1, 3, 4, 1200),

('Roberto', 'S√°nchez', 'roberto.sanchez@example.com', '@rob_sanchez', 
 (SELECT id FROM organizations LIMIT 1), 'active', 78, 'gold', 'cumple', 2, 6, 2, 4100);

-- Crear tareas de ejemplo para estos embajadores
INSERT INTO public.tasks (
  embassador_id,
  event_id,
  task_type,
  status,
  points_earned,
  reach_count,
  engagement_score,
  created_at,
  upload_time,
  platform
) 
SELECT 
  e.id as embassador_id,
  ev.id as event_id,
  (ARRAY['story', 'post', 'reel'])[floor(random() * 3 + 1)] as task_type,
  (ARRAY['completed', 'pending', 'invalid'])[floor(random() * 3 + 1)] as status,
  floor(random() * 5 + 1) as points_earned,
  floor(random() * 2000 + 100) as reach_count,
  random() * 10 as engagement_score,
  now() - (random() * interval '30 days') as created_at,
  now() - (random() * interval '25 days') as upload_time,
  'instagram'
FROM 
  embassadors e 
  CROSS JOIN events ev
  CROSS JOIN generate_series(1, 3) -- 3 tareas por embajador
WHERE 
  e.organization_id = (SELECT id FROM organizations LIMIT 1)
  AND ev.fiesta_id = (SELECT id FROM fiestas LIMIT 1);

-- Actualizar estad√≠sticas de tareas completadas/fallidas basadas en las tareas creadas
UPDATE embassadors 
SET 
  completed_tasks = (
    SELECT COUNT(*) 
    FROM tasks t 
    WHERE t.embassador_id = embassadors.id 
    AND t.status = 'completed'
  ),
  failed_tasks = (
    SELECT COUNT(*) 
    FROM tasks t 
    WHERE t.embassador_id = embassadors.id 
    AND t.status = 'invalid'
  ),
  global_points = (
    SELECT COALESCE(SUM(t.points_earned), 0)
    FROM tasks t 
    WHERE t.embassador_id = embassadors.id 
    AND t.status = 'completed'
  )
WHERE organization_id = (SELECT id FROM organizations LIMIT 1);

-- Crear algunas tareas adicionales para generar mejores datos hist√≥ricos
INSERT INTO public.tasks (
  embassador_id,
  event_id,
  task_type,
  status,
  points_earned,
  reach_count,
  engagement_score,
  created_at,
  upload_time,
  platform
) 
SELECT 
  e.id as embassador_id,
  ev.id as event_id,
  'story' as task_type,
  'completed' as status,
  2 as points_earned,
  floor(random() * 1500 + 500) as reach_count,
  random() * 8 + 2 as engagement_score,
  now() - (random() * interval '7 days') as created_at,
  now() - (random() * interval '5 days') as upload_time,
  'instagram'
FROM 
  embassadors e 
  CROSS JOIN events ev
  CROSS JOIN generate_series(1, 2) -- 2 tareas adicionales recientes
WHERE 
  e.organization_id = (SELECT id FROM organizations LIMIT 1)
  AND ev.fiesta_id = (SELECT id FROM fiestas LIMIT 1)
  AND e.performance_status IN ('cumple', 'exclusivo');
</file>

<file path="supabase/migrations/20250807164850_01cefc6c-a71a-4827-94a7-12bc22ca2619.sql">
-- Crear datos de prueba para Analytics usando solo valores v√°lidos
-- Usar solo 'bronze' para evitar errores de constraint
INSERT INTO public.embassadors (
  first_name, 
  last_name, 
  email, 
  instagram_user, 
  organization_id,
  status,
  global_points,
  performance_status,
  events_participated,
  completed_tasks,
  failed_tasks,
  follower_count
) VALUES 
-- Embajadores de alto rendimiento
('Mar√≠a', 'Gonz√°lez', 'maria.gonzalez@example.com', '@maria_glez', 
 (SELECT id FROM organizations LIMIT 1), 'active', 156, 'exclusivo', 3, 12, 1, 8500),

('Carlos', 'Rodr√≠guez', 'carlos.rodriguez@example.com', '@carlos_rod', 
 (SELECT id FROM organizations LIMIT 1), 'active', 134, 'cumple', 2, 10, 2, 5200),

('Ana', 'Mart√≠nez', 'ana.martinez@example.com', '@ana_mart', 
 (SELECT id FROM organizations LIMIT 1), 'active', 89, 'cumple', 2, 7, 3, 3800),

-- Embajadores de rendimiento medio
('Diego', 'L√≥pez', 'diego.lopez@example.com', '@diego_lp', 
 (SELECT id FROM organizations LIMIT 1), 'active', 67, 'advertencia', 1, 5, 4, 2100),

('Sof√≠a', 'Hern√°ndez', 'sofia.hernandez@example.com', '@sofia_hdz', 
 (SELECT id FROM organizations LIMIT 1), 'active', 45, 'cumple', 1, 4, 2, 1900),

-- Embajadores de bajo rendimiento
('Luis', 'Torres', 'luis.torres@example.com', '@luis_torres', 
 (SELECT id FROM organizations LIMIT 1), 'active', 23, 'no_cumple', 1, 2, 6, 890),

('Carmen', 'Vega', 'carmen.vega@example.com', '@carmen_vg', 
 (SELECT id FROM organizations LIMIT 1), 'active', 34, 'advertencia', 1, 3, 4, 1200),

('Roberto', 'S√°nchez', 'roberto.sanchez@example.com', '@rob_sanchez', 
 (SELECT id FROM organizations LIMIT 1), 'active', 78, 'cumple', 2, 6, 2, 4100);

-- Crear tareas de ejemplo para estos embajadores
WITH ambassador_event_pairs AS (
  SELECT e.id as embassador_id, ev.id as event_id
  FROM embassadors e 
  CROSS JOIN events ev
  WHERE e.organization_id = (SELECT id FROM organizations LIMIT 1)
    AND ev.fiesta_id = (SELECT id FROM fiestas LIMIT 1)
)
INSERT INTO public.tasks (
  embassador_id,
  event_id,
  task_type,
  status,
  points_earned,
  reach_count,
  engagement_score,
  created_at,
  upload_time,
  platform
) 
SELECT 
  embassador_id,
  event_id,
  'story' as task_type,
  CASE WHEN random() < 0.6 THEN 'completed'
       WHEN random() < 0.8 THEN 'pending'
       ELSE 'invalid' END as status,
  CASE WHEN random() < 0.6 THEN floor(random() * 3 + 2)
       ELSE 0 END as points_earned,
  floor(random() * 2000 + 100) as reach_count,
  random() * 10 as engagement_score,
  now() - (random() * interval '30 days') as created_at,
  now() - (random() * interval '25 days') as upload_time,
  'instagram'
FROM ambassador_event_pairs
CROSS JOIN generate_series(1, 3); -- 3 tareas por embajador

-- Actualizar estad√≠sticas reales basadas en las tareas creadas
UPDATE embassadors 
SET 
  completed_tasks = (
    SELECT COUNT(*) 
    FROM tasks t 
    WHERE t.embassador_id = embassadors.id 
    AND t.status = 'completed'
  ),
  failed_tasks = (
    SELECT COUNT(*) 
    FROM tasks t 
    WHERE t.embassador_id = embassadors.id 
    AND t.status = 'invalid'
  ),
  global_points = (
    SELECT COALESCE(SUM(t.points_earned), 0)
    FROM tasks t 
    WHERE t.embassador_id = embassadors.id 
    AND t.status = 'completed'
  )
WHERE organization_id = (SELECT id FROM organizations LIMIT 1);
</file>

<file path="supabase/migrations/20250807170546_c32bf32e-0541-4dc5-87d3-524d9ccae7e7.sql">
-- Add indexes to optimize analytics queries
CREATE INDEX IF NOT EXISTS idx_tasks_embassador_id ON tasks(embassador_id);
CREATE INDEX IF NOT EXISTS idx_tasks_event_id ON tasks(event_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_created_at ON tasks(created_at);
CREATE INDEX IF NOT EXISTS idx_embassadors_organization_id ON embassadors(organization_id);
CREATE INDEX IF NOT EXISTS idx_embassadors_status ON embassadors(status);
CREATE INDEX IF NOT EXISTS idx_events_fiesta_id ON events(fiesta_id);
CREATE INDEX IF NOT EXISTS idx_notifications_organization_id ON notifications(organization_id);
CREATE INDEX IF NOT EXISTS idx_notifications_read_status ON notifications(read_status);
</file>

<file path="supabase/migrations/20250811162727_be03bf7a-11bf-4701-9877-cd74b7950d45.sql">
-- Ensure proper search_path and security for trigger function
CREATE OR REPLACE FUNCTION public.update_organization_settings_updated_at()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- Restrict direct access to plans table to authenticated users only
DROP POLICY IF EXISTS "Users can view all plans" ON public.plans;
CREATE POLICY "Authenticated users can view plans"
ON public.plans
FOR SELECT
TO authenticated
USING (true);

-- Create a limited public view (still requires authentication due to table RLS)
CREATE OR REPLACE VIEW public.plans_public AS
SELECT name, price, max_ambassadors, max_events, is_active
FROM public.plans
WHERE is_active = true;
</file>

<file path="supabase/migrations/20250811180746_1d1637d8-f391-4e30-b67d-da2206e5ac38.sql">
-- Add missing columns for Meta/Instagram integration on organizations
ALTER TABLE public.organizations
ADD COLUMN IF NOT EXISTS instagram_user_id text,
ADD COLUMN IF NOT EXISTS instagram_username text,
ADD COLUMN IF NOT EXISTS facebook_page_id text,
ADD COLUMN IF NOT EXISTS instagram_business_account_id text;

-- Helpful indexes for lookups from webhooks and syncs
CREATE INDEX IF NOT EXISTS idx_organizations_instagram_user_id
  ON public.organizations (instagram_user_id);

CREATE INDEX IF NOT EXISTS idx_organizations_instagram_business_account_id
  ON public.organizations (instagram_business_account_id);
</file>

<file path="supabase/migrations/20250811191623_296b0a22-4886-4a0a-99bf-c6b2e5506bab.sql">
-- Fix linter ERROR 0010_security_definer_view by enabling security invoker on the affected view
-- This ensures the view enforces the caller's RLS policies instead of the view owner

-- Safeguard: only apply if the view exists
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM pg_views WHERE schemaname = 'public' AND viewname = 'plans_public'
  ) THEN
    EXECUTE 'ALTER VIEW public.plans_public SET (security_invoker = true)';
    COMMENT ON VIEW public.plans_public IS 'Security invoker enabled to enforce caller RLS (per Supabase linter 0010).';
  END IF;
END$$;
</file>

<file path="supabase/migrations/20250818195000_fcc80f72-8bb9-434f-8b1b-535ce27fdd85.sql">
-- Add redirect_base column to oauth_states table to support dynamic OAuth redirect URLs
ALTER TABLE oauth_states 
ADD COLUMN redirect_base text;
</file>

<file path="supabase/migrations/20250820202107_ea5b187c-250f-40f2-a7ff-aa073788f414.sql">
-- 1) Column-level privilege hardening for sensitive tokens

-- Organizations: prevent clients from reading token columns, but allow service_role.
REVOKE SELECT (meta_token, token_expiry) ON TABLE public.organizations FROM anon, authenticated, PUBLIC;
GRANT SELECT (meta_token, token_expiry) ON TABLE public.organizations TO service_role;

-- Keep UPDATE on these columns for authenticated so users can disconnect (set to NULL) if your UI does that.
-- If you prefer to block client updates too, uncomment the next lines:
-- REVOKE UPDATE (meta_token, token_expiry) ON TABLE public.organizations FROM anon, authenticated, PUBLIC;
-- GRANT UPDATE (meta_token, token_expiry) ON TABLE public.organizations TO service_role;

-- Embassadors: block clients from reading and updating token columns; allow only service_role.
REVOKE SELECT (instagram_access_token, token_expires_at) ON TABLE public.embassadors FROM anon, authenticated, PUBLIC;
REVOKE UPDATE (instagram_access_token, token_expires_at) ON TABLE public.embassadors FROM anon, authenticated, PUBLIC;
GRANT SELECT (instagram_access_token, token_expires_at) ON TABLE public.embassadors TO service_role;
GRANT UPDATE (instagram_access_token, token_expires_at) ON TABLE public.embassadors TO service_role;

-- 2) Tighten UPDATE on organizations: require created_by to remain the same
DROP POLICY IF EXISTS "Users can update own organizations" ON public.organizations;

CREATE POLICY "Users can update own organizations"
ON public.organizations
FOR UPDATE
USING (auth.uid() = created_by)
WITH CHECK (auth.uid() = created_by);

-- 3) Prevent user-controlled role escalation in users via trigger

-- Create the trigger function (idempotent-guarded)
CREATE OR REPLACE FUNCTION public.prevent_role_change()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  -- Allow service_role to change roles (for admin flows/edge functions).
  IF current_user = 'service_role' THEN
    RETURN NEW;
  END IF;

  -- Block role changes by regular clients.
  IF NEW.role IS DISTINCT FROM OLD.role THEN
    RAISE EXCEPTION 'Changing role is not allowed';
  END IF;

  RETURN NEW;
END;
$$;

-- Attach trigger if not exists
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_trigger
    WHERE tgrelid = 'public.users'::regclass
      AND tgname = 'trg_prevent_role_change'
  ) THEN
    CREATE TRIGGER trg_prevent_role_change
    BEFORE UPDATE ON public.users
    FOR EACH ROW
    EXECUTE FUNCTION public.prevent_role_change();
  END IF;
END$$;
</file>

<file path="supabase/migrations/20250820202942_15ecef57-50d8-49a1-b0a1-9a7437d0a3c9.sql">
-- Phase 1: Critical Security Fixes
-- =================================

-- 1. PROTECT SENSITIVE TOKEN COLUMNS
-- Make sensitive Instagram/Meta token columns only accessible by service_role
ALTER POLICY "Users can view own organization embassadors" ON public.embassadors 
DROP USING;

CREATE POLICY "Users can view own organization embassadors" 
ON public.embassadors 
FOR SELECT 
USING (
  CASE 
    -- Service role can see everything
    WHEN current_user = 'service_role' THEN true
    -- Regular users can see their org ambassadors but not sensitive token fields
    ELSE (organization_id IN ( 
      SELECT organizations.id
      FROM organizations
      WHERE (organizations.created_by = auth.uid())
    ))
  END
);

-- Create a view for safe ambassador data (without tokens)
CREATE OR REPLACE VIEW public.embassadors_safe AS
SELECT 
  id,
  first_name,
  last_name,
  email,
  instagram_user,
  instagram_user_id,
  follower_count,
  profile_picture_url,
  date_of_birth,
  rut,
  global_points,
  global_category,
  performance_status,
  events_participated,
  completed_tasks,
  failed_tasks,
  organization_id,
  created_by_user_id,
  status,
  profile_public,
  last_instagram_sync,
  created_at,
  -- Hide sensitive token fields from regular users
  CASE 
    WHEN current_user = 'service_role' THEN instagram_access_token
    ELSE NULL
  END as instagram_access_token,
  CASE 
    WHEN current_user = 'service_role' THEN token_expires_at
    ELSE NULL
  END as token_expires_at
FROM public.embassadors;

-- Grant access to the safe view
GRANT SELECT ON public.embassadors_safe TO authenticated;

-- Apply same protection to organizations table
ALTER POLICY "Users can view own organizations" ON public.organizations
DROP USING;

CREATE POLICY "Users can view own organizations" 
ON public.organizations 
FOR SELECT 
USING (
  CASE 
    -- Service role can see everything
    WHEN current_user = 'service_role' THEN true
    -- Regular users can see their orgs but not sensitive token fields
    ELSE (created_by = auth.uid())
  END
);

-- Create safe view for organizations
CREATE OR REPLACE VIEW public.organizations_safe AS
SELECT 
  id,
  name,
  description,
  timezone,
  logo_url,
  plan_type,
  instagram_username,
  facebook_page_id,
  instagram_business_account_id,
  instagram_user_id,
  last_instagram_sync,
  created_by,
  created_at,
  -- Hide sensitive token fields from regular users
  CASE 
    WHEN current_user = 'service_role' THEN meta_token
    ELSE NULL
  END as meta_token,
  CASE 
    WHEN current_user = 'service_role' THEN token_expiry
    ELSE NULL
  END as token_expiry
FROM public.organizations;

-- Grant access to the safe view
GRANT SELECT ON public.organizations_safe TO authenticated;

-- 2. PREVENT ROLE ESCALATION
-- Add trigger to prevent users from changing their own roles
CREATE OR REPLACE FUNCTION public.prevent_role_change()
RETURNS TRIGGER AS $$
BEGIN
  -- Allow service_role to change roles (for admin flows/edge functions)
  IF current_user = 'service_role' THEN
    RETURN NEW;
  END IF;

  -- Block role changes by regular clients
  IF NEW.role IS DISTINCT FROM OLD.role THEN
    RAISE EXCEPTION 'Changing role is not allowed';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply the trigger to users table
DROP TRIGGER IF EXISTS prevent_role_change_trigger ON public.users;
CREATE TRIGGER prevent_role_change_trigger
  BEFORE UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION public.prevent_role_change();

-- 3. FIX RLS POLICY WARNINGS
-- Add proper RLS to plans_public table
ALTER TABLE public.plans_public ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public plans are viewable by authenticated users" 
ON public.plans_public 
FOR SELECT 
TO authenticated
USING (is_active = true);

-- 4. IMPROVE FUNCTION SECURITY
-- Update existing functions to have proper search_path
CREATE OR REPLACE FUNCTION public.get_organization_hierarchy(org_id uuid)
RETURNS TABLE(id uuid, name text, description text, organization_type text, is_main_account boolean, level integer)
LANGUAGE sql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
WITH RECURSIVE hierarchy AS (
  -- Base case: start with the given organization
  SELECT 
    o.id,
    o.name,
    o.description,
    o.organization_type,
    o.is_main_account,
    0 as level
  FROM public.organizations o
  WHERE o.id = org_id
  
  UNION ALL
  
  -- Recursive case: find children
  SELECT 
    o.id,
    o.name,
    o.description,
    o.organization_type,
    o.is_main_account,
    h.level + 1
  FROM public.organizations o
  JOIN hierarchy h ON o.parent_organization_id = h.id
)
SELECT * FROM hierarchy ORDER BY level, name;
$$;

CREATE OR REPLACE FUNCTION public.get_user_organization_ids(user_id uuid)
RETURNS TABLE(organization_id uuid)
LANGUAGE sql
STABLE SECURITY DEFINER
SET search_path TO 'public'
AS $$
  SELECT id FROM organizations WHERE created_by = user_id;
$$;

CREATE OR REPLACE FUNCTION public.cleanup_expired_oauth_states()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  DELETE FROM public.oauth_states WHERE expires_at < now();
END;
$$;
</file>

<file path="supabase/migrations/20250820203059_a16ade44-7b02-431e-a5d7-c0f1f01a5773.sql">
-- Phase 1: Critical Security Fixes
-- =================================

-- 1. PROTECT SENSITIVE TOKEN COLUMNS
-- Fix ambassadors policy - drop and recreate with proper protection
DROP POLICY IF EXISTS "Users can view own organization embassadors" ON public.embassadors;

CREATE POLICY "Users can view own organization embassadors" 
ON public.embassadors 
FOR SELECT 
USING (
  CASE 
    -- Service role can see everything
    WHEN current_user = 'service_role' THEN true
    -- Regular users can see their org ambassadors but not sensitive token fields
    ELSE (organization_id IN ( 
      SELECT organizations.id
      FROM organizations
      WHERE (organizations.created_by = auth.uid())
    ))
  END
);

-- Create a view for safe ambassador data (without tokens)
CREATE OR REPLACE VIEW public.embassadors_safe AS
SELECT 
  id,
  first_name,
  last_name,
  email,
  instagram_user,
  instagram_user_id,
  follower_count,
  profile_picture_url,
  date_of_birth,
  rut,
  global_points,
  global_category,
  performance_status,
  events_participated,
  completed_tasks,
  failed_tasks,
  organization_id,
  created_by_user_id,
  status,
  profile_public,
  last_instagram_sync,
  created_at,
  -- Hide sensitive token fields from regular users
  CASE 
    WHEN current_user = 'service_role' THEN instagram_access_token
    ELSE NULL
  END as instagram_access_token,
  CASE 
    WHEN current_user = 'service_role' THEN token_expires_at
    ELSE NULL
  END as token_expires_at
FROM public.embassadors;

-- Grant access to the safe view
GRANT SELECT ON public.embassadors_safe TO authenticated;

-- Fix organizations policy - drop and recreate with proper protection
DROP POLICY IF EXISTS "Users can view own organizations" ON public.organizations;

CREATE POLICY "Users can view own organizations" 
ON public.organizations 
FOR SELECT 
USING (
  CASE 
    -- Service role can see everything
    WHEN current_user = 'service_role' THEN true
    -- Regular users can see their orgs but not sensitive token fields
    ELSE (created_by = auth.uid())
  END
);

-- Create safe view for organizations
CREATE OR REPLACE VIEW public.organizations_safe AS
SELECT 
  id,
  name,
  description,
  timezone,
  logo_url,
  plan_type,
  instagram_username,
  facebook_page_id,
  instagram_business_account_id,
  instagram_user_id,
  last_instagram_sync,
  created_by,
  created_at,
  -- Hide sensitive token fields from regular users
  CASE 
    WHEN current_user = 'service_role' THEN meta_token
    ELSE NULL
  END as meta_token,
  CASE 
    WHEN current_user = 'service_role' THEN token_expiry
    ELSE NULL
  END as token_expiry
FROM public.organizations;

-- Grant access to the safe view
GRANT SELECT ON public.organizations_safe TO authenticated;

-- 2. PREVENT ROLE ESCALATION
-- The function already exists, just ensure the trigger is applied
DROP TRIGGER IF EXISTS prevent_role_change_trigger ON public.users;
CREATE TRIGGER prevent_role_change_trigger
  BEFORE UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION public.prevent_role_change();

-- 3. FIX RLS POLICY WARNINGS
-- Add proper RLS to plans_public table
ALTER TABLE public.plans_public ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public plans are viewable by authenticated users" 
ON public.plans_public 
FOR SELECT 
TO authenticated
USING (is_active = true);
</file>

<file path="supabase/migrations/20250820203141_d1a73e87-732a-4ba9-9c26-7b9cb9a61378.sql">
-- Phase 1: Critical Security Fixes (Corrected)
-- ===============================================

-- 1. PROTECT SENSITIVE TOKEN COLUMNS
-- Fix ambassadors policy for safe access
DROP POLICY IF EXISTS "Users can view own organization embassadors" ON public.embassadors;

CREATE POLICY "Users can view own organization embassadors" 
ON public.embassadors 
FOR SELECT 
USING (organization_id IN ( 
  SELECT organizations.id
  FROM organizations
  WHERE (organizations.created_by = auth.uid())
));

-- Create a view for safe ambassador data (without tokens)
CREATE OR REPLACE VIEW public.embassadors_safe AS
SELECT 
  id,
  first_name,
  last_name,
  email,
  instagram_user,
  instagram_user_id,
  follower_count,
  profile_picture_url,
  date_of_birth,
  rut,
  global_points,
  global_category,
  performance_status,
  events_participated,
  completed_tasks,
  failed_tasks,
  organization_id,
  created_by_user_id,
  status,
  profile_public,
  last_instagram_sync,
  created_at,
  -- Always hide sensitive token fields from regular users
  NULL as instagram_access_token,
  NULL as token_expires_at
FROM public.embassadors;

-- Grant access to the safe view
GRANT SELECT ON public.embassadors_safe TO authenticated;

-- Fix organizations policy for safe access
DROP POLICY IF EXISTS "Users can view own organizations" ON public.organizations;

CREATE POLICY "Users can view own organizations" 
ON public.organizations 
FOR SELECT 
USING (created_by = auth.uid());

-- Create safe view for organizations (hide sensitive tokens)
CREATE OR REPLACE VIEW public.organizations_safe AS
SELECT 
  id,
  name,
  description,
  timezone,
  logo_url,
  plan_type,
  instagram_username,
  facebook_page_id,
  instagram_business_account_id,
  instagram_user_id,
  last_instagram_sync,
  created_by,
  created_at,
  -- Always hide sensitive token fields from regular users
  NULL as meta_token,
  NULL as token_expiry
FROM public.organizations;

-- Grant access to the safe view
GRANT SELECT ON public.organizations_safe TO authenticated;

-- 2. PREVENT ROLE ESCALATION
-- Ensure the trigger is applied (function already exists)
DROP TRIGGER IF EXISTS prevent_role_change_trigger ON public.users;
CREATE TRIGGER prevent_role_change_trigger
  BEFORE UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION public.prevent_role_change();
</file>

<file path="supabase/migrations/20250820203208_73fca020-156e-4f21-9a20-a067ec44c363.sql">
-- Phase 1: Critical Security Fixes (Corrected)
-- ===============================================

-- 1. PROTECT SENSITIVE TOKEN COLUMNS
-- Fix ambassadors policy for safe access
DROP POLICY IF EXISTS "Users can view own organization embassadors" ON public.embassadors;

CREATE POLICY "Users can view own organization embassadors" 
ON public.embassadors 
FOR SELECT 
USING (organization_id IN ( 
  SELECT organizations.id
  FROM organizations
  WHERE (organizations.created_by = auth.uid())
));

-- Create a view for safe ambassador data (without tokens)
CREATE OR REPLACE VIEW public.embassadors_safe AS
SELECT 
  id,
  first_name,
  last_name,
  email,
  instagram_user,
  instagram_user_id,
  follower_count,
  profile_picture_url,
  date_of_birth,
  rut,
  global_points,
  global_category,
  performance_status,
  events_participated,
  completed_tasks,
  failed_tasks,
  organization_id,
  created_by_user_id,
  status,
  profile_public,
  last_instagram_sync,
  created_at,
  -- Always hide sensitive token fields from regular users
  NULL as instagram_access_token,
  NULL as token_expires_at
FROM public.embassadors;

-- Grant access to the safe view
GRANT SELECT ON public.embassadors_safe TO authenticated;

-- Fix organizations policy for safe access
DROP POLICY IF EXISTS "Users can view own organizations" ON public.organizations;

CREATE POLICY "Users can view own organizations" 
ON public.organizations 
FOR SELECT 
USING (created_by = auth.uid());

-- Create safe view for organizations (hide sensitive tokens)
CREATE OR REPLACE VIEW public.organizations_safe AS
SELECT 
  id,
  name,
  description,
  timezone,
  logo_url,
  plan_type,
  instagram_username,
  facebook_page_id,
  instagram_business_account_id,
  instagram_user_id,
  last_instagram_sync,
  created_by,
  created_at,
  -- Always hide sensitive token fields from regular users
  NULL as meta_token,
  NULL as token_expiry
FROM public.organizations;

-- Grant access to the safe view
GRANT SELECT ON public.organizations_safe TO authenticated;

-- 2. PREVENT ROLE ESCALATION
-- Ensure the trigger is applied (function already exists)
DROP TRIGGER IF EXISTS prevent_role_change_trigger ON public.users;
CREATE TRIGGER prevent_role_change_trigger
  BEFORE UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION public.prevent_role_change();
</file>

<file path="supabase/migrations/20250820203511_da55945b-622f-4df7-b725-c219697816d8.sql">
-- Final Security Fix: Add RLS to Safe Views
-- ==========================================

-- Enable RLS on safe views and add proper policies
ALTER VIEW public.embassadors_safe SET (security_barrier = true, check_option = cascaded);
ALTER VIEW public.organizations_safe SET (security_barrier = true, check_option = cascaded);

-- Drop the existing views and recreate them as proper security definer views with RLS
DROP VIEW IF EXISTS public.embassadors_safe;
DROP VIEW IF EXISTS public.organizations_safe;

-- Create secure function to get safe ambassador data
CREATE OR REPLACE FUNCTION public.get_safe_ambassador_data(user_organization_ids uuid[])
RETURNS TABLE (
  id uuid,
  first_name text,
  last_name text,
  email text,
  instagram_user text,
  instagram_user_id text,
  follower_count integer,
  profile_picture_url text,
  date_of_birth date,
  rut text,
  global_points integer,
  global_category text,
  performance_status text,
  events_participated integer,
  completed_tasks integer,
  failed_tasks integer,
  organization_id uuid,
  created_by_user_id uuid,
  status text,
  profile_public boolean,
  last_instagram_sync timestamp with time zone,
  created_at timestamp with time zone,
  instagram_access_token text,
  token_expires_at timestamp with time zone
)
LANGUAGE sql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
  SELECT 
    e.id,
    e.first_name,
    e.last_name,
    e.email,
    e.instagram_user,
    e.instagram_user_id,
    e.follower_count,
    e.profile_picture_url,
    e.date_of_birth,
    e.rut,
    e.global_points,
    e.global_category,
    e.performance_status,
    e.events_participated,
    e.completed_tasks,
    e.failed_tasks,
    e.organization_id,
    e.created_by_user_id,
    e.status,
    e.profile_public,
    e.last_instagram_sync,
    e.created_at,
    -- Always hide sensitive token fields from regular users
    NULL::text as instagram_access_token,
    NULL::timestamp with time zone as token_expires_at
  FROM public.embassadors e
  WHERE e.organization_id = ANY(user_organization_ids);
$$;

-- Create secure function to get safe organization data
CREATE OR REPLACE FUNCTION public.get_safe_organization_data(user_id uuid)
RETURNS TABLE (
  id uuid,
  name text,
  description text,
  timezone text,
  logo_url text,
  plan_type text,
  instagram_username text,
  facebook_page_id text,
  instagram_business_account_id text,
  instagram_user_id text,
  last_instagram_sync timestamp with time zone,
  created_by uuid,
  created_at timestamp with time zone,
  meta_token text,
  token_expiry timestamp with time zone
)
LANGUAGE sql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
  SELECT 
    o.id,
    o.name,
    o.description,
    o.timezone,
    o.logo_url,
    o.plan_type,
    o.instagram_username,
    o.facebook_page_id,
    o.instagram_business_account_id,
    o.instagram_user_id,
    o.last_instagram_sync,
    o.created_by,
    o.created_at,
    -- Always hide sensitive token fields from regular users
    NULL::text as meta_token,
    NULL::timestamp with time zone as token_expiry
  FROM public.organizations o
  WHERE o.created_by = user_id;
$$;

-- Recreate views using the secure functions
CREATE OR REPLACE VIEW public.embassadors_safe AS
SELECT * FROM public.get_safe_ambassador_data(
  ARRAY(SELECT id FROM organizations WHERE created_by = auth.uid())
);

CREATE OR REPLACE VIEW public.organizations_safe AS
SELECT * FROM public.get_safe_organization_data(auth.uid());

-- Grant permissions to authenticated users
GRANT SELECT ON public.embassadors_safe TO authenticated;
GRANT SELECT ON public.organizations_safe TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_safe_ambassador_data TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_safe_organization_data TO authenticated;
</file>

<file path="supabase/migrations/20250820204442_2829495c-e27e-411f-a36f-3e94b52d41e9.sql">
-- CRITICAL SECURITY FIXES - Phase 1
-- Fix exposed sensitive data and privilege escalation vulnerabilities

-- 1. Drop insecure safe views that expose sensitive data
DROP VIEW IF EXISTS public.embassadors_safe CASCADE;
DROP VIEW IF EXISTS public.organizations_safe CASCADE;
DROP VIEW IF EXISTS public.plans_public CASCADE;

-- 2. Add trigger to prevent role escalation in users table
CREATE OR REPLACE FUNCTION public.prevent_user_privilege_escalation()
RETURNS TRIGGER AS $$
BEGIN
  -- Allow service_role to manage all fields
  IF current_user = 'service_role' THEN
    RETURN NEW;
  END IF;
  
  -- For regular users, prevent role changes and organization_id manipulation
  IF TG_OP = 'INSERT' THEN
    -- Force new users to have 'user' role, not 'admin'
    NEW.role := 'user';
    -- Only allow setting organization_id if user owns it
    IF NEW.organization_id IS NOT NULL THEN
      IF NOT EXISTS (
        SELECT 1 FROM public.organizations 
        WHERE id = NEW.organization_id AND created_by = auth.uid()
      ) THEN
        RAISE EXCEPTION 'Cannot assign to organization you do not own';
      END IF;
    END IF;
  END IF;
  
  IF TG_OP = 'UPDATE' THEN
    -- Prevent role changes by regular users
    IF NEW.role IS DISTINCT FROM OLD.role THEN
      RAISE EXCEPTION 'Role changes not allowed';
    END IF;
    -- Prevent organization_id changes
    IF NEW.organization_id IS DISTINCT FROM OLD.organization_id THEN
      RAISE EXCEPTION 'Organization changes not allowed';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public';

-- Drop existing trigger if exists and create new one
DROP TRIGGER IF EXISTS prevent_user_privilege_escalation_trigger ON public.users;
CREATE TRIGGER prevent_user_privilege_escalation_trigger
  BEFORE INSERT OR UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION public.prevent_user_privilege_escalation();

-- 3. Update users table default role to 'user' instead of 'admin'
ALTER TABLE public.users ALTER COLUMN role SET DEFAULT 'user';

-- 4. Add proper RLS policies for users table with stricter checks
DROP POLICY IF EXISTS "Users can create own profile" ON public.users;
DROP POLICY IF EXISTS "Users can update own profile" ON public.users;

CREATE POLICY "Users can create own profile" ON public.users
  FOR INSERT WITH CHECK (
    auth.uid() = auth_user_id AND
    role = 'user' AND
    (organization_id IS NULL OR organization_id IN (
      SELECT id FROM public.organizations WHERE created_by = auth.uid()
    ))
  );

CREATE POLICY "Users can update own profile" ON public.users
  FOR UPDATE USING (auth.uid() = auth_user_id)
  WITH CHECK (
    auth.uid() = auth_user_id AND
    role = OLD.role AND -- Prevent role changes
    organization_id = OLD.organization_id -- Prevent org changes
  );

-- 5. Create secure RPC functions to replace unsafe views
CREATE OR REPLACE FUNCTION public.get_organization_safe_info(org_id uuid DEFAULT NULL)
RETURNS TABLE(
  id uuid,
  name text,
  description text,
  timezone text,
  logo_url text,
  plan_type text,
  instagram_username text,
  instagram_connected boolean,
  last_instagram_sync timestamp with time zone,
  created_at timestamp with time zone
) LANGUAGE sql SECURITY DEFINER SET search_path TO 'public' AS $$
  SELECT 
    o.id,
    o.name,
    o.description,
    o.timezone,
    o.logo_url,
    o.plan_type,
    o.instagram_username,
    (o.meta_token IS NOT NULL) as instagram_connected,
    o.last_instagram_sync,
    o.created_at
  FROM public.organizations o
  WHERE (org_id IS NULL OR o.id = org_id)
    AND o.created_by = auth.uid();
$$;

CREATE OR REPLACE FUNCTION public.get_ambassador_safe_info(org_id uuid DEFAULT NULL)
RETURNS TABLE(
  id uuid,
  first_name text,
  last_name text,
  email text,
  instagram_user text,
  follower_count integer,
  profile_picture_url text,
  global_points integer,
  global_category text,
  performance_status text,
  events_participated integer,
  completed_tasks integer,
  failed_tasks integer,
  organization_id uuid,
  status text,
  profile_public boolean,
  last_instagram_sync timestamp with time zone,
  created_at timestamp with time zone
) LANGUAGE sql SECURITY DEFINER SET search_path TO 'public' AS $$
  SELECT 
    e.id,
    e.first_name,
    e.last_name,
    e.email,
    e.instagram_user,
    e.follower_count,
    e.profile_picture_url,
    e.global_points,
    e.global_category,
    e.performance_status,
    e.events_participated,
    e.completed_tasks,
    e.failed_tasks,
    e.organization_id,
    e.status,
    e.profile_public,
    e.last_instagram_sync,
    e.created_at
  FROM public.embassadors e
  WHERE (org_id IS NULL OR e.organization_id = org_id)
    AND e.organization_id IN (
      SELECT id FROM public.organizations WHERE created_by = auth.uid()
    );
$$;

-- 6. Fix existing SECURITY DEFINER functions to have proper search_path
CREATE OR REPLACE FUNCTION public.get_safe_organization_data(user_id uuid)
RETURNS TABLE(
  id uuid, name text, description text, timezone text, logo_url text, plan_type text, 
  instagram_username text, facebook_page_id text, instagram_business_account_id text, 
  instagram_user_id text, last_instagram_sync timestamp with time zone, 
  created_by uuid, created_at timestamp with time zone, 
  meta_token text, token_expiry timestamp with time zone
)
LANGUAGE sql SECURITY DEFINER SET search_path TO 'public' AS $$
  SELECT 
    o.id, o.name, o.description, o.timezone, o.logo_url, o.plan_type,
    o.instagram_username, o.facebook_page_id, o.instagram_business_account_id,
    o.instagram_user_id, o.last_instagram_sync, o.created_by, o.created_at,
    -- Always hide sensitive token fields from regular users
    NULL::text as meta_token,
    NULL::timestamp with time zone as token_expiry
  FROM public.organizations o
  WHERE o.created_by = user_id;
$$;

CREATE OR REPLACE FUNCTION public.get_safe_ambassador_data(user_organization_ids uuid[])
RETURNS TABLE(
  id uuid, first_name text, last_name text, email text, instagram_user text, 
  instagram_user_id text, follower_count integer, profile_picture_url text, 
  date_of_birth date, rut text, global_points integer, global_category text, 
  performance_status text, events_participated integer, completed_tasks integer, 
  failed_tasks integer, organization_id uuid, created_by_user_id uuid, 
  status text, profile_public boolean, last_instagram_sync timestamp with time zone, 
  created_at timestamp with time zone, instagram_access_token text, token_expires_at timestamp with time zone
)
LANGUAGE sql SECURITY DEFINER SET search_path TO 'public' AS $$
  SELECT 
    e.id, e.first_name, e.last_name, e.email, e.instagram_user, e.instagram_user_id,
    e.follower_count, e.profile_picture_url, e.date_of_birth, e.rut, e.global_points,
    e.global_category, e.performance_status, e.events_participated, e.completed_tasks,
    e.failed_tasks, e.organization_id, e.created_by_user_id, e.status, e.profile_public,
    e.last_instagram_sync, e.created_at,
    -- Always hide sensitive token fields from regular users
    NULL::text as instagram_access_token,
    NULL::timestamp with time zone as token_expires_at
  FROM public.embassadors e
  WHERE e.organization_id = ANY(user_organization_ids);
$$;

-- Update other functions to have proper search_path
CREATE OR REPLACE FUNCTION public.get_organization_hierarchy(org_id uuid)
RETURNS TABLE(id uuid, name text, description text, organization_type text, is_main_account boolean, level integer)
LANGUAGE sql SECURITY DEFINER SET search_path TO 'public' AS $$
WITH RECURSIVE hierarchy AS (
  SELECT 
    o.id, o.name, o.description, o.organization_type, o.is_main_account, 0 as level
  FROM public.organizations o
  WHERE o.id = org_id
  
  UNION ALL
  
  SELECT 
    o.id, o.name, o.description, o.organization_type, o.is_main_account, h.level + 1
  FROM public.organizations o
  JOIN hierarchy h ON o.parent_organization_id = h.id
)
SELECT * FROM hierarchy ORDER BY level, name;
$$;

CREATE OR REPLACE FUNCTION public.cleanup_expired_oauth_states()
RETURNS void
LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
BEGIN
  DELETE FROM public.oauth_states WHERE expires_at < now();
END;
$$;

CREATE OR REPLACE FUNCTION public.get_user_organization_ids(user_id uuid)
RETURNS TABLE(organization_id uuid)
LANGUAGE sql STABLE SECURITY DEFINER SET search_path TO 'public' AS $$
  SELECT id FROM organizations WHERE created_by = user_id;
$$;

CREATE OR REPLACE FUNCTION public.update_organization_settings_updated_at()
RETURNS trigger
LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;
</file>

<file path="supabase/migrations/20250820204650_ebdc6b47-8529-485f-85e1-b32139bc343f.sql">
-- CRITICAL SECURITY FIXES - Phase 1A
-- Fix exposed sensitive data and privilege escalation vulnerabilities

-- 1. Drop insecure safe views that expose sensitive data
DROP VIEW IF EXISTS public.embassadors_safe CASCADE;
DROP VIEW IF EXISTS public.organizations_safe CASCADE;
DROP VIEW IF EXISTS public.plans_public CASCADE;

-- 2. Update users table default role to 'user' instead of 'admin'
ALTER TABLE public.users ALTER COLUMN role SET DEFAULT 'user';

-- 3. Add trigger to prevent role escalation in users table
CREATE OR REPLACE FUNCTION public.prevent_user_privilege_escalation()
RETURNS TRIGGER AS $$
BEGIN
  -- Allow service_role to manage all fields
  IF current_user = 'service_role' THEN
    RETURN NEW;
  END IF;
  
  -- For regular users, prevent role changes and organization_id manipulation
  IF TG_OP = 'INSERT' THEN
    -- Force new users to have 'user' role, not 'admin'
    NEW.role := 'user';
    -- Only allow setting organization_id if user owns it
    IF NEW.organization_id IS NOT NULL THEN
      IF NOT EXISTS (
        SELECT 1 FROM public.organizations 
        WHERE id = NEW.organization_id AND created_by = auth.uid()
      ) THEN
        RAISE EXCEPTION 'Cannot assign to organization you do not own';
      END IF;
    END IF;
  END IF;
  
  IF TG_OP = 'UPDATE' THEN
    -- Prevent role changes by regular users
    IF NEW.role IS DISTINCT FROM OLD.role THEN
      RAISE EXCEPTION 'Role changes not allowed';
    END IF;
    -- Prevent organization_id changes
    IF NEW.organization_id IS DISTINCT FROM OLD.organization_id THEN
      RAISE EXCEPTION 'Organization changes not allowed';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public';

-- Drop existing trigger if exists and create new one
DROP TRIGGER IF EXISTS prevent_user_privilege_escalation_trigger ON public.users;
CREATE TRIGGER prevent_user_privilege_escalation_trigger
  BEFORE INSERT OR UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION public.prevent_user_privilege_escalation();
</file>

<file path="supabase/migrations/20250820204840_d1dda474-a8ac-47ee-95ba-45f53c5eec43.sql">
-- CRITICAL SECURITY FIXES - Phase 1B
-- Fix RLS policies with correct syntax

-- Add proper RLS policies for users table with stricter checks
DROP POLICY IF EXISTS "Users can create own profile" ON public.users;
DROP POLICY IF EXISTS "Users can update own profile" ON public.users;

CREATE POLICY "Users can create own profile" ON public.users
  FOR INSERT WITH CHECK (
    auth.uid() = auth_user_id AND
    role = 'user' AND
    (organization_id IS NULL OR organization_id IN (
      SELECT id FROM public.organizations WHERE created_by = auth.uid()
    ))
  );

CREATE POLICY "Users can update own profile" ON public.users
  FOR UPDATE USING (auth.uid() = auth_user_id)
  WITH CHECK (auth.uid() = auth_user_id);

-- Create secure RPC functions to replace unsafe views
CREATE OR REPLACE FUNCTION public.get_organization_safe_info(org_id uuid DEFAULT NULL)
RETURNS TABLE(
  id uuid,
  name text,
  description text,
  timezone text,
  logo_url text,
  plan_type text,
  instagram_username text,
  instagram_connected boolean,
  last_instagram_sync timestamp with time zone,
  created_at timestamp with time zone
) LANGUAGE sql SECURITY DEFINER SET search_path TO 'public' AS $$
  SELECT 
    o.id,
    o.name,
    o.description,
    o.timezone,
    o.logo_url,
    o.plan_type,
    o.instagram_username,
    (o.meta_token IS NOT NULL) as instagram_connected,
    o.last_instagram_sync,
    o.created_at
  FROM public.organizations o
  WHERE (org_id IS NULL OR o.id = org_id)
    AND o.created_by = auth.uid();
$$;

CREATE OR REPLACE FUNCTION public.get_ambassador_safe_info(org_id uuid DEFAULT NULL)
RETURNS TABLE(
  id uuid,
  first_name text,
  last_name text,
  email text,
  instagram_user text,
  follower_count integer,
  profile_picture_url text,
  global_points integer,
  global_category text,
  performance_status text,
  events_participated integer,
  completed_tasks integer,
  failed_tasks integer,
  organization_id uuid,
  status text,
  profile_public boolean,
  last_instagram_sync timestamp with time zone,
  created_at timestamp with time zone
) LANGUAGE sql SECURITY DEFINER SET search_path TO 'public' AS $$
  SELECT 
    e.id,
    e.first_name,
    e.last_name,
    e.email,
    e.instagram_user,
    e.follower_count,
    e.profile_picture_url,
    e.global_points,
    e.global_category,
    e.performance_status,
    e.events_participated,
    e.completed_tasks,
    e.failed_tasks,
    e.organization_id,
    e.status,
    e.profile_public,
    e.last_instagram_sync,
    e.created_at
  FROM public.embassadors e
  WHERE (org_id IS NULL OR e.organization_id = org_id)
    AND e.organization_id IN (
      SELECT id FROM public.organizations WHERE created_by = auth.uid()
    );
$$;
</file>

<file path="supabase/migrations/20250820213436_750847ba-049f-446b-9257-bf22594de8c5.sql">
-- Fix the user role check constraint to allow 'user' role
ALTER TABLE public.users DROP CONSTRAINT IF EXISTS users_role_check;
ALTER TABLE public.users ADD CONSTRAINT users_role_check CHECK (role IN ('admin', 'user', 'viewer'));

-- Update any existing users with 'admin' role to 'user' role for non-service accounts
UPDATE public.users SET role = 'user' WHERE role = 'admin' AND auth_user_id IS NOT NULL;
</file>

<file path="supabase/migrations/20250820214206_ace36894-d0b7-4bc8-812b-b5e49182dda2.sql">
-- Fix the user role check constraint to properly allow 'user' role
ALTER TABLE public.users DROP CONSTRAINT IF EXISTS users_role_check;
ALTER TABLE public.users ADD CONSTRAINT users_role_check CHECK (role IN ('admin', 'user', 'viewer'));

-- Add foreign key constraint between users and organizations for data integrity
ALTER TABLE public.users 
ADD CONSTRAINT fk_users_organization 
FOREIGN KEY (organization_id) 
REFERENCES public.organizations(id) 
ON DELETE SET NULL;
</file>

<file path="supabase/migrations/20250820215548_2a3bbca0-8d86-4a4d-9acd-3de24a7de323.sql">
-- 1) Tabla para credenciales por organizaci√≥n (APP ID/SECRET/VERIFY TOKEN)
create table if not exists public.organization_meta_credentials (
  id uuid primary key default gen_random_uuid(),
  organization_id uuid not null references public.organizations(id) on delete cascade,
  meta_app_id text not null,
  meta_app_secret text not null,
  webhook_verify_token text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (organization_id)
);

-- Seguridad: habilitar RLS y no crear pol√≠ticas de lectura/escritura por defecto.
-- (Los clientes no podr√°n leer esta tabla directamente)
alter table public.organization_meta_credentials enable row level security;

-- √çndices √∫tiles
create index if not exists idx_omc_org_id on public.organization_meta_credentials(organization_id);
create index if not exists idx_omc_verify_token on public.organization_meta_credentials(webhook_verify_token);

-- Trigger para updated_at
create or replace function public.update_omc_updated_at()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  new.updated_at := now();
  return new;
end;
$$;

drop trigger if exists trg_omc_updated_at on public.organization_meta_credentials;
create trigger trg_omc_updated_at
before update on public.organization_meta_credentials
for each row execute procedure public.update_omc_updated_at();

-- 2) RPC: Upsert seguro de credenciales (no expone secretos en el retorno)
create or replace function public.upsert_org_meta_credentials(
  p_organization_id uuid,
  p_meta_app_id text,
  p_meta_app_secret text,
  p_webhook_verify_token text
)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  -- Validar que el usuario actual sea due√±o de la organizaci√≥n
  if not exists (
    select 1 from public.organizations o
    where o.id = p_organization_id and o.created_by = auth.uid()
  ) then
    raise exception 'No autorizado para gestionar credenciales de esta organizaci√≥n';
  end if;

  insert into public.organization_meta_credentials(
    organization_id, meta_app_id, meta_app_secret, webhook_verify_token
  )
  values (p_organization_id, p_meta_app_id, p_meta_app_secret, p_webhook_verify_token)
  on conflict (organization_id)
  do update set
    meta_app_id = excluded.meta_app_id,
    meta_app_secret = excluded.meta_app_secret,
    webhook_verify_token = excluded.webhook_verify_token,
    updated_at = now();
end;
$$;

-- 3) RPC: Estado seguro de credenciales (sin exponer valores)
create or replace function public.get_org_meta_credentials_status(
  p_organization_id uuid
)
returns table(
  has_credentials boolean,
  updated_at timestamptz
)
language plpgsql
security definer
set search_path = public
as $$
begin
  -- Validar que el usuario actual sea due√±o de la organizaci√≥n
  if not exists (
    select 1 from public.organizations o
    where o.id = p_organization_id and o.created_by = auth.uid()
  ) then
    raise exception 'No autorizado para ver el estado de credenciales de esta organizaci√≥n';
  end if;

  return query
  select
    exists(select 1 from public.organization_meta_credentials omc where omc.organization_id = p_organization_id) as has_credentials,
    (select omc2.updated_at from public.organization_meta_credentials omc2 where omc2.organization_id = p_organization_id limit 1) as updated_at;
end;
$$;
</file>

<file path="supabase/migrations/20250820221757_54167868-ccdf-4af3-9d35-852f4f924609.sql">
-- Step 1: Create private token tables with strong RLS policies

-- Create organization_instagram_tokens table (private token storage)
CREATE TABLE public.organization_instagram_tokens (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  organization_id UUID NOT NULL UNIQUE REFERENCES public.organizations(id) ON DELETE CASCADE,
  access_token TEXT NOT NULL,
  token_expiry TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create ambassador_tokens table (private token storage) 
CREATE TABLE public.ambassador_tokens (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  embassador_id UUID NOT NULL UNIQUE REFERENCES public.embassadors(id) ON DELETE CASCADE,
  access_token TEXT NOT NULL,
  token_expiry TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable RLS on both tables but DO NOT add any client policies
-- This makes them accessible ONLY by Edge Functions with service_role
ALTER TABLE public.organization_instagram_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ambassador_tokens ENABLE ROW LEVEL SECURITY;

-- Revoke ALL permissions from anon and authenticated users
REVOKE ALL ON TABLE public.organization_instagram_tokens FROM anon, authenticated;
REVOKE ALL ON TABLE public.ambassador_tokens FROM anon, authenticated;

-- Create update triggers for updated_at
CREATE OR REPLACE FUNCTION public.update_organization_instagram_tokens_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public';

CREATE OR REPLACE FUNCTION public.update_ambassador_tokens_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public';

CREATE TRIGGER update_organization_instagram_tokens_updated_at
  BEFORE UPDATE ON public.organization_instagram_tokens
  FOR EACH ROW
  EXECUTE FUNCTION public.update_organization_instagram_tokens_updated_at();

CREATE TRIGGER update_ambassador_tokens_updated_at
  BEFORE UPDATE ON public.ambassador_tokens
  FOR EACH ROW
  EXECUTE FUNCTION public.update_ambassador_tokens_updated_at();

-- Migrate existing token data from organizations table
INSERT INTO public.organization_instagram_tokens (organization_id, access_token, token_expiry)
SELECT id, meta_token, token_expiry 
FROM public.organizations 
WHERE meta_token IS NOT NULL;

-- Migrate existing token data from embassadors table
INSERT INTO public.ambassador_tokens (embassador_id, access_token, token_expiry)
SELECT id, instagram_access_token, token_expires_at 
FROM public.embassadors 
WHERE instagram_access_token IS NOT NULL;

-- Step 2: OAuth state hardening - add unique constraint
CREATE UNIQUE INDEX IF NOT EXISTS idx_oauth_states_state_unique ON public.oauth_states(state);

-- Step 3: Update existing SECURITY DEFINER functions to include search_path
-- (Most already have it, but let's ensure consistency)

-- Update get_safe_organization_data to completely hide token fields
CREATE OR REPLACE FUNCTION public.get_safe_organization_data(user_id uuid)
 RETURNS TABLE(id uuid, name text, description text, timezone text, logo_url text, plan_type text, instagram_username text, facebook_page_id text, instagram_business_account_id text, instagram_user_id text, last_instagram_sync timestamp with time zone, created_by uuid, created_at timestamp with time zone, meta_token text, token_expiry timestamp with time zone)
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT 
    o.id,
    o.name,
    o.description,
    o.timezone,
    o.logo_url,
    o.plan_type,
    o.instagram_username,
    o.facebook_page_id,
    o.instagram_business_account_id,
    o.instagram_user_id,
    o.last_instagram_sync,
    o.created_by,
    o.created_at,
    -- ALWAYS return NULL for token fields - tokens are now in private tables
    NULL::text as meta_token,
    NULL::timestamp with time zone as token_expiry
  FROM public.organizations o
  WHERE o.created_by = user_id;
$function$;

-- Update get_safe_ambassador_data to completely hide token fields
CREATE OR REPLACE FUNCTION public.get_safe_ambassador_data(user_organization_ids uuid[])
 RETURNS TABLE(id uuid, first_name text, last_name text, email text, instagram_user text, instagram_user_id text, follower_count integer, profile_picture_url text, date_of_birth date, rut text, global_points integer, global_category text, performance_status text, events_participated integer, completed_tasks integer, failed_tasks integer, organization_id uuid, created_by_user_id uuid, status text, profile_public boolean, last_instagram_sync timestamp with time zone, created_at timestamp with time zone, instagram_access_token text, token_expires_at timestamp with time zone)
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT 
    e.id,
    e.first_name,
    e.last_name,
    e.email,
    e.instagram_user,
    e.instagram_user_id,
    e.follower_count,
    e.profile_picture_url,
    e.date_of_birth,
    e.rut,
    e.global_points,
    e.global_category,
    e.performance_status,
    e.events_participated,
    e.completed_tasks,
    e.failed_tasks,
    e.organization_id,
    e.created_by_user_id,
    e.status,
    e.profile_public,
    e.last_instagram_sync,
    e.created_at,
    -- ALWAYS return NULL for token fields - tokens are now in private tables
    NULL::text as instagram_access_token,
    NULL::timestamp with time zone as token_expires_at
  FROM public.embassadors e
  WHERE e.organization_id = ANY(user_organization_ids);
$function$;

-- Create function to securely get organization token status (for Edge Functions only)
CREATE OR REPLACE FUNCTION public.get_organization_token_info(org_id uuid)
 RETURNS TABLE(access_token text, token_expiry timestamp with time zone, is_expired boolean)
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT 
    oit.access_token,
    oit.token_expiry,
    (oit.token_expiry IS NOT NULL AND oit.token_expiry < now()) as is_expired
  FROM public.organization_instagram_tokens oit
  WHERE oit.organization_id = org_id;
$function$;

-- Create function to securely get ambassador token info (for Edge Functions only)
CREATE OR REPLACE FUNCTION public.get_ambassador_token_info(ambassador_id uuid)
 RETURNS TABLE(access_token text, token_expiry timestamp with time zone, is_expired boolean)
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT 
    at.access_token,
    at.token_expiry,
    (at.token_expiry IS NOT NULL AND at.token_expiry < now()) as is_expired
  FROM public.ambassador_tokens at
  WHERE at.embassador_id = ambassador_id;
$function$;
</file>

<file path="supabase/migrations/20250820222419_b0aa158b-aeae-4e7a-a23f-93fbb48228fa.sql">
-- Fix remaining function search path issues
CREATE OR REPLACE FUNCTION public.cleanup_expired_oauth_states()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  DELETE FROM public.oauth_states WHERE expires_at < now();
END;
$function$;

-- Create OAuth cleanup job (if pg_cron is available)
-- This will run every 15 minutes to clean up expired OAuth states
DO $$
BEGIN
  -- Try to create the cron job, but don't fail if pg_cron is not available
  BEGIN
    PERFORM cron.schedule(
      'cleanup-oauth-states',
      '*/15 * * * *', -- every 15 minutes
      'SELECT public.cleanup_expired_oauth_states();'
    );
    RAISE NOTICE 'OAuth cleanup cron job created successfully';
  EXCEPTION
    WHEN undefined_function THEN
      RAISE NOTICE 'pg_cron extension not available, OAuth cleanup job not created';
    WHEN OTHERS THEN
      RAISE NOTICE 'Failed to create OAuth cleanup job: %', SQLERRM;
  END;
END;
$$;
</file>

<file path="supabase/migrations/20250821155827_62f27a8a-a0fd-4b06-9afc-41a70479ad3d.sql">
-- Create social_mentions table to store all mentions/tags from Instagram
CREATE TABLE public.social_mentions (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  organization_id UUID NOT NULL,
  instagram_user_id TEXT,
  instagram_username TEXT,
  content TEXT,
  mention_type TEXT NOT NULL CHECK (mention_type IN ('mention', 'hashtag', 'story', 'comment')),
  instagram_media_id TEXT,
  instagram_story_id TEXT,
  story_url TEXT,
  hashtag TEXT,
  reach_count INTEGER DEFAULT 0,
  engagement_score DOUBLE PRECISION DEFAULT 0,
  platform TEXT DEFAULT 'instagram',
  raw_data JSONB,
  processed BOOLEAN DEFAULT false,
  matched_ambassador_id UUID,
  matched_event_id UUID,
  matched_fiesta_id UUID,
  created_task_id UUID,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  processed_at TIMESTAMP WITH TIME ZONE,
  CONSTRAINT fk_social_mentions_organization FOREIGN KEY (organization_id) REFERENCES organizations(id) ON DELETE CASCADE,
  CONSTRAINT fk_social_mentions_ambassador FOREIGN KEY (matched_ambassador_id) REFERENCES embassadors(id) ON DELETE SET NULL,
  CONSTRAINT fk_social_mentions_event FOREIGN KEY (matched_event_id) REFERENCES events(id) ON DELETE SET NULL,
  CONSTRAINT fk_social_mentions_fiesta FOREIGN KEY (matched_fiesta_id) REFERENCES fiestas(id) ON DELETE SET NULL,
  CONSTRAINT fk_social_mentions_task FOREIGN KEY (created_task_id) REFERENCES tasks(id) ON DELETE SET NULL
);

-- Create ambassador_requests table for potential ambassadors detected from mentions
CREATE TABLE public.ambassador_requests (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  organization_id UUID NOT NULL,
  instagram_user_id TEXT,
  instagram_username TEXT NOT NULL,
  follower_count INTEGER DEFAULT 0,
  profile_picture_url TEXT,
  bio TEXT,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
  source_mention_ids UUID[] DEFAULT '{}',
  total_mentions INTEGER DEFAULT 1,
  last_mention_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  processed_at TIMESTAMP WITH TIME ZONE,
  processed_by_user_id UUID,
  rejection_reason TEXT,
  notes TEXT,
  CONSTRAINT fk_ambassador_requests_organization FOREIGN KEY (organization_id) REFERENCES organizations(id) ON DELETE CASCADE,
  CONSTRAINT unique_org_instagram_user UNIQUE (organization_id, instagram_username)
);

-- Add instagram_handle to fiestas table
ALTER TABLE public.fiestas 
ADD COLUMN instagram_handle TEXT;

-- Create indexes for better performance
CREATE INDEX idx_social_mentions_org_created ON public.social_mentions (organization_id, created_at DESC);
CREATE INDEX idx_social_mentions_instagram_user ON public.social_mentions (instagram_user_id);
CREATE INDEX idx_social_mentions_type_processed ON public.social_mentions (mention_type, processed);
CREATE INDEX idx_social_mentions_hashtag ON public.social_mentions (hashtag) WHERE hashtag IS NOT NULL;
CREATE INDEX idx_ambassador_requests_org_status ON public.ambassador_requests (organization_id, status);
CREATE INDEX idx_ambassador_requests_instagram_user ON public.ambassador_requests (instagram_username);
CREATE INDEX idx_fiestas_instagram_handle ON public.fiestas (instagram_handle) WHERE instagram_handle IS NOT NULL;

-- Enable RLS on new tables
ALTER TABLE public.social_mentions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ambassador_requests ENABLE ROW LEVEL SECURITY;

-- RLS policies for social_mentions
CREATE POLICY "Users can view own organization social mentions" 
ON public.social_mentions 
FOR SELECT 
USING (organization_id IN (
  SELECT id FROM organizations WHERE created_by = auth.uid()
));

CREATE POLICY "Users can update own organization social mentions" 
ON public.social_mentions 
FOR UPDATE 
USING (organization_id IN (
  SELECT id FROM organizations WHERE created_by = auth.uid()
));

-- RLS policies for ambassador_requests
CREATE POLICY "Users can view own organization ambassador requests" 
ON public.ambassador_requests 
FOR SELECT 
USING (organization_id IN (
  SELECT id FROM organizations WHERE created_by = auth.uid()
));

CREATE POLICY "Users can update own organization ambassador requests" 
ON public.ambassador_requests 
FOR UPDATE 
USING (organization_id IN (
  SELECT id FROM organizations WHERE created_by = auth.uid()
));

-- Create function to automatically update ambassador_requests when social_mentions are added
CREATE OR REPLACE FUNCTION public.handle_social_mention_ambassador_request()
RETURNS TRIGGER AS $$
BEGIN
  -- Only process if this is an unmatched mention (no ambassador found)
  IF NEW.matched_ambassador_id IS NULL AND NEW.instagram_username IS NOT NULL THEN
    -- Insert or update ambassador request
    INSERT INTO public.ambassador_requests (
      organization_id,
      instagram_user_id,
      instagram_username,
      source_mention_ids,
      total_mentions,
      last_mention_at
    )
    VALUES (
      NEW.organization_id,
      NEW.instagram_user_id,
      NEW.instagram_username,
      ARRAY[NEW.id],
      1,
      NEW.created_at
    )
    ON CONFLICT (organization_id, instagram_username)
    DO UPDATE SET
      source_mention_ids = ambassador_requests.source_mention_ids || NEW.id,
      total_mentions = ambassador_requests.total_mentions + 1,
      last_mention_at = NEW.created_at;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for the function
CREATE TRIGGER trigger_social_mention_ambassador_request
  AFTER INSERT ON public.social_mentions
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_social_mention_ambassador_request();
</file>

<file path="supabase/migrations/20250821155854_df5fb83c-53a1-4458-8dbf-615ffaa26290.sql">
-- Fix RLS policies - Add missing INSERT and DELETE policies for social_mentions
CREATE POLICY "Service role can insert social mentions" 
ON public.social_mentions 
FOR INSERT 
TO service_role
WITH CHECK (true);

CREATE POLICY "Users can delete own organization social mentions" 
ON public.social_mentions 
FOR DELETE 
USING (organization_id IN (
  SELECT id FROM organizations WHERE created_by = auth.uid()
));

-- Fix RLS policies - Add missing INSERT and DELETE policies for ambassador_requests  
CREATE POLICY "Service role can insert ambassador requests" 
ON public.ambassador_requests 
FOR INSERT 
TO service_role
WITH CHECK (true);

CREATE POLICY "Users can delete own organization ambassador requests" 
ON public.ambassador_requests 
FOR DELETE 
USING (organization_id IN (
  SELECT id FROM organizations WHERE created_by = auth.uid()
));

-- Fix RLS policies for organization_instagram_tokens (missing policies)
CREATE POLICY "Users can view own organization instagram tokens" 
ON public.organization_instagram_tokens 
FOR SELECT 
USING (organization_id IN (
  SELECT id FROM organizations WHERE created_by = auth.uid()
));

CREATE POLICY "Service role can manage instagram tokens" 
ON public.organization_instagram_tokens 
FOR ALL 
TO service_role
USING (true)
WITH CHECK (true);

-- Fix RLS policies for organization_meta_credentials (missing policies)
CREATE POLICY "Users can view own organization meta credentials" 
ON public.organization_meta_credentials 
FOR SELECT 
USING (organization_id IN (
  SELECT id FROM organizations WHERE created_by = auth.uid()
));

CREATE POLICY "Service role can manage meta credentials" 
ON public.organization_meta_credentials 
FOR ALL 
TO service_role
USING (true)
WITH CHECK (true);

-- Fix RLS policies for ambassador_tokens (missing policies)
CREATE POLICY "Service role can manage ambassador tokens" 
ON public.ambassador_tokens 
FOR ALL 
TO service_role
USING (true)
WITH CHECK (true);

-- Fix function search path issues
CREATE OR REPLACE FUNCTION public.handle_social_mention_ambassador_request()
RETURNS TRIGGER AS $$
BEGIN
  -- Only process if this is an unmatched mention (no ambassador found)
  IF NEW.matched_ambassador_id IS NULL AND NEW.instagram_username IS NOT NULL THEN
    -- Insert or update ambassador request
    INSERT INTO public.ambassador_requests (
      organization_id,
      instagram_user_id,
      instagram_username,
      source_mention_ids,
      total_mentions,
      last_mention_at
    )
    VALUES (
      NEW.organization_id,
      NEW.instagram_user_id,
      NEW.instagram_username,
      ARRAY[NEW.id],
      1,
      NEW.created_at
    )
    ON CONFLICT (organization_id, instagram_username)
    DO UPDATE SET
      source_mention_ids = ambassador_requests.source_mention_ids || NEW.id,
      total_mentions = ambassador_requests.total_mentions + 1,
      last_mention_at = NEW.created_at;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;
</file>

<file path="supabase/migrations/20250821162427_00f91255-07e4-4d4d-9f76-8e9d17b10fd3.sql">
-- 1) Extensiones necesarias (idempotentes)
create extension if not exists pg_net with schema extensions;
create extension if not exists pg_cron with schema extensions;

-- 2) Realtime robusto (old/new)
alter table public.social_mentions replica identity full;
alter table public.ambassador_requests replica identity full;

-- A√±adir tablas a la publicaci√≥n realtime (puede fallar si ya est√°n a√±adidas; si es as√≠, ignora ese error)
alter publication supabase_realtime add table public.social_mentions;
alter publication supabase_realtime add table public.ambassador_requests;

-- 3) Cron cada 5 minutos para instagram-sync
-- Nota: Inicialmente llamar√° con el ANON key; en el siguiente paso har√© la funci√≥n p√∫blica (verify_jwt = false)
-- para que la llamada del cron funcione sin usuario.
-- Evitar duplicados si ya existe un job con el mismo nombre
do $$
begin
  if exists (select 1 from cron.job where jobname = 'instagram_sync_every_5_min') then
    perform cron.unschedule('instagram_sync_every_5_min');
  end if;

  perform cron.schedule(
    'instagram_sync_every_5_min',
    '*/5 * * * *',
    $sql$
    select
      net.http_post(
        url    := 'https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-sync',
        headers:= '{
          "Content-Type": "application/json",
          "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF3cGZzbGNlcHlsbmlwYW9sbXZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3NTUzOTUsImV4cCI6MjA2OTMzMTM5NX0.KyXrezLFMXhsOr3zyrNm1nb1T3w6C6R3WdJZ2w21oOY"
        }'::jsonb,
        body   := '{"source":"cron","cron":true}'::jsonb
      );
    $sql$
  );
end$$;
</file>

<file path="supabase/migrations/20250821163219_4a7fe2ac-937d-4e0c-8a68-beaff97042db.sql">
-- Enable REPLICA IDENTITY FULL for real-time updates
ALTER TABLE public.social_mentions REPLICA IDENTITY FULL;
ALTER TABLE public.ambassador_requests REPLICA IDENTITY FULL;
</file>

<file path="supabase/migrations/20250821163803_e74a7d6e-edef-4bc4-9107-b3fae0a09f23.sql">
-- Fix social_mentions mention_type constraint to allow 'tag'
ALTER TABLE public.social_mentions 
DROP CONSTRAINT IF EXISTS social_mentions_mention_type_check;

ALTER TABLE public.social_mentions 
ADD CONSTRAINT social_mentions_mention_type_check 
CHECK (mention_type IN ('mention', 'tag', 'hashtag', 'story', 'comment'));
</file>

<file path="supabase/migrations/20250821164618_437eb3bf-e90c-49ac-9bdb-9e73bef65e62.sql">
-- Security Fix 1: Prevent privilege escalation in users table
-- Add trigger to prevent users from changing their role to admin
CREATE TRIGGER prevent_user_role_escalation
  BEFORE INSERT OR UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION public.prevent_user_privilege_escalation();

-- Security Fix 2: Remove client SELECT access to Instagram tokens
-- This prevents potential token leakage to client applications
DROP POLICY IF EXISTS "Users can view own organization instagram tokens" ON public.organization_instagram_tokens;

-- Security Fix 3: Fix function search paths for security
-- Update existing functions to use secure search path
CREATE OR REPLACE FUNCTION public.prevent_role_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path = 'public'
AS $function$
BEGIN
  -- Allow service_role to change roles (for admin flows/edge functions).
  IF current_user = 'service_role' THEN
    RETURN NEW;
  END IF;

  -- Block role changes by regular clients.
  IF NEW.role IS DISTINCT FROM OLD.role THEN
    RAISE EXCEPTION 'Changing role is not allowed';
  END IF;

  RETURN NEW;
END;
$function$;

CREATE OR REPLACE FUNCTION public.handle_social_mention_ambassador_request()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path = 'public'
AS $function$
BEGIN
  -- Only process if this is an unmatched mention (no ambassador found)
  IF NEW.matched_ambassador_id IS NULL AND NEW.instagram_username IS NOT NULL THEN
    -- Insert or update ambassador request
    INSERT INTO public.ambassador_requests (
      organization_id,
      instagram_user_id,
      instagram_username,
      source_mention_ids,
      total_mentions,
      last_mention_at
    )
    VALUES (
      NEW.organization_id,
      NEW.instagram_user_id,
      NEW.instagram_username,
      ARRAY[NEW.id],
      1,
      NEW.created_at
    )
    ON CONFLICT (organization_id, instagram_username)
    DO UPDATE SET
      source_mention_ids = ambassador_requests.source_mention_ids || NEW.id,
      total_mentions = ambassador_requests.total_mentions + 1,
      last_mention_at = NEW.created_at;
  END IF;
  
  RETURN NEW;
END;
$function$;

CREATE OR REPLACE FUNCTION public.get_safe_organization_data(user_id uuid)
 RETURNS TABLE(id uuid, name text, description text, timezone text, logo_url text, plan_type text, instagram_username text, facebook_page_id text, instagram_business_account_id text, instagram_user_id text, last_instagram_sync timestamp with time zone, created_by uuid, created_at timestamp with time zone, meta_token text, token_expiry timestamp with time zone)
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path = 'public'
AS $function$
  SELECT 
    o.id,
    o.name,
    o.description,
    o.timezone,
    o.logo_url,
    o.plan_type,
    o.instagram_username,
    o.facebook_page_id,
    o.instagram_business_account_id,
    o.instagram_user_id,
    o.last_instagram_sync,
    o.created_by,
    o.created_at,
    -- ALWAYS return NULL for token fields - tokens are now in private tables
    NULL::text as meta_token,
    NULL::timestamp with time zone as token_expiry
  FROM public.organizations o
  WHERE o.created_by = user_id;
$function$;

CREATE OR REPLACE FUNCTION public.get_safe_ambassador_data(user_organization_ids uuid[])
 RETURNS TABLE(id uuid, first_name text, last_name text, email text, instagram_user text, instagram_user_id text, follower_count integer, profile_picture_url text, date_of_birth date, rut text, global_points integer, global_category text, performance_status text, events_participated integer, completed_tasks integer, failed_tasks integer, organization_id uuid, created_by_user_id uuid, status text, profile_public boolean, last_instagram_sync timestamp with time zone, created_at timestamp with time zone, instagram_access_token text, token_expires_at timestamp with time zone)
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path = 'public'
AS $function$
  SELECT 
    e.id,
    e.first_name,
    e.last_name,
    e.email,
    e.instagram_user,
    e.instagram_user_id,
    e.follower_count,
    e.profile_picture_url,
    e.date_of_birth,
    e.rut,
    e.global_points,
    e.global_category,
    e.performance_status,
    e.events_participated,
    e.completed_tasks,
    e.failed_tasks,
    e.organization_id,
    e.created_by_user_id,
    e.status,
    e.profile_public,
    e.last_instagram_sync,
    e.created_at,
    -- ALWAYS return NULL for token fields - tokens are now in private tables
    NULL::text as instagram_access_token,
    NULL::timestamp with time zone as token_expires_at
  FROM public.embassadors e
  WHERE e.organization_id = ANY(user_organization_ids);
$function$;
</file>

<file path="supabase/migrations/20250821230621_1cdadd8a-a24a-47bd-afde-371a2d6d6a9a.sql">
-- Add fields to social_mentions table for story mentions and idempotency
ALTER TABLE public.social_mentions
ADD COLUMN IF NOT EXISTS external_event_id TEXT,
ADD COLUMN IF NOT EXISTS recipient_page_id TEXT;

-- Create partial unique index for idempotency (only for non-null external_event_id)
CREATE UNIQUE INDEX IF NOT EXISTS idx_social_mentions_external_event_id 
ON public.social_mentions (external_event_id, organization_id) 
WHERE external_event_id IS NOT NULL;

-- Create index for recipient_page_id for faster lookups
CREATE INDEX IF NOT EXISTS idx_social_mentions_recipient_page_id 
ON public.social_mentions (recipient_page_id);
</file>

<file path="supabase/migrations/20250821232048_8a423d55-54b5-4c0d-9144-49e6c2e969b6.sql">
-- Idempotencia para menciones desde historias (DM referrals)
CREATE UNIQUE INDEX IF NOT EXISTS ux_social_mentions_story_referral_external_event
ON public.social_mentions (organization_id, external_event_id)
WHERE mention_type = 'story_referral';
</file>

<file path="supabase/migrations/20250821233305_54e25c5b-59f7-48a5-b41b-fa4898c8691a.sql">
-- 1) Nuevas columnas para gestionar 24h, estados y deep links
ALTER TABLE public.social_mentions
  ADD COLUMN IF NOT EXISTS mentioned_at timestamptz NOT NULL DEFAULT now(),
  ADD COLUMN IF NOT EXISTS expires_at timestamptz,
  ADD COLUMN IF NOT EXISTS state text NOT NULL DEFAULT 'new',
  ADD COLUMN IF NOT EXISTS deep_link text;

-- Opcional: validar valores de estado (est√°tico, no dependiente de tiempo)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'social_mentions_state_chk'
  ) THEN
    ALTER TABLE public.social_mentions
      ADD CONSTRAINT social_mentions_state_chk
      CHECK (state IN ('new','flagged_early_delete','completed','expired_unknown'));
  END IF;
END$$;

-- 2) Idempotencia adicional cuando no haya external_event_id
CREATE UNIQUE INDEX IF NOT EXISTS ux_social_mentions_story_referral_user_ts
ON public.social_mentions (organization_id, instagram_user_id, mentioned_at)
WHERE mention_type = 'story_referral';

-- 3) √çndices para el worker
CREATE INDEX IF NOT EXISTS idx_social_mentions_story_referral_expires_at
ON public.social_mentions (expires_at)
WHERE mention_type = 'story_referral' AND state = 'new';

CREATE INDEX IF NOT EXISTS idx_social_mentions_story_referral_state
ON public.social_mentions (state)
WHERE mention_type = 'story_referral';

-- 4) Trigger para setear expires_at = mentioned_at + 24h
CREATE OR REPLACE FUNCTION public.set_social_mention_expiry()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
BEGIN
  IF NEW.expires_at IS NULL THEN
    NEW.expires_at := NEW.mentioned_at + interval '24 hours';
  END IF;
  RETURN NEW;
END;
$function$;

DROP TRIGGER IF EXISTS trg_set_social_mention_expiry ON public.social_mentions;
CREATE TRIGGER trg_set_social_mention_expiry
BEFORE INSERT ON public.social_mentions
FOR EACH ROW
EXECUTE PROCEDURE public.set_social_mention_expiry();

-- 5) Trigger para crear/actualizar Solicitud de Embajador a partir de menciones no emparejadas
-- La funci√≥n public.handle_social_mention_ambassador_request() ya existe
DROP TRIGGER IF EXISTS trg_handle_social_mention_ambassador_request ON public.social_mentions;
CREATE TRIGGER trg_handle_social_mention_ambassador_request
AFTER INSERT ON public.social_mentions
FOR EACH ROW
EXECUTE PROCEDURE public.handle_social_mention_ambassador_request();
</file>

<file path="supabase/migrations/20250822171203_e481d447-2aa6-491e-96a9-7f589ee9c90f.sql">
-- 1) Lock down RPCs that expose access tokens
REVOKE EXECUTE ON FUNCTION public.get_organization_token_info(uuid) FROM PUBLIC, anon, authenticated;
REVOKE EXECUTE ON FUNCTION public.get_ambassador_token_info(uuid) FROM PUBLIC, anon, authenticated;

-- Allow only service_role to execute these (Edge Functions).
GRANT EXECUTE ON FUNCTION public.get_organization_token_info(uuid) TO service_role;
GRANT EXECUTE ON FUNCTION public.get_ambassador_token_info(uuid) TO service_role;

-- 2) Column-level privilege hardening for sensitive tokens
-- Organizations: block clients from reading token columns; allow only service_role.
REVOKE SELECT (meta_token, token_expiry) ON TABLE public.organizations FROM PUBLIC, anon, authenticated;
GRANT SELECT (meta_token, token_expiry) ON TABLE public.organizations TO service_role;

-- Embassadors: block clients from reading token columns; allow only service_role.
REVOKE SELECT (instagram_access_token, token_expires_at) ON TABLE public.embassadors FROM PUBLIC, anon, authenticated;
GRANT SELECT (instagram_access_token, token_expires_at) ON TABLE public.embassadors TO service_role;

-- If you want maximum hardening, also prevent client-side updates to these columns (optional):
-- REVOKE UPDATE (meta_token, token_expiry) ON TABLE public.organizations FROM PUBLIC, anon, authenticated;
-- GRANT UPDATE (meta_token, token_expiry) ON TABLE public.organizations TO service_role;
-- REVOKE UPDATE (instagram_access_token, token_expires_at) ON TABLE public.embassadors FROM PUBLIC, anon, authenticated;
-- GRANT UPDATE (instagram_access_token, token_expires_at) ON TABLE public.embassadors TO service_role;

-- 3) Remove direct SELECT on Meta App credentials to prevent leaking secrets
DROP POLICY IF EXISTS "Users can view own organization meta credentials" ON public.organization_meta_credentials;

-- Note: Keep existing policy "Service role can manage meta credentials".
-- Clients can still use the safe RPCs:
--  - get_org_meta_credentials_status (status only)
--  - upsert_org_meta_credentials (SECURITY DEFINER with ownership checks)
</file>

<file path="supabase/migrations/20250825201738_4ca79031-76eb-497e-ab51-adf47af569cb.sql">
-- Add columns for story mention verification tracking
ALTER TABLE public.social_mentions 
ADD COLUMN IF NOT EXISTS checks_count integer DEFAULT 0,
ADD COLUMN IF NOT EXISTS last_check_at timestamp with time zone;

-- Create indexes for efficient queries
CREATE INDEX IF NOT EXISTS idx_social_mentions_org_type_state 
ON public.social_mentions (organization_id, mention_type, state);

CREATE INDEX IF NOT EXISTS idx_social_mentions_org_type_mentioned_at 
ON public.social_mentions (organization_id, mention_type, mentioned_at DESC);

-- Create index for story verification queries
CREATE INDEX IF NOT EXISTS idx_social_mentions_verification 
ON public.social_mentions (mention_type, state, checks_count, mentioned_at)
WHERE mention_type = 'story_referral';

-- Schedule story mentions verification job to run every hour
SELECT cron.schedule(
  'verify-story-mentions',
  '0 * * * *', -- Every hour at minute 0
  $$
  SELECT
    net.http_post(
        url:='https://awpfslcepylnipaolmvv.supabase.co/functions/v1/story-mentions-state-worker',
        headers:='{"Content-Type": "application/json", "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF3cGZzbGNlcHlsbmlwYW9sbXZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3NTUzOTUsImV4cCI6MjA2OTMzMTM5NX0.KyXrezLFMXhsOr3zyrNm1nb1T3w6C6R3WdJZ2w21oOY", "X-Cron-Secret": "' || current_setting('app.settings.cron_secret', true) || '"}'::jsonb,
        body:='{"source": "cron", "type": "verification"}'::jsonb
    ) as request_id;
  $$
);

-- Add settings for story mentions feature in organization_settings
UPDATE public.organization_settings 
SET instagram_settings = instagram_settings || '{"story_mentions_enabled": true, "story_verification_intervals": [60, 720, 1380]}'::jsonb
WHERE instagram_settings IS NOT NULL;

-- Insert default settings for organizations without settings
INSERT INTO public.organization_settings (organization_id, instagram_settings)
SELECT o.id, '{"auto_sync": true, "sync_interval": "hourly", "auto_validate_tasks": false, "story_validation_24h": true, "story_mentions_enabled": true, "story_verification_intervals": [60, 720, 1380]}'::jsonb
FROM public.organizations o
WHERE NOT EXISTS (
  SELECT 1 FROM public.organization_settings os WHERE os.organization_id = o.id
);
</file>

<file path="supabase/migrations/20250825202621_76de8da2-accd-4534-a274-206358f25bb3.sql">
-- Phase 1: User Onboarding System & Phase 2: Multi-User Support

-- Create organization_members table for multi-user support
CREATE TABLE public.organization_members (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  organization_id uuid NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'member',
  joined_at timestamp with time zone NOT NULL DEFAULT now(),
  invited_by uuid REFERENCES auth.users(id),
  status text NOT NULL DEFAULT 'active',
  permissions jsonb DEFAULT '{"manage_ambassadors": true, "manage_events": true, "manage_instagram": false, "view_analytics": true}'::jsonb,
  UNIQUE(organization_id, user_id)
);

-- Enable RLS on organization_members
ALTER TABLE public.organization_members ENABLE ROW LEVEL SECURITY;

-- Create policies for organization_members
CREATE POLICY "Users can view memberships for their organizations" 
ON public.organization_members 
FOR SELECT 
USING (
  organization_id IN (
    SELECT id FROM public.organizations WHERE created_by = auth.uid()
  ) OR user_id = auth.uid()
);

CREATE POLICY "Org owners can manage memberships" 
ON public.organization_members 
FOR ALL 
USING (
  organization_id IN (
    SELECT id FROM public.organizations WHERE created_by = auth.uid()
  )
);

-- Function to check if user is member of organization
CREATE OR REPLACE FUNCTION public.is_organization_member(user_auth_id uuid, org_id uuid)
RETURNS boolean
LANGUAGE sql
STABLE SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.organization_members om
    WHERE om.user_id = user_auth_id 
    AND om.organization_id = org_id 
    AND om.status = 'active'
  ) OR EXISTS (
    SELECT 1 FROM public.organizations o
    WHERE o.id = org_id 
    AND o.created_by = user_auth_id
  );
$$;

-- Function to get user's accessible organizations
CREATE OR REPLACE FUNCTION public.get_user_organizations(user_auth_id uuid)
RETURNS TABLE(organization_id uuid, role text, is_owner boolean)
LANGUAGE sql
STABLE SECURITY DEFINER
SET search_path = public
AS $$
  -- Organizations owned by user
  SELECT o.id, 'owner'::text, true
  FROM public.organizations o
  WHERE o.created_by = user_auth_id
  
  UNION
  
  -- Organizations where user is member
  SELECT om.organization_id, om.role, false
  FROM public.organization_members om
  WHERE om.user_id = user_auth_id 
  AND om.status = 'active';
$$;

-- Trigger to automatically add owner as member when organization is created
CREATE OR REPLACE FUNCTION public.add_owner_as_member()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.organization_members (organization_id, user_id, role, status, permissions)
  VALUES (
    NEW.id, 
    NEW.created_by, 
    'owner', 
    'active',
    '{"manage_ambassadors": true, "manage_events": true, "manage_instagram": true, "view_analytics": true, "manage_members": true}'::jsonb
  );
  RETURN NEW;
END;
$$;

CREATE TRIGGER on_organization_created
AFTER INSERT ON public.organizations
FOR EACH ROW EXECUTE FUNCTION public.add_owner_as_member();

-- Function to handle new user registration (creates user profile automatically)
CREATE OR REPLACE FUNCTION public.handle_new_auth_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Only create if user doesn't already exist in public.users
  IF NOT EXISTS (SELECT 1 FROM public.users WHERE auth_user_id = NEW.id) THEN
    INSERT INTO public.users (
      auth_user_id,
      email,
      name,
      role
    ) VALUES (
      NEW.id,
      NEW.email,
      COALESCE(NEW.raw_user_meta_data->>'name', NEW.email),
      'user'
    );
  END IF;
  RETURN NEW;
END;
$$;

-- Create trigger on auth.users for automatic profile creation
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_auth_user();

-- Update RLS policies to use membership instead of created_by

-- Update embassadors policies
DROP POLICY IF EXISTS "Users can view own organization embassadors" ON public.embassadors;
DROP POLICY IF EXISTS "Users can create embassadors for own organization" ON public.embassadors;
DROP POLICY IF EXISTS "Users can update own organization embassadors" ON public.embassadors;

CREATE POLICY "Members can view organization embassadors" 
ON public.embassadors 
FOR SELECT 
USING (public.is_organization_member(auth.uid(), organization_id));

CREATE POLICY "Members can create embassadors for organization" 
ON public.embassadors 
FOR INSERT 
WITH CHECK (public.is_organization_member(auth.uid(), organization_id));

CREATE POLICY "Members can update organization embassadors" 
ON public.embassadors 
FOR UPDATE 
USING (public.is_organization_member(auth.uid(), organization_id));

-- Update fiestas policies
DROP POLICY IF EXISTS "Users can view own organization fiestas" ON public.fiestas;
DROP POLICY IF EXISTS "Users can create fiestas for own organization" ON public.fiestas;
DROP POLICY IF EXISTS "Users can update own organization fiestas" ON public.fiestas;

CREATE POLICY "Members can view organization fiestas" 
ON public.fiestas 
FOR SELECT 
USING (public.is_organization_member(auth.uid(), organization_id));

CREATE POLICY "Members can create fiestas for organization" 
ON public.fiestas 
FOR INSERT 
WITH CHECK (public.is_organization_member(auth.uid(), organization_id));

CREATE POLICY "Members can update organization fiestas" 
ON public.fiestas 
FOR UPDATE 
USING (public.is_organization_member(auth.uid(), organization_id));

-- Update events policies to use membership through fiestas
DROP POLICY IF EXISTS "Users can view events from own organization fiestas" ON public.events;
DROP POLICY IF EXISTS "Users can create events for own organization fiestas" ON public.events;
DROP POLICY IF EXISTS "Users can update events from own organization fiestas" ON public.events;

CREATE POLICY "Members can view organization events" 
ON public.events 
FOR SELECT 
USING (
  fiesta_id IN (
    SELECT f.id FROM public.fiestas f 
    WHERE public.is_organization_member(auth.uid(), f.organization_id)
  )
);

CREATE POLICY "Members can create events for organization" 
ON public.events 
FOR INSERT 
WITH CHECK (
  fiesta_id IN (
    SELECT f.id FROM public.fiestas f 
    WHERE public.is_organization_member(auth.uid(), f.organization_id)
  )
);

CREATE POLICY "Members can update organization events" 
ON public.events 
FOR UPDATE 
USING (
  fiesta_id IN (
    SELECT f.id FROM public.fiestas f 
    WHERE public.is_organization_member(auth.uid(), f.organization_id)
  )
);

-- Update social_mentions policies
DROP POLICY IF EXISTS "Users can view own organization social mentions" ON public.social_mentions;
DROP POLICY IF EXISTS "Users can update own organization social mentions" ON public.social_mentions;
DROP POLICY IF EXISTS "Users can delete own organization social mentions" ON public.social_mentions;

CREATE POLICY "Members can view organization social mentions" 
ON public.social_mentions 
FOR SELECT 
USING (public.is_organization_member(auth.uid(), organization_id));

CREATE POLICY "Members can update organization social mentions" 
ON public.social_mentions 
FOR UPDATE 
USING (public.is_organization_member(auth.uid(), organization_id));

CREATE POLICY "Members can delete organization social mentions" 
ON public.social_mentions 
FOR DELETE 
USING (public.is_organization_member(auth.uid(), organization_id));

-- Update notifications policies
DROP POLICY IF EXISTS "Users can view own organization notifications" ON public.notifications;
DROP POLICY IF EXISTS "Users can update own organization notifications" ON public.notifications;

CREATE POLICY "Members can view organization notifications" 
ON public.notifications 
FOR SELECT 
USING (public.is_organization_member(auth.uid(), organization_id));

CREATE POLICY "Members can update organization notifications" 
ON public.notifications 
FOR UPDATE 
USING (public.is_organization_member(auth.uid(), organization_id));

-- Update ambassador_requests policies
DROP POLICY IF EXISTS "Users can view own organization ambassador requests" ON public.ambassador_requests;
DROP POLICY IF EXISTS "Users can update own organization ambassador requests" ON public.ambassador_requests;
DROP POLICY IF EXISTS "Users can delete own organization ambassador requests" ON public.ambassador_requests;

CREATE POLICY "Members can view organization ambassador requests" 
ON public.ambassador_requests 
FOR SELECT 
USING (public.is_organization_member(auth.uid(), organization_id));

CREATE POLICY "Members can update organization ambassador requests" 
ON public.ambassador_requests 
FOR UPDATE 
USING (public.is_organization_member(auth.uid(), organization_id));

CREATE POLICY "Members can delete organization ambassador requests" 
ON public.ambassador_requests 
FOR DELETE 
USING (public.is_organization_member(auth.uid(), organization_id));

-- Update organization_settings policies
DROP POLICY IF EXISTS "Users can view own organization settings" ON public.organization_settings;
DROP POLICY IF EXISTS "Users can create settings for own organization" ON public.organization_settings;
DROP POLICY IF EXISTS "Users can update own organization settings" ON public.organization_settings;

CREATE POLICY "Members can view organization settings" 
ON public.organization_settings 
FOR SELECT 
USING (public.is_organization_member(auth.uid(), organization_id));

CREATE POLICY "Members can create organization settings" 
ON public.organization_settings 
FOR INSERT 
WITH CHECK (public.is_organization_member(auth.uid(), organization_id));

CREATE POLICY "Members can update organization settings" 
ON public.organization_settings 
FOR UPDATE 
USING (public.is_organization_member(auth.uid(), organization_id));

-- Update tasks policies to use membership through embassadors
DROP POLICY IF EXISTS "Users can view tasks from own organization" ON public.tasks;
DROP POLICY IF EXISTS "Users can create tasks for own organization" ON public.tasks;
DROP POLICY IF EXISTS "Users can update tasks from own organization" ON public.tasks;

CREATE POLICY "Members can view organization tasks" 
ON public.tasks 
FOR SELECT 
USING (
  embassador_id IN (
    SELECT e.id FROM public.embassadors e 
    WHERE public.is_organization_member(auth.uid(), e.organization_id)
  )
);

CREATE POLICY "Members can create tasks for organization" 
ON public.tasks 
FOR INSERT 
WITH CHECK (
  embassador_id IN (
    SELECT e.id FROM public.embassadors e 
    WHERE public.is_organization_member(auth.uid(), e.organization_id)
  )
);

CREATE POLICY "Members can update organization tasks" 
ON public.tasks 
FOR UPDATE 
USING (
  embassador_id IN (
    SELECT e.id FROM public.embassadors e 
    WHERE public.is_organization_member(auth.uid(), e.organization_id)
  )
);

-- Update leaderboards policies
DROP POLICY IF EXISTS "Users can view own organization leaderboards" ON public.leaderboards;

CREATE POLICY "Members can view organization leaderboards" 
ON public.leaderboards 
FOR SELECT 
USING (
  event_id IN (
    SELECT e.id FROM public.events e
    JOIN public.fiestas f ON e.fiesta_id = f.id
    WHERE public.is_organization_member(auth.uid(), f.organization_id)
  )
);

-- Update task_logs policies
DROP POLICY IF EXISTS "Users can view own organization task logs" ON public.task_logs;

CREATE POLICY "Members can view organization task logs" 
ON public.task_logs 
FOR SELECT 
USING (
  task_id IN (
    SELECT t.id FROM public.tasks t
    JOIN public.embassadors e ON t.embassador_id = e.id
    WHERE public.is_organization_member(auth.uid(), e.organization_id)
  )
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_organization_members_user_id ON public.organization_members(user_id);
CREATE INDEX IF NOT EXISTS idx_organization_members_org_id ON public.organization_members(organization_id);
CREATE INDEX IF NOT EXISTS idx_organization_members_status ON public.organization_members(status);
</file>

<file path="supabase/migrations/20250825205903_a75f4036-91aa-411b-a413-fefe3d83ed92.sql">
-- 1) Restrict access to SECURITY DEFINER functions that can be abused

-- Revoke public access to "safe" functions that accept caller-supplied IDs
REVOKE EXECUTE ON FUNCTION public.get_safe_organization_data(uuid) FROM PUBLIC, anon, authenticated;
REVOKE EXECUTE ON FUNCTION public.get_safe_ambassador_data(uuid[]) FROM PUBLIC, anon, authenticated;

-- Ensure token info functions are only callable by service_role
REVOKE EXECUTE ON FUNCTION public.get_organization_token_info(uuid) FROM PUBLIC, anon, authenticated;
REVOKE EXECUTE ON FUNCTION public.get_ambassador_token_info(uuid) FROM PUBLIC, anon, authenticated;
GRANT EXECUTE ON FUNCTION public.get_organization_token_info(uuid) TO service_role;
GRANT EXECUTE ON FUNCTION public.get_ambassador_token_info(uuid) TO service_role;

-- 2) Enforce role/org integrity on public.users using the existing function
-- Note: prevent_user_privilege_escalation() is already defined in your DB.
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_users_prevent_privilege_escalation'
  ) THEN
    CREATE TRIGGER trg_users_prevent_privilege_escalation
    BEFORE INSERT OR UPDATE ON public.users
    FOR EACH ROW
    EXECUTE FUNCTION public.prevent_user_privilege_escalation();
  END IF;
END
$$;

-- 3) Tighten RLS for organization_settings UPDATE (and INSERT)

-- Remove broad update policy
DROP POLICY IF EXISTS "Members can update organization settings" ON public.organization_settings;

-- Create stricter UPDATE policy:
-- Owners OR members with explicit permission manage_instagram = true
CREATE POLICY "Owners or permitted members can update organization settings"
ON public.organization_settings
FOR UPDATE
USING (
  EXISTS (
    SELECT 1
    FROM public.organizations o
    WHERE o.id = organization_id
      AND o.created_by = auth.uid()
  )
  OR EXISTS (
    SELECT 1
    FROM public.organization_members om
    WHERE om.organization_id = organization_id
      AND om.user_id = auth.uid()
      AND COALESCE((om.permissions->>'manage_instagram')::boolean, false) = true
  )
)
WITH CHECK (
  EXISTS (
    SELECT 1
    FROM public.organizations o
    WHERE o.id = organization_id
      AND o.created_by = auth.uid()
  )
  OR EXISTS (
    SELECT 1
    FROM public.organization_members om
    WHERE om.organization_id = organization_id
      AND om.user_id = auth.uid()
      AND COALESCE((om.permissions->>'manage_instagram')::boolean, false) = true
  )
);

-- Optional but recommended: apply the same restriction for INSERT
DROP POLICY IF EXISTS "Members can create organization settings" ON public.organization_settings;

CREATE POLICY "Owners or permitted members can create organization settings"
ON public.organization_settings
FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1
    FROM public.organizations o
    WHERE o.id = organization_id
      AND o.created_by = auth.uid()
  )
  OR EXISTS (
    SELECT 1
    FROM public.organization_members om
    WHERE om.organization_id = organization_id
      AND om.user_id = auth.uid()
      AND COALESCE((om.permissions->>'manage_instagram')::boolean, false) = true
  )
);
</file>

<file path="supabase/migrations/20250825210748_9cf401f9-abac-44f6-a425-6b1956e3cef7.sql">
-- CRITICAL SECURITY FIX: Secure organization_meta_credentials table
-- Remove overly permissive service role policy and implement secure access patterns

-- 1) Drop the insecure policy that allows unrestricted service role access
DROP POLICY IF EXISTS "Service role can manage meta credentials" ON public.organization_meta_credentials;

-- 2) Create a secure function for edge functions to get organization credentials
-- This function validates organization existence and provides controlled access
CREATE OR REPLACE FUNCTION public.get_organization_credentials_secure(p_organization_id uuid)
RETURNS TABLE(
  meta_app_id text,
  meta_app_secret text,
  webhook_verify_token text
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  -- Validate that the organization exists
  IF NOT EXISTS (
    SELECT 1 FROM public.organizations WHERE id = p_organization_id
  ) THEN
    RAISE EXCEPTION 'Organization not found';
  END IF;

  -- Return credentials only for the specified organization
  RETURN QUERY
  SELECT 
    omc.meta_app_id,
    omc.meta_app_secret,
    omc.webhook_verify_token
  FROM public.organization_meta_credentials omc
  WHERE omc.organization_id = p_organization_id;
END;
$$;

-- 3) Create a function to get credentials by Instagram user ID (for webhooks)
CREATE OR REPLACE FUNCTION public.get_organization_credentials_by_instagram_user(p_instagram_user_id text)
RETURNS TABLE(
  organization_id uuid,
  meta_app_id text,
  meta_app_secret text,
  webhook_verify_token text
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  -- Find organization by Instagram user ID and return its credentials
  RETURN QUERY
  SELECT 
    o.id as organization_id,
    omc.meta_app_id,
    omc.meta_app_secret,
    omc.webhook_verify_token
  FROM public.organizations o
  INNER JOIN public.organization_meta_credentials omc ON o.id = omc.organization_id
  WHERE o.instagram_user_id = p_instagram_user_id;
END;
$$;

-- 4) Grant execute permissions only to service_role for these new functions
GRANT EXECUTE ON FUNCTION public.get_organization_credentials_secure(uuid) TO service_role;
GRANT EXECUTE ON FUNCTION public.get_organization_credentials_by_instagram_user(text) TO service_role;

-- 5) Revoke all access from the credentials table - only accessible through secure functions
REVOKE ALL ON public.organization_meta_credentials FROM PUBLIC, anon, authenticated;

-- 6) Create minimal policies for the existing upsert/status functions to work
-- These functions already have proper organization ownership validation
CREATE POLICY "Allow access through secure functions only"
ON public.organization_meta_credentials
FOR ALL
USING (
  -- Only allow access if called from a security definer function
  -- This effectively blocks direct table access while allowing function-based access
  current_user = 'service_role' AND current_setting('role', true) = 'service_role'
)
WITH CHECK (
  current_user = 'service_role' AND current_setting('role', true) = 'service_role'
);

-- 7) Additional security: Create audit trigger to log access attempts
CREATE OR REPLACE FUNCTION public.audit_credentials_access()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  -- Log any access to credentials (for monitoring)
  INSERT INTO public.notifications (
    organization_id,
    type,
    message,
    priority
  ) VALUES (
    COALESCE(NEW.organization_id, OLD.organization_id),
    'security_audit',
    'Meta credentials accessed at ' || now()::text,
    'low'
  );
  
  RETURN COALESCE(NEW, OLD);
END;
$$;

CREATE TRIGGER audit_meta_credentials_access
  AFTER INSERT OR UPDATE OR DELETE ON public.organization_meta_credentials
  FOR EACH ROW
  EXECUTE FUNCTION public.audit_credentials_access();
</file>

<file path="supabase/migrations/20250826181228_b96cacdb-7b6a-40d5-a510-f17d409ecdb4.sql">
-- Fix Critical Security Issues

-- 1. Fix organization_settings RLS policy bug (cross-tenant write vulnerability)
DROP POLICY IF EXISTS "Owners or permitted members can create organization settings" ON public.organization_settings;
DROP POLICY IF EXISTS "Owners or permitted members can update organization settings" ON public.organization_settings;

CREATE POLICY "Owners or permitted members can create organization settings" 
ON public.organization_settings 
FOR INSERT 
WITH CHECK (
  -- Organization owner can create settings
  EXISTS (
    SELECT 1 FROM public.organizations o
    WHERE o.id = organization_settings.organization_id 
    AND o.created_by = auth.uid()
  ) OR
  -- OR member with manage_instagram permission
  EXISTS (
    SELECT 1 FROM public.organization_members om
    WHERE om.organization_id = organization_settings.organization_id 
    AND om.user_id = auth.uid() 
    AND om.status = 'active'
    AND COALESCE((om.permissions->>'manage_instagram')::boolean, false) = true
  )
);

CREATE POLICY "Owners or permitted members can update organization settings" 
ON public.organization_settings 
FOR UPDATE 
USING (
  -- Organization owner can update settings
  EXISTS (
    SELECT 1 FROM public.organizations o
    WHERE o.id = organization_settings.organization_id 
    AND o.created_by = auth.uid()
  ) OR
  -- OR member with manage_instagram permission
  EXISTS (
    SELECT 1 FROM public.organization_members om
    WHERE om.organization_id = organization_settings.organization_id 
    AND om.user_id = auth.uid() 
    AND om.status = 'active'
    AND COALESCE((om.permissions->>'manage_instagram')::boolean, false) = true
  )
)
WITH CHECK (
  -- Organization owner can update settings
  EXISTS (
    SELECT 1 FROM public.organizations o
    WHERE o.id = organization_settings.organization_id 
    AND o.created_by = auth.uid()
  ) OR
  -- OR member with manage_instagram permission
  EXISTS (
    SELECT 1 FROM public.organization_members om
    WHERE om.organization_id = organization_settings.organization_id 
    AND om.user_id = auth.uid() 
    AND om.status = 'active'
    AND COALESCE((om.permissions->>'manage_instagram')::boolean, false) = true
  )
);

-- 2. Add missing privilege escalation protection for users table
CREATE OR REPLACE FUNCTION public.prevent_user_privilege_escalation()
RETURNS TRIGGER AS $$
BEGIN
  -- Allow service_role to manage all fields
  IF current_user = 'service_role' THEN
    RETURN NEW;
  END IF;
  
  -- For regular users, prevent role changes and organization_id manipulation
  IF TG_OP = 'INSERT' THEN
    -- Force new users to have 'user' role, not 'admin'
    NEW.role := 'user';
    -- Only allow setting organization_id if user owns it
    IF NEW.organization_id IS NOT NULL THEN
      IF NOT EXISTS (
        SELECT 1 FROM public.organizations 
        WHERE id = NEW.organization_id AND created_by = auth.uid()
      ) THEN
        RAISE EXCEPTION 'Cannot assign to organization you do not own';
      END IF;
    END IF;
  END IF;
  
  IF TG_OP = 'UPDATE' THEN
    -- Prevent role changes by regular users
    IF NEW.role IS DISTINCT FROM OLD.role THEN
      RAISE EXCEPTION 'Role changes not allowed';
    END IF;
    -- Prevent organization_id changes
    IF NEW.organization_id IS DISTINCT FROM OLD.organization_id THEN
      RAISE EXCEPTION 'Organization changes not allowed';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add the missing trigger
DROP TRIGGER IF EXISTS prevent_user_privilege_escalation ON public.users;
CREATE TRIGGER prevent_user_privilege_escalation
  BEFORE INSERT OR UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION public.prevent_user_privilege_escalation();

-- 3. Secure sensitive token RPCs - revoke from clients, allow only service_role
REVOKE EXECUTE ON FUNCTION public.get_organization_token_info(uuid) FROM anon, authenticated;
GRANT EXECUTE ON FUNCTION public.get_organization_token_info(uuid) TO service_role;

REVOKE EXECUTE ON FUNCTION public.get_ambassador_token_info(uuid) FROM anon, authenticated;  
GRANT EXECUTE ON FUNCTION public.get_ambassador_token_info(uuid) TO service_role;

-- 4. Hide sensitive token columns from clients
-- Remove SELECT privileges on sensitive columns
REVOKE SELECT (meta_token, token_expiry) ON public.organizations FROM anon, authenticated;
REVOKE SELECT (instagram_access_token, token_expires_at) ON public.embassadors FROM anon, authenticated;

-- Grant SELECT on all other columns explicitly
GRANT SELECT (id, name, description, timezone, logo_url, plan_type, instagram_username, facebook_page_id, instagram_business_account_id, instagram_user_id, last_instagram_sync, created_by, created_at) ON public.organizations TO anon, authenticated;

GRANT SELECT (id, first_name, last_name, email, instagram_user, instagram_user_id, follower_count, profile_picture_url, date_of_birth, rut, global_points, global_category, performance_status, events_participated, completed_tasks, failed_tasks, organization_id, created_by_user_id, status, profile_public, last_instagram_sync, created_at) ON public.embassadors TO anon, authenticated;
</file>

<file path="supabase/migrations/20250826181939_1eae008f-2a79-4850-ad67-510f3f557c07.sql">
-- Fix ambassador_tokens RLS policies for proper access control

-- Add RLS policies to ambassador_tokens table to protect Instagram access tokens
-- Current policy only allows service_role access, but we need organization member access too

-- Allow organization members to view ambassador tokens only for ambassadors in their organization
CREATE POLICY "Members can view organization ambassador tokens"
ON public.ambassador_tokens
FOR SELECT
USING (
  embassador_id IN (
    SELECT e.id
    FROM public.embassadors e
    WHERE is_organization_member(auth.uid(), e.organization_id)
  )
);

-- Allow organization members to update ambassador tokens only for ambassadors in their organization  
CREATE POLICY "Members can update organization ambassador tokens"
ON public.ambassador_tokens
FOR UPDATE
USING (
  embassador_id IN (
    SELECT e.id
    FROM public.embassadors e
    WHERE is_organization_member(auth.uid(), e.organization_id)
  )
);

-- Allow organization members to create ambassador tokens only for ambassadors in their organization
CREATE POLICY "Members can create organization ambassador tokens"
ON public.ambassador_tokens
FOR INSERT
WITH CHECK (
  embassador_id IN (
    SELECT e.id
    FROM public.embassadors e
    WHERE is_organization_member(auth.uid(), e.organization_id)
  )
);

-- Allow organization members to delete ambassador tokens only for ambassadors in their organization
CREATE POLICY "Members can delete organization ambassador tokens"
ON public.ambassador_tokens
FOR DELETE
USING (
  embassador_id IN (
    SELECT e.id
    FROM public.embassadors e
    WHERE is_organization_member(auth.uid(), e.organization_id)
  )
);
</file>

<file path="supabase/migrations/20250901155735_3da38357-11a0-4c64-a071-dba609f9fe7d.sql">
-- 1) Permitir que cualquier miembro consulte el estado de credenciales
create or replace function public.get_org_meta_credentials_status(
  p_organization_id uuid
)
returns table(
  has_credentials boolean,
  updated_at timestamptz
)
language plpgsql
security definer
set search_path = public
as $$
begin
  -- Permitir a cualquier miembro (o due√±o) consultar el estado
  if not public.is_organization_member(auth.uid(), p_organization_id) then
    raise exception 'No autorizado para ver el estado de credenciales de esta organizaci√≥n';
  end if;

  return query
  select
    exists(select 1 from public.organization_meta_credentials omc where omc.organization_id = p_organization_id) as has_credentials,
    (select omc2.updated_at from public.organization_meta_credentials omc2 where omc2.organization_id = p_organization_id limit 1) as updated_at;
end;
$$;

-- 2) Permitir que el due√±o o un miembro con manage_instagram guarde/actualice credenciales
create or replace function public.upsert_org_meta_credentials(
  p_organization_id uuid,
  p_meta_app_id text,
  p_meta_app_secret text,
  p_webhook_verify_token text
)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  -- Autorizar si: (a) el usuario es due√±o de la organizaci√≥n
  --        o (b) es miembro activo con permiso manage_instagram = true
  if not (
    exists (
      select 1
      from public.organizations o
      where o.id = p_organization_id
        and o.created_by = auth.uid()
    )
    or exists (
      select 1
      from public.organization_members om
      where om.organization_id = p_organization_id
        and om.user_id = auth.uid()
        and om.status = 'active'
        and coalesce((om.permissions->>'manage_instagram')::boolean, false) = true
    )
  ) then
    raise exception 'No autorizado para gestionar credenciales de esta organizaci√≥n';
  end if;

  insert into public.organization_meta_credentials(
    organization_id, meta_app_id, meta_app_secret, webhook_verify_token
  )
  values (p_organization_id, p_meta_app_id, p_meta_app_secret, p_webhook_verify_token)
  on conflict (organization_id)
  do update set
    meta_app_id = excluded.meta_app_id,
    meta_app_secret = excluded.meta_app_secret,
    webhook_verify_token = excluded.webhook_verify_token,
    updated_at = now();
end;
$$;
</file>

<file path="supabase/migrations/20250901163414_eef0a8c1-167c-4db8-962c-e9448a33e4e1.sql">
-- Update the RPC function to be more robust and handle permissions properly
CREATE OR REPLACE FUNCTION public.get_org_meta_credentials_status(p_organization_id uuid)
 RETURNS TABLE(has_credentials boolean, updated_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- Check if user has access to organization (either owner or member)
  if not (
    exists (
      select 1
      from public.organizations o
      where o.id = p_organization_id
        and o.created_by = auth.uid()
    )
    or exists (
      select 1
      from public.organization_members om
      where om.organization_id = p_organization_id
        and om.user_id = auth.uid()
        and om.status = 'active'
    )
  ) then
    -- Return false instead of throwing error for better UX
    return query
    select false as has_credentials, null::timestamp with time zone as updated_at;
    return;
  end if;

  -- Return credentials status
  return query
  select
    exists(select 1 from public.organization_meta_credentials omc where omc.organization_id = p_organization_id) as has_credentials,
    (select omc2.updated_at from public.organization_meta_credentials omc2 where omc2.organization_id = p_organization_id limit 1) as updated_at;
end;
$function$;
</file>

<file path="supabase/migrations/20250901202326_f08dcc74-3d25-497f-8385-61050ea69456.sql">
-- Create secure token rotation logs table for audit trail
CREATE TABLE IF NOT EXISTS public.token_rotation_logs (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  organization_id UUID REFERENCES public.organizations(id) ON DELETE CASCADE,
  ambassador_id UUID REFERENCES public.embassadors(id) ON DELETE CASCADE,
  rotation_type TEXT NOT NULL CHECK (rotation_type IN ('automatic', 'manual', 'security_event')),
  old_token_hash TEXT, -- Store hash of old token for auditing
  new_token_hash TEXT, -- Store hash of new token for auditing
  reason TEXT,
  rotated_by UUID, -- User who initiated manual rotation
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  success BOOLEAN NOT NULL DEFAULT true
);

-- Enable RLS on token rotation logs
ALTER TABLE public.token_rotation_logs ENABLE ROW LEVEL SECURITY;

-- Create policy for viewing token rotation logs
CREATE POLICY "Members can view organization token rotation logs" 
ON public.token_rotation_logs 
FOR SELECT 
USING (
  (organization_id IS NOT NULL AND is_organization_member(auth.uid(), organization_id))
  OR 
  (ambassador_id IS NOT NULL AND ambassador_id IN (
    SELECT e.id FROM embassadors e WHERE is_organization_member(auth.uid(), e.organization_id)
  ))
);

-- Create policy for service role to manage logs
CREATE POLICY "Service role can manage token rotation logs" 
ON public.token_rotation_logs 
FOR ALL 
USING (true)
WITH CHECK (true);

-- Function to create secure hash of token for logging (without exposing the token)
CREATE OR REPLACE FUNCTION public.hash_token_for_audit(token_text TEXT)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Create a SHA256 hash of the token for audit purposes
  -- Only first and last 4 characters of hash for identification
  RETURN substring(encode(digest(token_text, 'sha256'), 'hex'), 1, 8);
END;
$$;

-- Create automatic token rotation policy function
CREATE OR REPLACE FUNCTION public.schedule_token_rotation()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Check if token is close to expiration (within 7 days)
  IF NEW.token_expiry IS NOT NULL AND NEW.token_expiry - NOW() < INTERVAL '7 days' THEN
    -- Insert notification for upcoming token expiration
    INSERT INTO public.notifications (
      organization_id,
      type,
      message,
      priority,
      target_type,
      target_id
    ) VALUES (
      COALESCE(NEW.organization_id, (SELECT organization_id FROM embassadors WHERE id = NEW.embassador_id)),
      'token_expiry_warning',
      'Token de Instagram expira pronto. Se recomienda renovar para mantener la funcionalidad.',
      'medium',
      CASE WHEN NEW.organization_id IS NOT NULL THEN 'organization' ELSE 'ambassador' END,
      COALESCE(NEW.organization_id, NEW.embassador_id)
    );
  END IF;
  
  RETURN NEW;
END;
$$;

-- Create triggers for token expiry monitoring
DROP TRIGGER IF EXISTS organization_token_expiry_check ON organization_instagram_tokens;
CREATE TRIGGER organization_token_expiry_check
  AFTER UPDATE ON organization_instagram_tokens
  FOR EACH ROW
  EXECUTE FUNCTION schedule_token_rotation();

DROP TRIGGER IF EXISTS ambassador_token_expiry_check ON ambassador_tokens;  
CREATE TRIGGER ambassador_token_expiry_check
  AFTER UPDATE ON ambassador_tokens
  FOR EACH ROW
  EXECUTE FUNCTION schedule_token_rotation();
</file>

<file path="supabase/migrations/20250901202422_9b68a344-a551-40ad-96fe-f4d1b2753c71.sql">
-- Fix security warnings by setting search_path for functions

-- Update hash_token_for_audit function with proper search_path
CREATE OR REPLACE FUNCTION public.hash_token_for_audit(token_text TEXT)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Create a SHA256 hash of the token for audit purposes
  -- Only first and last 4 characters of hash for identification
  RETURN substring(encode(digest(token_text, 'sha256'), 'hex'), 1, 8);
END;
$$;

-- Update schedule_token_rotation function with proper search_path
CREATE OR REPLACE FUNCTION public.schedule_token_rotation()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Check if token is close to expiration (within 7 days)
  IF NEW.token_expiry IS NOT NULL AND NEW.token_expiry - NOW() < INTERVAL '7 days' THEN
    -- Insert notification for upcoming token expiration
    INSERT INTO public.notifications (
      organization_id,
      type,
      message,
      priority,
      target_type,
      target_id
    ) VALUES (
      COALESCE(NEW.organization_id, (SELECT organization_id FROM embassadors WHERE id = NEW.embassador_id)),
      'token_expiry_warning',
      'Token de Instagram expira pronto. Se recomienda renovar para mantener la funcionalidad.',
      'medium',
      CASE WHEN NEW.organization_id IS NOT NULL THEN 'organization' ELSE 'ambassador' END,
      COALESCE(NEW.organization_id, NEW.embassador_id)
    );
  END IF;
  
  RETURN NEW;
END;
$$;
</file>

<file path="supabase/migrations/20250901202447_01bef7cc-02cf-44c0-8680-d2238716462e.sql">
-- Fix remaining function search_path security warning
CREATE OR REPLACE FUNCTION public.handle_social_mention_ambassador_request()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path = 'public'
AS $function$
BEGIN
  -- Only process if this is an unmatched mention (no ambassador found)
  IF NEW.matched_ambassador_id IS NULL AND NEW.instagram_username IS NOT NULL THEN
    -- Insert or update ambassador request
    INSERT INTO public.ambassador_requests (
      organization_id,
      instagram_user_id,
      instagram_username,
      source_mention_ids,
      total_mentions,
      last_mention_at
    )
    VALUES (
      NEW.organization_id,
      NEW.instagram_user_id,
      NEW.instagram_username,
      ARRAY[NEW.id],
      1,
      NEW.created_at
    )
    ON CONFLICT (organization_id, instagram_username)
    DO UPDATE SET
      source_mention_ids = ambassador_requests.source_mention_ids || NEW.id,
      total_mentions = ambassador_requests.total_mentions + 1,
      last_mention_at = NEW.created_at;
  END IF;
  
  RETURN NEW;
END;
$function$;
</file>

<file path="supabase/migrations/20250901204710_654caf4b-19b5-4082-a1e1-45cbb88980b8.sql">
-- Fix audit_credentials_access function search_path security warning
CREATE OR REPLACE FUNCTION public.audit_credentials_access()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path = 'public'
AS $function$
BEGIN
  -- Log any access to credentials (for monitoring)
  INSERT INTO public.notifications (
    organization_id,
    type,
    message,
    priority
  ) VALUES (
    COALESCE(NEW.organization_id, OLD.organization_id),
    'security_audit',
    'Meta credentials accessed at ' || now()::text,
    'low'
  );
  
  RETURN COALESCE(NEW, OLD);
END;
$function$;
</file>

<file path="supabase/migrations/20250901205157_10d4a94d-e333-4ba8-a9cf-6394e2efee91.sql">
-- Fix set_social_mention_expiry function search_path security warning
CREATE OR REPLACE FUNCTION public.set_social_mention_expiry()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path = 'public'
AS $function$
BEGIN
  IF NEW.expires_at IS NULL THEN
    NEW.expires_at := NEW.mentioned_at + interval '24 hours';
  END IF;
  RETURN NEW;
END;
$function$;
</file>

<file path="supabase/migrations/20250901205451_7d04a1b7-725e-40b0-9406-07005a8c276c.sql">
-- Fix prevent_user_privilege_escalation function search_path security warning  
CREATE OR REPLACE FUNCTION public.prevent_user_privilege_escalation()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path = 'public'
AS $function$
BEGIN
  -- Allow service_role to manage all fields
  IF current_user = 'service_role' THEN
    RETURN NEW;
  END IF;
  
  -- For regular users, prevent role changes and organization_id manipulation
  IF TG_OP = 'INSERT' THEN
    -- Force new users to have 'user' role, not 'admin'
    NEW.role := 'user';
    -- Only allow setting organization_id if user owns it
    IF NEW.organization_id IS NOT NULL THEN
      IF NOT EXISTS (
        SELECT 1 FROM public.organizations 
        WHERE id = NEW.organization_id AND created_by = auth.uid()
      ) THEN
        RAISE EXCEPTION 'Cannot assign to organization you do not own';
      END IF;
    END IF;
  END IF;
  
  IF TG_OP = 'UPDATE' THEN
    -- Prevent role changes by regular users
    IF NEW.role IS DISTINCT FROM OLD.role THEN
      RAISE EXCEPTION 'Role changes not allowed';
    END IF;
    -- Prevent organization_id changes
    IF NEW.organization_id IS DISTINCT FROM OLD.organization_id THEN
      RAISE EXCEPTION 'Organization changes not allowed';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$;
</file>

<file path="supabase/migrations/20250904202847_50693ef3-1a7d-4dcb-9e51-ba3fb4beef2b.sql">
-- Add conversation_id and inbox_link columns to social_mentions table
ALTER TABLE public.social_mentions 
ADD COLUMN conversation_id TEXT,
ADD COLUMN inbox_link TEXT;

-- Add index for conversation_id for better query performance
CREATE INDEX idx_social_mentions_conversation_id ON public.social_mentions(conversation_id);

-- Create CRON job to run the story-mentions-state-worker every hour for verification
-- and every 10 minutes for expiry checks
SELECT cron.schedule(
  'story-mentions-verification-worker',
  '0 * * * *', -- Every hour at minute 0
  $$
  SELECT
    net.http_post(
        url:='https://awpfslcepylnipaolmvv.supabase.co/functions/v1/story-mentions-state-worker',
        headers:='{"Content-Type": "application/json", "Authorization": "Bearer ' || current_setting('app.settings.service_role_key', true) || '"}'::jsonb,
        body:='{"source": "cron", "type": "verification"}'::jsonb
    ) as request_id;
  $$
);

SELECT cron.schedule(
  'story-mentions-expiry-worker',
  '*/10 * * * *', -- Every 10 minutes
  $$
  SELECT
    net.http_post(
        url:='https://awpfslcepylnipaolmvv.supabase.co/functions/v1/story-mentions-state-worker',
        headers:='{"Content-Type": "application/json", "Authorization": "Bearer ' || current_setting('app.settings.service_role_key', true) || '"}'::jsonb,
        body:='{"source": "cron", "type": "expiry"}'::jsonb
    ) as request_id;
  $$
);
</file>

<file path="supabase/migrations/20250913211106_e230427a-c0cd-44ec-832e-9572b31b50f1.sql">
-- Fix security issue: Restrict access to sensitive ambassador data
-- Drop existing overly permissive policies
DROP POLICY IF EXISTS "Members can view organization embassadors" ON public.embassadors;
DROP POLICY IF EXISTS "Members can create embassadors for organization" ON public.embassadors;
DROP POLICY IF EXISTS "Members can update organization embassadors" ON public.embassadors;

-- Create more restrictive policies that check for manage_ambassadors permission

-- Policy 1: Basic ambassador info viewable by all organization members
-- This allows viewing non-sensitive fields like name, instagram_user, status, points, etc.
CREATE POLICY "Members can view basic ambassador info" 
ON public.embassadors 
FOR SELECT 
USING (
  is_organization_member(auth.uid(), organization_id)
);

-- Policy 2: Sensitive ambassador data (email, rut, date_of_birth) only for users with manage_ambassadors permission
-- This will be enforced at the application level through views or selective field queries
-- But we need to ensure the base policy allows access first, then filter in application code

-- Policy 3: Only users with manage_ambassadors permission can create ambassadors
CREATE POLICY "Authorized members can create embassadors" 
ON public.embassadors 
FOR INSERT 
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.organizations o
    WHERE o.id = organization_id 
    AND o.created_by = auth.uid()
  ) OR EXISTS (
    SELECT 1 FROM public.organization_members om
    WHERE om.organization_id = embassadors.organization_id
    AND om.user_id = auth.uid()
    AND om.status = 'active'
    AND COALESCE((om.permissions->>'manage_ambassadors')::boolean, false) = true
  )
);

-- Policy 4: Only users with manage_ambassadors permission can update ambassadors
CREATE POLICY "Authorized members can update embassadors" 
ON public.embassadors 
FOR UPDATE 
USING (
  EXISTS (
    SELECT 1 FROM public.organizations o
    WHERE o.id = organization_id 
    AND o.created_by = auth.uid()
  ) OR EXISTS (
    SELECT 1 FROM public.organization_members om
    WHERE om.organization_id = embassadors.organization_id
    AND om.user_id = auth.uid()
    AND om.status = 'active'
    AND COALESCE((om.permissions->>'manage_ambassadors')::boolean, false) = true
  )
);

-- Create a secure function to get ambassador sensitive data
-- This function will only return sensitive fields to authorized users
CREATE OR REPLACE FUNCTION public.get_ambassador_sensitive_data(ambassador_id uuid)
RETURNS TABLE(
  id uuid,
  email text,
  date_of_birth date,
  rut text,
  profile_picture_url text
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Check if user has permission to view sensitive data
  IF NOT EXISTS (
    SELECT 1 FROM public.embassadors e
    INNER JOIN public.organizations o ON e.organization_id = o.id
    WHERE e.id = ambassador_id 
    AND o.created_by = auth.uid()
  ) AND NOT EXISTS (
    SELECT 1 FROM public.embassadors e
    INNER JOIN public.organization_members om ON e.organization_id = om.organization_id
    WHERE e.id = ambassador_id
    AND om.user_id = auth.uid()
    AND om.status = 'active'
    AND COALESCE((om.permissions->>'manage_ambassadors')::boolean, false) = true
  ) THEN
    -- Return empty result if not authorized
    RETURN;
  END IF;

  -- Return sensitive data if authorized
  RETURN QUERY
  SELECT 
    e.id,
    e.email,
    e.date_of_birth,
    e.rut,
    e.profile_picture_url
  FROM public.embassadors e
  WHERE e.id = ambassador_id;
END;
$$;

-- Create a secure function to get ambassador basic data (non-sensitive)
CREATE OR REPLACE FUNCTION public.get_ambassador_basic_data()
RETURNS TABLE(
  id uuid,
  first_name text,
  last_name text,
  instagram_user text,
  instagram_user_id text,
  follower_count integer,
  global_points integer,
  global_category text,
  performance_status text,
  events_participated integer,
  completed_tasks integer,
  failed_tasks integer,
  organization_id uuid,
  status text,
  profile_public boolean,
  last_instagram_sync timestamp with time zone,
  created_at timestamp with time zone
)
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT 
    e.id,
    e.first_name,
    e.last_name,
    e.instagram_user,
    e.instagram_user_id,
    e.follower_count,
    e.global_points,
    e.global_category,
    e.performance_status,
    e.events_participated,
    e.completed_tasks,
    e.failed_tasks,
    e.organization_id,
    e.status,
    e.profile_public,
    e.last_instagram_sync,
    e.created_at
  FROM public.embassadors e
  WHERE is_organization_member(auth.uid(), e.organization_id);
$$;
</file>

<file path="supabase/migrations/20251030155806_create_story_insights_snapshots.sql">
-- Create story_insights_snapshots table for tracking Story insights over time
-- This table stores periodic snapshots of Instagram Story metrics during their 24h lifecycle

CREATE TABLE IF NOT EXISTS public.story_insights_snapshots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Reference to the story mention
  social_mention_id UUID NOT NULL REFERENCES public.social_mentions(id) ON DELETE CASCADE,
  organization_id UUID NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,
  
  -- Instagram Story identifiers
  instagram_story_id TEXT,
  instagram_media_id TEXT,
  
  -- Snapshot metadata
  snapshot_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  story_age_hours NUMERIC(5,2), -- Age of story when snapshot was taken
  
  -- Core metrics (available for Stories)
  impressions INTEGER DEFAULT 0,
  reach INTEGER DEFAULT 0,
  
  -- Story-specific engagement metrics
  replies INTEGER DEFAULT 0,
  exits INTEGER DEFAULT 0,
  taps_forward INTEGER DEFAULT 0,
  taps_back INTEGER DEFAULT 0,
  
  -- Navigation metrics (JSONB for flexibility)
  navigation JSONB DEFAULT '{}',
  
  -- Additional metrics that might be available
  shares INTEGER DEFAULT 0,
  
  -- Raw data from Instagram API for audit trail
  raw_insights JSONB DEFAULT '{}',
  
  -- Metadata
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  
  -- Constraints
  CONSTRAINT story_insights_snapshots_positive_metrics CHECK (
    impressions >= 0 AND 
    reach >= 0 AND 
    replies >= 0 AND 
    exits >= 0 AND 
    taps_forward >= 0 AND 
    taps_back >= 0 AND
    shares >= 0
  )
);

-- Indexes for efficient querying
CREATE INDEX idx_story_insights_snapshots_mention_id 
  ON public.story_insights_snapshots(social_mention_id);

CREATE INDEX idx_story_insights_snapshots_org_id 
  ON public.story_insights_snapshots(organization_id);

CREATE INDEX idx_story_insights_snapshots_snapshot_at 
  ON public.story_insights_snapshots(snapshot_at DESC);

CREATE INDEX idx_story_insights_snapshots_story_id 
  ON public.story_insights_snapshots(instagram_story_id) 
  WHERE instagram_story_id IS NOT NULL;

-- Composite index for getting latest snapshots per story
CREATE INDEX idx_story_insights_snapshots_mention_snapshot 
  ON public.story_insights_snapshots(social_mention_id, snapshot_at DESC);

-- Enable RLS
ALTER TABLE public.story_insights_snapshots ENABLE ROW LEVEL SECURITY;

-- RLS policies: Members can view snapshots from their organization
CREATE POLICY "Members can view organization story insights snapshots" 
  ON public.story_insights_snapshots 
  FOR SELECT 
  USING (
    public.is_organization_member(auth.uid(), organization_id)
  );

-- System can insert snapshots (for edge functions)
CREATE POLICY "System can insert story insights snapshots" 
  ON public.story_insights_snapshots 
  FOR INSERT 
  WITH CHECK (true);

-- Create a view for latest snapshots per story
CREATE OR REPLACE VIEW public.story_insights_latest AS
SELECT DISTINCT ON (social_mention_id)
  si.*,
  sm.instagram_username,
  sm.mentioned_at,
  sm.expires_at,
  sm.state
FROM public.story_insights_snapshots si
JOIN public.social_mentions sm ON si.social_mention_id = sm.id
ORDER BY social_mention_id, snapshot_at DESC;

-- Grant access to the view
ALTER VIEW public.story_insights_latest OWNER TO postgres;
GRANT SELECT ON public.story_insights_latest TO authenticated;
GRANT SELECT ON public.story_insights_latest TO service_role;

-- Add comment for documentation
COMMENT ON TABLE public.story_insights_snapshots IS 
  'Stores periodic snapshots of Instagram Story insights during their 24-hour lifecycle. ' ||
  'Snapshots are taken at multiple intervals (1h, 4h, 8h, 12h, 20h, 23h) to track metric evolution.';

COMMENT ON COLUMN public.story_insights_snapshots.story_age_hours IS 
  'Age of the story in hours when this snapshot was taken. Useful for time-series analysis.';

COMMENT ON COLUMN public.story_insights_snapshots.navigation IS 
  'JSON object containing detailed navigation metrics like swipe-forward, swipe-back, etc.';
</file>

<file path="supabase/migrations/20251030160000_add_story_insights_cron.sql">
-- Create cron job to collect Story insights every 2 hours
-- This ensures we capture snapshots at key points in the 24h Story lifecycle
-- Snapshots will be taken approximately at: 1h, 4h, 8h, 12h, 20h, 23h after story creation

-- Unschedule existing job if it exists
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'collect-story-insights-every-2h') THEN
    PERFORM cron.unschedule('collect-story-insights-every-2h');
  END IF;
END$$;

-- Schedule new job to run every 2 hours
SELECT cron.schedule(
  'collect-story-insights-every-2h',
  '0 */2 * * *', -- Every 2 hours at minute 0 (e.g., 00:00, 02:00, 04:00, etc.)
  $$
  SELECT
    net.http_post(
      url    := 'https://awpfslcepylnipaolmvv.supabase.co/functions/v1/collect-story-insights',
      headers:= jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || current_setting('app.settings.service_role_key', true),
        'x-cron-secret', current_setting('app.settings.cron_secret', true)
      ),
      body   := '{"source":"cron"}'::jsonb
    );
  $$
);

-- Add comment for documentation
COMMENT ON EXTENSION cron IS 'Includes job: collect-story-insights-every-2h - Collects Instagram Story insights every 2 hours for stories within their 24h lifecycle';
</file>

<file path="supabase/migrations/20251202215835_add_story_insights_columns.sql">
-- Add new story insights columns based on Instagram API v24.0
-- See: https://developers.facebook.com/docs/instagram-platform/reference/instagram-media/insights

-- Make social_mention_id nullable (stories may not have a corresponding mention)
ALTER TABLE public.story_insights_snapshots 
  ALTER COLUMN social_mention_id DROP NOT NULL;

-- Update foreign key to SET NULL on delete
ALTER TABLE public.story_insights_snapshots 
  DROP CONSTRAINT IF EXISTS story_insights_snapshots_social_mention_id_fkey;

ALTER TABLE public.story_insights_snapshots 
  ADD CONSTRAINT story_insights_snapshots_social_mention_id_fkey 
  FOREIGN KEY (social_mention_id) 
  REFERENCES public.social_mentions(id) 
  ON DELETE SET NULL;

-- Add new engagement metrics columns
ALTER TABLE public.story_insights_snapshots 
  ADD COLUMN IF NOT EXISTS profile_visits INTEGER DEFAULT 0,
  ADD COLUMN IF NOT EXISTS total_interactions INTEGER DEFAULT 0,
  ADD COLUMN IF NOT EXISTS views INTEGER DEFAULT 0;

-- Add index for instagram_story_id lookups
CREATE INDEX IF NOT EXISTS idx_story_insights_snapshots_ig_story_id 
  ON public.story_insights_snapshots(instagram_story_id);

-- Update constraint to include new columns
ALTER TABLE public.story_insights_snapshots
  DROP CONSTRAINT IF EXISTS story_insights_snapshots_positive_metrics;

ALTER TABLE public.story_insights_snapshots
  ADD CONSTRAINT story_insights_snapshots_positive_metrics CHECK (
    impressions >= 0 AND 
    reach >= 0 AND 
    replies >= 0 AND 
    exits >= 0 AND 
    taps_forward >= 0 AND 
    taps_back >= 0 AND
    shares >= 0 AND
    profile_visits >= 0 AND
    total_interactions >= 0 AND
    views >= 0
  );

-- Add comments for new columns
COMMENT ON COLUMN public.story_insights_snapshots.profile_visits IS 
  'Number of times profile was visited from this story';

COMMENT ON COLUMN public.story_insights_snapshots.total_interactions IS 
  'Total interactions (likes, saves, comments, shares minus unlikes/unsaves/deleted)';

COMMENT ON COLUMN public.story_insights_snapshots.views IS 
  'Total views of the story (metric in development by Meta)';

COMMENT ON COLUMN public.story_insights_snapshots.social_mention_id IS 
  'Optional reference to social_mentions. NULL for stories fetched directly without a mention record.';
</file>

<file path="supabase/config.toml">
project_id = "awpfslcepylnipaolmvv"

[functions.meta-oauth]
verify_jwt = true

[functions.instagram-webhook]
verify_jwt = false

[functions.instagram-sync]
verify_jwt = true

[functions.instagram-profile]
verify_jwt = true

[functions.instagram-diagnostics]
verify_jwt = true

[functions.backup-full-database]
verify_jwt = true

[functions.export-organization-data]
verify_jwt = true

[functions.restore-organization-data]
verify_jwt = true

[functions.facebook-data-deletion]
verify_jwt = false

[functions.secure-webhook-proxy]
verify_jwt = true

[functions.instagram-token-status]
verify_jwt = true

[functions.disconnect-instagram]
verify_jwt = true

[functions.resolve-story-mentions]
verify_jwt = true
</file>

<file path=".env.example">
# Supabase Credentials for Story Insights Cron Testing
# Copy this file to .env and fill in your actual values

# Supabase Service Role Key (obtener de: Dashboard ‚Üí Settings ‚Üí API ‚Üí service_role)
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Supabase Anon Key (opcional, para pruebas de usuario)
SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Cron Secret (generar con: openssl rand -hex 32)
# Debe coincidir con el configurado en:
# 1. Supabase Dashboard ‚Üí Edge Functions ‚Üí Settings ‚Üí Environment Variables
# 2. Base de datos: app.settings.cron_secret
CRON_SECRET=your-cron-secret-here

# Supabase URL (opcional, tiene default)
SUPABASE_URL=https://awpfslcepylnipaolmvv.supabase.co

SUPABASE_PROJECT_ID=
SUPABASE_PUBLISHABLE_KEY=

TOKEN_ENCRYPTION_KEY=

# META ENV
META_APP_ID=
META_APP_SECRET=

# INSTAGRAM APP ID
INSTAGRAM_APP_ID=
INSTAGRAM_APP_SECRET=

WEBHOOK_VERIFY_TOKEN=
</file>

<file path="complete-typescript-fixes.ts">
// Complete fixes for all remaining TypeScript errors
// Pattern to fix: error.message => error instanceof Error ? error.message : String(error)

export function getErrorMessage(error: unknown): string {
  return error instanceof Error ? error.message : String(error);
}

export function getErrorName(error: unknown): string {
  return error instanceof Error ? error.name : 'Error';
}

export function isAbortError(error: unknown): boolean {
  return error instanceof Error && error.name === 'AbortError';
}

// Apply these fixes to all remaining files with TypeScript errors
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="eslint.config.js">
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";

export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": [
        "warn",
        { allowConstantExport: true },
      ],
      "@typescript-eslint/no-unused-vars": "off",
    },
  }
);
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>insta-maestro-hub</title>
    <meta name="description" content="Lovable Generated Project" />
    <meta name="author" content="Lovable" />

    <meta property="og:title" content="insta-maestro-hub" />
    <meta property="og:description" content="Lovable Generated Project" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="META_APP_REVIEW_GUIDE.md">
# Gu√≠a de Revisi√≥n de App de Meta - EVA System

## Resumen de la App

**EVA System** es una plataforma de gesti√≥n de embajadores de marca que permite a las organizaciones:
- Administrar y rankear embajadores seg√∫n su desempe√±o en Instagram
- Rastrear menciones en Stories de Instagram
- Analizar m√©tricas de alcance, engagement e impresiones
- Asignar tareas a embajadores y medir su cumplimiento
- Generar reportes anal√≠ticos de rendimiento

---

## Permisos Requeridos

### 1. `pages_show_list` (CR√çTICO - Necesita App Review)

**Por qu√© lo necesitamos:**
Para listar las P√°ginas de Facebook del usuario y detectar cu√°les tienen cuentas de Instagram Business vinculadas.

**C√≥mo lo usamos:**
- Llamamos a `GET /me/accounts` para obtener la lista de p√°ginas
- Para cada p√°gina, verificamos si tiene una cuenta de Instagram Business conectada
- Esto permite al usuario seleccionar qu√© cuenta de Instagram quiere conectar a su organizaci√≥n

**Texto para el formulario:**
> "EVA System necesita listar las P√°ginas de Facebook del usuario para identificar cu√°les tienen cuentas de Instagram Business vinculadas. Esto es esencial para el proceso de conexi√≥n inicial, donde el administrador de la organizaci√≥n elige qu√© cuenta de Instagram usar para monitorear menciones y analizar el rendimiento de sus embajadores de marca."

---

### 2. `instagram_manage_insights` (CR√çTICO - Necesita App Review)

**Por qu√© lo necesitamos:**
Para obtener m√©tricas de rendimiento de las Stories de Instagram (alcance, impresiones, respuestas, compartidos).

**C√≥mo lo usamos:**
- Obtenemos insights de Stories publicadas por embajadores
- Calculamos el alcance total de las campa√±as
- Medimos el engagement (respuestas, compartidos)
- Generamos rankings basados en m√©tricas reales

**Texto para el formulario:**
> "EVA System es una plataforma de gesti√≥n de embajadores de marca. Necesitamos instagram_manage_insights para obtener m√©tricas de rendimiento (alcance, impresiones, engagement) de las Stories donde nuestros embajadores mencionan la marca. Estos datos se usan para: (1) Calcular el alcance total de cada embajador, (2) Rankear embajadores seg√∫n su desempe√±o real, (3) Generar reportes anal√≠ticos para las organizaciones, (4) Asignar puntos y categor√≠as (Bronce/Plata/Oro/Diamante) basados en m√©tricas verificables."

---

### 3. `pages_read_engagement` (RECOMENDADO)

**Por qu√© lo necesitamos:**
Para leer datos de engagement de las p√°ginas de Facebook vinculadas.

**Texto para el formulario:**
> "Necesitamos leer m√©tricas de engagement de las P√°ginas de Facebook para complementar nuestros an√°lisis de rendimiento de embajadores y proporcionar reportes completos a las organizaciones."

---

### 4. `pages_manage_metadata` (RECOMENDADO)

**Por qu√© lo necesitamos:**
Para suscribir webhooks que nos notifiquen cuando un embajador menciona la marca en una Story.

**Texto para el formulario:**
> "Necesitamos pages_manage_metadata para configurar webhooks que nos notifiquen en tiempo real cuando embajadores mencionan la cuenta de Instagram de la organizaci√≥n en sus Stories. Esto es fundamental para el rastreo autom√°tico de menciones."

---

## Gu√≠a para Video de Demostraci√≥n

### Video 1: `pages_show_list`

**Duraci√≥n recomendada:** 60-90 segundos

**Gui√≥n del video:**

1. **Intro (5s):** "Este video muestra c√≥mo EVA System usa pages_show_list"

2. **Ir a Configuraci√≥n (10s):**
   - Navegar a `https://app.evasystem.cl/settings`
   - Hacer clic en la pesta√±a "Instagram"

3. **Conectar Instagram (15s):**
   - Mostrar el bot√≥n "Conectar Instagram"
   - Hacer clic en √©l
   - Mostrar la pantalla de autorizaci√≥n de Facebook

4. **Selecci√≥n de p√°ginas (20s):**
   - En la pantalla de Meta, mostrar la lista de p√°ginas disponibles
   - Explicar: "Aqu√≠ el usuario ve sus p√°ginas de Facebook. Selecciona las que tienen cuentas de Instagram Business vinculadas."

5. **Resultado (15s):**
   - Mostrar c√≥mo la app detecta las cuentas de Instagram
   - Mostrar el panel de diagn√≥stico con las p√°ginas encontradas

6. **Cierre (5s):** "Este permiso es necesario √∫nicamente para el proceso de conexi√≥n inicial."

---

### Video 2: `instagram_manage_insights`

**Duraci√≥n recomendada:** 90-120 segundos

**Gui√≥n del video:**

1. **Intro (5s):** "Este video muestra c√≥mo EVA System usa instagram_manage_insights"

2. **Dashboard de Anal√≠ticas (20s):**
   - Navegar a `https://app.evasystem.cl/analytics` (o la ruta correcta)
   - Mostrar las m√©tricas principales:
     - "Alcance Total" 
     - "Total Menciones"
     - "Tasa de Completitud"

3. **Ranking de Embajadores (20s):**
   - Mostrar el "Top 10 Embajadores"
   - Explicar: "Los embajadores se rankean seg√∫n su alcance y engagement medido a trav√©s de instagram_manage_insights"

4. **Detalle de Embajador (25s):**
   - Hacer clic en "Ver" en un embajador
   - Mostrar las m√©tricas:
     - Alcance Total
     - Engagement Promedio
     - Insights de Stories (total stories, alcance, impresiones, engagement)

5. **Menciones de Stories (20s):**
   - Navegar a la secci√≥n de "Menciones"
   - Mostrar una menci√≥n con sus m√©tricas

6. **Cierre (10s):** "Estos insights nos permiten medir objetivamente el desempe√±o de cada embajador y generar rankings justos basados en datos reales."

---

## Pantallas a Capturar para Screenshots

Para cada permiso, Meta pide screenshots. Aqu√≠ est√°n las pantallas relevantes:

### Para `pages_show_list`:
1. **Configuraci√≥n > Instagram** - Bot√≥n "Conectar Instagram"
2. **Modal de diagn√≥stico** - Mostrando las p√°ginas encontradas
3. **Estado de conexi√≥n** - Mostrando cuenta conectada

### Para `instagram_manage_insights`:
1. **Dashboard Anal√≠tico** - M√©tricas principales (Alcance, Menciones, etc.)
2. **Ranking de Embajadores** - Top 10 con puntos
3. **Detalle de Embajador** - Cards de m√©tricas
4. **Insights de Stories** - Secci√≥n espec√≠fica mostrando alcance/impresiones
5. **Distribuci√≥n de Rendimiento** - Gr√°fico de pie (Cumple/Advertencia/No Cumple)

---

## Texto Completo para Formulario de App Review

### Descripci√≥n General de la App:

```
EVA System es una plataforma SaaS de gesti√≥n de embajadores de marca para empresas en Chile y Latinoam√©rica.

La plataforma permite a las organizaciones:
1. Registrar y gestionar embajadores de marca
2. Asignar tareas de contenido en Instagram (como publicar Stories con hashtags espec√≠ficos)
3. Rastrear autom√°ticamente cuando los embajadores mencionan la marca en sus Stories
4. Medir el alcance e impacto real de cada embajador usando m√©tricas de Instagram
5. Rankear embajadores en categor√≠as (Bronce, Plata, Oro, Diamante) seg√∫n su desempe√±o
6. Generar reportes anal√≠ticos para las organizaciones

URL de la App: https://app.evasystem.cl
```

### Instrucciones de Prueba para el Revisor:

```
1. Visite https://app.evasystem.cl
2. Inicie sesi√≥n con las credenciales de prueba proporcionadas
3. Navegue a Configuraci√≥n > Instagram para ver el proceso de conexi√≥n
4. Vaya a "Anal√≠ticas" para ver c√≥mo se muestran las m√©tricas de Instagram
5. En "Embajadores", haga clic en "Ver" para ver los insights individuales
6. En "Menciones", puede ver c√≥mo se rastrean las menciones en Stories
```

---

## Checklist Pre-Env√≠o

- [ ] Privacy Policy URL actualizada y accesible
- [ ] Terms of Service URL actualizados
- [ ] App Icon de alta calidad (1024x1024)
- [ ] Screenshots de todas las pantallas relevantes
- [ ] Videos de demostraci√≥n para cada permiso
- [ ] Credenciales de prueba para el revisor
- [ ] Data Deletion URL configurada
- [ ] Business Verification completada (si aplica)

---

## URLs Requeridas

| Campo | URL |
|-------|-----|
| Privacy Policy | https://evasystem.cl/privacy |
| Terms of Service | https://evasystem.cl/terms |
| Data Deletion | https://app.evasystem.cl/data-deletion |
| App Website | https://evasystem.cl |

---

## Respuestas a Preguntas Frecuentes del Revisor

**P: ¬øPor qu√© necesitan acceso a p√°ginas de Facebook?**
R: Solo necesitamos listar las p√°ginas para identificar cu√°les tienen cuentas de Instagram Business vinculadas. No accedemos al contenido ni publicamos en las p√°ginas.

**P: ¬øQu√© hacen con los datos de Instagram?**
R: Los datos se usan exclusivamente para calcular m√©tricas de rendimiento de embajadores. No compartimos datos con terceros ni los usamos para publicidad.

**P: ¬øPor qu√© necesitan insights en tiempo real?**
R: Para poder rankear embajadores de manera justa, necesitamos m√©tricas actualizadas de su alcance y engagement.

---

## Notas Importantes

1. **Modo de App:** Aseg√∫rate de que la app est√© en modo "Activo" (no Development) para el review

2. **Permisos ya aprobados que tienes:**
   - ‚úÖ instagram_business_basic
   - ‚úÖ instagram_business_manage_messages
   - ‚úÖ instagram_business_content_publish

3. **Permisos por solicitar:**
   - ‚è≥ pages_show_list (CR√çTICO)
   - ‚è≥ instagram_manage_insights (CR√çTICO)
   - ‚è≥ pages_read_engagement (RECOMENDADO)
   - ‚è≥ pages_manage_metadata (RECOMENDADO para webhooks)
</file>

<file path="package.json">
{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.0",
    "@radix-ui/react-accordion": "^1.2.0",
    "@radix-ui/react-alert-dialog": "^1.1.1",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-collapsible": "^1.1.0",
    "@radix-ui/react-context-menu": "^2.2.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-hover-card": "^1.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.1",
    "@radix-ui/react-navigation-menu": "^1.2.0",
    "@radix-ui/react-popover": "^1.1.1",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.0",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@supabase/supabase-js": "^2.53.0",
    "@tanstack/react-query": "^5.56.2",
    "@types/react-window": "^1.8.8",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "date-fns": "^3.6.0",
    "embla-carousel-react": "^8.3.0",
    "i18next": "^25.4.0",
    "input-otp": "^1.2.4",
    "lucide-react": "^0.462.0",
    "next-themes": "^0.3.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.0",
    "react-i18next": "^15.7.0",
    "react-resizable-panels": "^2.1.3",
    "react-router-dom": "^6.26.2",
    "react-window": "^2.0.2",
    "recharts": "^2.12.7",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@tailwindcss/typography": "^0.5.15",
    "@types/node": "^22.5.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.9.0",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "lovable-tagger": "^1.1.7",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.11",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="README.md">
# Welcome to your Lovable project

## Project info

**URL**: https://lovable.dev/projects/683863ee-ecdb-43b3-915c-426116657c73

## How can I edit this code?

There are several ways of editing your application.

**Use Lovable**

Simply visit the [Lovable Project](https://lovable.dev/projects/683863ee-ecdb-43b3-915c-426116657c73) and start prompting.

Changes made via Lovable will be committed automatically to this repo.

**Use your preferred IDE**

If you want to work locally using your own IDE, you can clone this repo and push changes. Pushed changes will also be reflected in Lovable.

The only requirement is having Node.js & npm installed - [install with nvm](https://github.com/nvm-sh/nvm#installing-and-updating)

Follow these steps:

```sh
# Step 1: Clone the repository using the project's Git URL.
git clone <YOUR_GIT_URL>

# Step 2: Navigate to the project directory.
cd <YOUR_PROJECT_NAME>

# Step 3: Install the necessary dependencies.
npm i

# Step 4: Start the development server with auto-reloading and an instant preview.
npm run dev
```

**Edit a file directly in GitHub**

- Navigate to the desired file(s).
- Click the "Edit" button (pencil icon) at the top right of the file view.
- Make your changes and commit the changes.

**Use GitHub Codespaces**

- Navigate to the main page of your repository.
- Click on the "Code" button (green button) near the top right.
- Select the "Codespaces" tab.
- Click on "New codespace" to launch a new Codespace environment.
- Edit files directly within the Codespace and commit and push your changes once you're done.

## What technologies are used for this project?

This project is built with:

- Vite
- TypeScript
- React
- shadcn-ui
- Tailwind CSS

## How can I deploy this project?

Simply open [Lovable](https://lovable.dev/projects/683863ee-ecdb-43b3-915c-426116657c73) and click on Share -> Publish.

## Can I connect a custom domain to my Lovable project?

Yes, you can!

To connect a domain, navigate to Project > Settings > Domains and click Connect Domain.

Read more here: [Setting up a custom domain](https://docs.lovable.dev/tips-tricks/custom-domain#step-by-step-guide)
</file>

<file path="STORY_INSIGHTS_IMPLEMENTATION.md">
# üìä Story Insights - Implementaci√≥n Completa

## Resumen Ejecutivo

Este documento detalla la implementaci√≥n completa del sistema de **Polling + Cron para Stories vigentes (‚â§24h) y lectura de insights por Story, persistiendo snapshots en Supabase**.

---

## ‚úÖ Funcionalidades Implementadas

### 1. **Base de Datos - Tabla `story_insights_snapshots`**

**Archivo:** `supabase/migrations/20251030155806_create_story_insights_snapshots.sql`

**Descripci√≥n:** Tabla dedicada para almacenar snapshots peri√≥dicos de insights de Stories durante su ciclo de vida de 24 horas.

**Campos principales:**
- `social_mention_id` - Referencia a la story en `social_mentions`
- `instagram_story_id` - ID de la historia en Instagram
- `snapshot_at` - Timestamp del snapshot
- `story_age_hours` - Edad de la story cuando se tom√≥ el snapshot
- **M√©tricas de Stories:**
  - `impressions` - Impresiones totales
  - `reach` - Alcance √∫nico
  - `replies` - Respuestas recibidas
  - `exits` - Salidas de la story
  - `taps_forward` - Taps hacia adelante
  - `taps_back` - Taps hacia atr√°s
  - `shares` - Veces compartida
  - `navigation` - Datos de navegaci√≥n (JSONB)
- `raw_insights` - Datos raw del API para auditor√≠a

**Caracter√≠sticas:**
- √çndices optimizados para consultas r√°pidas
- RLS (Row Level Security) habilitado
- Vista `story_insights_latest` para obtener el √∫ltimo snapshot de cada story
- Constraints para validar valores positivos

---

### 2. **Funci√≥n Dedicada `collect-story-insights`**

**Archivo:** `supabase/functions/collect-story-insights/index.ts`

**Descripci√≥n:** Funci√≥n serverless que colecta insights de Stories activas (<24h) y persiste snapshots.

**Caracter√≠sticas:**
- **Polling Inteligente:** Solo colecta snapshots en momentos clave:
  - 1 hora
  - 4 horas
  - 8 horas
  - 12 horas
  - 20 horas
  - 23 horas
- **Dos Fuentes de Datos:**
  - Stories desde `social_mentions` (historias rastreadas)
  - Stories desde Instagram API (cobertura completa)
- **Seguridad:** Valida token de cron y autenticaci√≥n de usuario
- **API Version:** Usa `v21.0` (√∫ltima estable)
- **M√©tricas espec√≠ficas de Stories:** impressions, reach, replies, exits, taps_forward, taps_back, shares

**Flujo de Trabajo:**
1. Obtiene organizaciones con conexiones de Instagram
2. Verifica tokens v√°lidos
3. Recupera Stories activas (<24h)
4. Determina si debe tomar snapshot basado en edad
5. Consulta insights desde Instagram Graph API
6. Persiste snapshot en Supabase
7. Reporta resultados

---

### 3. **Cron Job para Colecci√≥n Peri√≥dica**

**Archivo:** `supabase/migrations/20251030160000_add_story_insights_cron.sql`

**Descripci√≥n:** Job programado que ejecuta `collect-story-insights` cada 2 horas.

**Schedule:** `0 */2 * * *` (cada 2 horas en punto)

**Beneficios:**
- Captura snapshots en m√∫ltiples puntos del ciclo de 24h
- Permite an√°lisis de evoluci√≥n temporal de m√©tricas
- Asegura que no se pierdan datos antes de que expire la story

---

### 4. **Webhook Handler para `story_insights`**

**Archivo:** `supabase/functions/instagram-webhook/index.ts`

**Descripci√≥n:** Handler agregado para procesar eventos de insights enviados por Meta en tiempo real.

**Funcionalidad:**
- Captura eventos `story_insights` del webhook
- Busca la story en `social_mentions`
- Parsea m√©tricas del payload
- Crea snapshot instant√°neo cuando llegan insights
- Maneja casos donde la story a√∫n no est√° registrada

**Ventaja:** Complementa el polling con datos push en tiempo real cuando est√°n disponibles.

---

### 5. **Snapshot Final en `story-mentions-state-worker`**

**Archivo:** `supabase/functions/story-mentions-state-worker/index.ts`

**Descripci√≥n:** Worker actualizado para capturar un snapshot final de insights cuando una story expira naturalmente a las 24h.

**Mejoras:**
- Intenta obtener insights finales antes de marcar como completada
- Crea snapshot con `story_age_hours: 24`
- Notificaci√≥n mejorada indicando si se guardaron insights finales
- Usa API `v21.0`

**Beneficio:** Captura el rendimiento total de la story al finalizar su ciclo.

---

### 6. **Instagram Sync Mejorado**

**Archivo:** `supabase/functions/instagram-sync/index.ts`

**Descripci√≥n:** Funci√≥n de sincronizaci√≥n actualizada para colectar insights espec√≠ficos de Stories.

**Mejoras Clave:**
- **Filtrado por tipo:** Distingue entre Stories (`media_product_type: 'STORY'`) y otros contenidos
- **M√©tricas espec√≠ficas:**
  - Stories: impressions, reach, replies, exits, taps_forward, taps_back, shares
  - Otros: reach, impressions (gen√©rico)
- **Validaci√≥n de edad:** Solo procesa Stories activas (<24h)
- **Persistencia:** Crea snapshots autom√°ticamente durante el sync
- **L√≠mite aumentado:** De 10 a 50 items para cubrir m√°s stories activas
- **API Version:** Actualizado a `v21.0`

---

### 7. **Actualizaci√≥n de API Version**

**Alcance:** Todas las funciones serverless

**Cambio:** `v18.0` ‚Üí `v21.0`

**Archivos Actualizados:**
- `instagram-sync/index.ts`
- `instagram-webhook/index.ts`
- `story-mentions-state-worker/index.ts`
- `resolve-story-mentions/index.ts`
- `meta-oauth/index.ts`
- `instagram-send-message/index.ts`
- `instagram-diagnostics/index.ts`
- `collect-story-insights/index.ts` (nuevo)

**Beneficio:** Compatibilidad con las √∫ltimas m√©tricas y endpoints de Meta.

---

## üîÑ Flujo Completo del Sistema

### Ciclo de Vida de una Story

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Story Publicada en Instagram                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. Webhook recibe evento (media o story_mention)            ‚îÇ
‚îÇ     ‚Üí Crea registro en social_mentions                       ‚îÇ
‚îÇ     ‚Üí mentioned_at = now()                                   ‚îÇ
‚îÇ     ‚Üí expires_at = mentioned_at + 24h                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  2. Cron "collect-story-insights" (cada 2h)                  ‚îÇ
‚îÇ     ‚Üí Detecta story activa                                   ‚îÇ
‚îÇ     ‚Üí Verifica si debe tomar snapshot (1h, 4h, 8h, etc.)    ‚îÇ
‚îÇ     ‚Üí Consulta insights desde Instagram API                  ‚îÇ
‚îÇ     ‚Üí Persiste snapshot en story_insights_snapshots          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  3. Instagram Sync (cada 5 min)                              ‚îÇ
‚îÇ     ‚Üí Sincroniza media reciente                              ‚îÇ
‚îÇ     ‚Üí Filtra por Stories activas                             ‚îÇ
‚îÇ     ‚Üí Colecta insights espec√≠ficos                           ‚îÇ
‚îÇ     ‚Üí Crea snapshots adicionales si corresponde              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  4. Webhook story_insights (si disponible)                   ‚îÇ
‚îÇ     ‚Üí Recibe insights en tiempo real                         ‚îÇ
‚îÇ     ‚Üí Crea snapshot instant√°neo                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  5. Story-mentions-state-worker (cada hora)                  ‚îÇ
‚îÇ     ‚Üí Verifica en intervalos 1h, 12h, 23h                    ‚îÇ
‚îÇ     ‚Üí Detecta eliminaci√≥n temprana                           ‚îÇ
‚îÇ     ‚Üí Al llegar a 24h:                                       ‚îÇ
‚îÇ       ‚úì Intenta snapshot final                               ‚îÇ
‚îÇ       ‚úì Marca state = 'completed'                            ‚îÇ
‚îÇ       ‚úì Notifica con resultados                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Timeline de Snapshots

```
Story Age:    0h    1h    4h    8h    12h   20h   23h   24h
              ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ
Collect:      ‚îÇ     ‚óè     ‚óè     ‚óè     ‚óè     ‚óè     ‚óè     ‚îÇ
Instagram:    ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
Worker:       ‚îÇ     ‚óè                 ‚óè           ‚óè     ‚óè
Webhook:      ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ(cuando Meta lo env√≠a)‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ

‚óè = Snapshot tomado
```

---

## üìä Datos Capturados

### M√©tricas por Snapshot

Cada snapshot incluye:

| M√©trica | Descripci√≥n | Tipo |
|---------|-------------|------|
| `impressions` | N√∫mero total de veces vista | INTEGER |
| `reach` | Usuarios √∫nicos que vieron | INTEGER |
| `replies` | Respuestas directas recibidas | INTEGER |
| `exits` | Usuarios que salieron de la story | INTEGER |
| `taps_forward` | Taps para avanzar | INTEGER |
| `taps_back` | Taps para retroceder | INTEGER |
| `shares` | Veces compartida | INTEGER |
| `navigation` | Datos detallados de navegaci√≥n | JSONB |

### Metadatos

- `story_age_hours` - Edad precisa cuando se tom√≥ el snapshot
- `snapshot_at` - Timestamp exacto
- `raw_insights` - Datos completos del API para auditor√≠a

---

## üéØ Casos de Uso

### 1. An√°lisis de Evoluci√≥n Temporal

```sql
SELECT 
  story_age_hours,
  impressions,
  reach,
  replies
FROM story_insights_snapshots
WHERE social_mention_id = '<story_id>'
ORDER BY story_age_hours;
```

**Output:**
```
story_age_hours | impressions | reach | replies
----------------|-------------|-------|--------
1.0             | 150         | 120   | 5
4.0             | 450         | 380   | 12
8.0             | 820         | 650   | 18
12.0            | 1200        | 890   | 22
20.0            | 1550        | 1100  | 25
23.0            | 1680        | 1180  | 27
24.0            | 1720        | 1200  | 28
```

### 2. √öltimos Insights por Story

```sql
SELECT * FROM story_insights_latest
WHERE organization_id = '<org_id>'
ORDER BY snapshot_at DESC
LIMIT 10;
```

### 3. Comparaci√≥n de Rendimiento

```sql
SELECT 
  sm.instagram_username,
  MAX(sis.impressions) as max_impressions,
  MAX(sis.reach) as max_reach,
  MAX(sis.replies) as total_replies
FROM story_insights_snapshots sis
JOIN social_mentions sm ON sis.social_mention_id = sm.id
WHERE sm.organization_id = '<org_id>'
  AND sis.story_age_hours >= 23
GROUP BY sm.id, sm.instagram_username
ORDER BY max_impressions DESC;
```

---

## üîê Conformidad con Documentaci√≥n de Meta

### ‚úÖ Endpoints Utilizados

1. **IG Media Insights**
   - Endpoint: `GET /{ig-media-id}/insights`
   - M√©tricas: impressions, reach, replies, exits, taps_forward, taps_back, shares
   - Documentaci√≥n: [Instagram Graph API - IG Media Insights](https://developers.facebook.com/docs/instagram-api/reference/ig-media/insights)

2. **IG User Media**
   - Endpoint: `GET /{ig-user-id}/media`
   - Filtro: `media_product_type=STORY`
   - Documentaci√≥n: [Instagram Graph API - IG User Media](https://developers.facebook.com/docs/instagram-api/reference/ig-user/media)

### ‚úÖ Limitaciones Respetadas

- **Ventana de 24h:** Solo se consultan insights para Stories activas (<24h)
- **No retroactivo:** No se intentan obtener datos hist√≥ricos previos a la configuraci√≥n
- **Rate Limits:** Polling espaciado cada 2h para respetar l√≠mites
- **M√©tricas actuales:** Usa solo m√©tricas no descontinuadas

### ‚úÖ Mejores Pr√°cticas

- **Snapshots m√∫ltiples:** Captura evoluci√≥n durante el ciclo de vida
- **Snapshot final:** Intenta obtener m√©tricas finales antes de expiraci√≥n
- **Datos raw:** Almacena respuesta completa del API para auditor√≠a
- **Manejo de errores:** Logs detallados y notificaciones de problemas

---

## üöÄ Ventajas de la Implementaci√≥n

### 1. **Cobertura Completa**
- ‚úÖ Polling programado cada 2 horas
- ‚úÖ Sync general cada 5 minutos
- ‚úÖ Webhooks en tiempo real
- ‚úÖ Snapshot final garantizado

### 2. **Datos Ricos**
- ‚úÖ M√∫ltiples puntos en el tiempo (1h, 4h, 8h, 12h, 20h, 23h, 24h)
- ‚úÖ M√©tricas espec√≠ficas de Stories (no solo reach/impressions)
- ‚úÖ Datos de interacci√≥n (replies, exits, taps)

### 3. **Arquitectura Robusta**
- ‚úÖ Redundancia (m√∫ltiples fuentes)
- ‚úÖ Idempotencia (no duplica snapshots)
- ‚úÖ Manejo de errores
- ‚úÖ Notificaciones autom√°ticas

### 4. **An√°lisis Avanzado**
- ‚úÖ Evoluci√≥n temporal
- ‚úÖ Rendimiento comparativo
- ‚úÖ Detecci√≥n de patrones
- ‚úÖ ROI de Stories

---

## üìà M√©tricas del Sistema

### Frecuencia de Colecci√≥n

| Mecanismo | Frecuencia | Prop√≥sito |
|-----------|-----------|-----------|
| `collect-story-insights` | Cada 2 horas | Snapshots programados |
| `instagram-sync` | Cada 5 minutos | Sync general + stories |
| `story-mentions-state-worker` | Cada hora | Verificaci√≥n + snapshot final |
| Webhook `story_insights` | Tiempo real | Push de Meta |

### Cobertura Esperada

Para una story t√≠pica de 24h:
- **M√≠nimo:** 4-6 snapshots
- **T√≠pico:** 7-10 snapshots
- **M√°ximo:** 15+ snapshots (con webhook activo)

---

## üîß Mantenimiento y Monitoreo

### Logs a Revisar

1. **collect-story-insights**
   - `Found X active story mentions`
   - `Created snapshot for story X (age: Xh)`
   - `X stories processed, X snapshots created`

2. **instagram-sync**
   - `Found X stories from Instagram API`
   - `Created story insights snapshot during sync`

3. **story-mentions-state-worker**
   - `Created final insights snapshot for story X`
   - `Historia complet√≥ su ciclo de 24h (insights finales guardados)`

### Alertas Configurables

- Token expirado ‚Üí Reconectar cuenta
- Cron job falla ‚Üí Revisar logs
- Snapshot rate bajo ‚Üí Verificar conexi√≥n API
- Stories sin snapshots ‚Üí Investigar causa

---

## üìù Pr√≥ximos Pasos Sugeridos

### Opcional - Mejoras Adicionales

1. **Dashboard de Stories**
   - Visualizaci√≥n de evoluci√≥n temporal
   - Comparativas entre embajadores
   - M√©tricas agregadas por evento

2. **Alertas Inteligentes**
   - Story con alto rendimiento
   - Story con bajo engagement
   - Eliminaci√≥n temprana detectada

3. **An√°lisis Predictivo**
   - Proyecci√≥n de rendimiento final
   - Sugerencias de timing √≥ptimo
   - Identificaci√≥n de contenido efectivo

4. **Exportaci√≥n de Reportes**
   - CSV con evoluci√≥n de m√©tricas
   - PDF con an√°lisis comparativo
   - API para integraci√≥n externa

---

## ‚úÖ Conclusi√≥n

La implementaci√≥n est√° **COMPLETA** y **FUNCIONAL**:

- ‚úÖ Polling cada 2 horas con cron job
- ‚úÖ Stories vigentes (<24h) correctamente identificadas
- ‚úÖ Insights espec√≠ficos de Stories colectados
- ‚úÖ Snapshots persistidos en Supabase
- ‚úÖ M√∫ltiples fuentes de datos (polling, sync, webhook)
- ‚úÖ Snapshot final al expirar
- ‚úÖ Conforme con documentaci√≥n de Meta
- ‚úÖ API actualizada a v21.0
- ‚úÖ Arquitectura robusta y escalable

El sistema ahora captura la evoluci√≥n completa de las Stories durante su ciclo de vida de 24 horas, permitiendo an√°lisis detallados de rendimiento y engagement.

---

**Fecha de Implementaci√≥n:** 30 de octubre de 2025  
**Versi√≥n API Meta:** v21.0  
**Estado:** ‚úÖ Producci√≥n Lista
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

export default {
	darkMode: ["class"],
	content: [
		"./pages/**/*.{ts,tsx}",
		"./components/**/*.{ts,tsx}",
		"./app/**/*.{ts,tsx}",
		"./src/**/*.{ts,tsx}",
	],
	prefix: "",
	theme: {
		container: {
			center: true,
			padding: '2rem',
			screens: {
				'2xl': '1400px'
			}
		},
		extend: {
			fontFamily: {
				sans: ["Helvetica Neue", "Helvetica", "Arial", "ui-sans-serif", "system-ui", "sans-serif"],
			},
			colors: {
				border: 'hsl(var(--border))',
				input: 'hsl(var(--input))',
				ring: 'hsl(var(--ring))',
				background: 'hsl(var(--background))',
				foreground: 'hsl(var(--foreground))',
				primary: {
					DEFAULT: 'hsl(var(--primary))',
					foreground: 'hsl(var(--primary-foreground))',
					glow: 'hsl(var(--primary-glow))'
				},
				secondary: {
					DEFAULT: 'hsl(var(--secondary))',
					foreground: 'hsl(var(--secondary-foreground))'
				},
				destructive: {
					DEFAULT: 'hsl(var(--destructive))',
					foreground: 'hsl(var(--destructive-foreground))'
				},
				muted: {
					DEFAULT: 'hsl(var(--muted))',
					foreground: 'hsl(var(--muted-foreground))'
				},
				accent: {
					DEFAULT: 'hsl(var(--accent))',
					foreground: 'hsl(var(--accent-foreground))'
				},
				popover: {
					DEFAULT: 'hsl(var(--popover))',
					foreground: 'hsl(var(--popover-foreground))'
				},
				card: {
					DEFAULT: 'hsl(var(--card))',
					foreground: 'hsl(var(--card-foreground))'
				},
				success: {
					DEFAULT: 'hsl(var(--success))',
					foreground: 'hsl(var(--success-foreground))'
				},
				warning: {
					DEFAULT: 'hsl(var(--warning))',
					foreground: 'hsl(var(--warning-foreground))'
				},
				info: {
					DEFAULT: 'hsl(var(--info))',
					foreground: 'hsl(var(--info-foreground))'
				},
				sidebar: {
					DEFAULT: 'hsl(var(--sidebar-background))',
					foreground: 'hsl(var(--sidebar-foreground))',
					primary: 'hsl(var(--sidebar-primary))',
					'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
					accent: 'hsl(var(--sidebar-accent))',
					'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
					border: 'hsl(var(--sidebar-border))',
					ring: 'hsl(var(--sidebar-ring))'
				}
			},
			backgroundImage: {
				'gradient-primary': 'var(--gradient-primary)',
				'gradient-card': 'var(--gradient-card)',
				'gradient-border': 'var(--gradient-border)'
			},
			boxShadow: {
				'elegant': 'var(--shadow-elegant)',
				'glow': 'var(--shadow-glow)',
				'card': 'var(--shadow-card)'
			},
			transitionTimingFunction: {
				'smooth': 'var(--transition-smooth)',
				'bounce': 'var(--transition-bounce)'
			},
			borderRadius: {
				lg: 'var(--radius)',
				md: 'calc(var(--radius) - 2px)',
				sm: 'calc(var(--radius) - 4px)'
			},
			keyframes: {
				'accordion-down': {
					from: {
						height: '0'
					},
					to: {
						height: 'var(--radix-accordion-content-height)'
					}
				},
				'accordion-up': {
					from: {
						height: 'var(--radix-accordion-content-height)'
					},
					to: {
						height: '0'
					}
				}
			},
			animation: {
				'accordion-down': 'accordion-down 0.2s ease-out',
				'accordion-up': 'accordion-up 0.2s ease-out'
			}
		}
	},
	plugins: [require("tailwindcss-animate")],
} satisfies Config;
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": false,
    "noFallthroughCasesInSwitch": false,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vercel.json">
{
    "rewrites": [
      {
        "source": "/(.*)",
        "destination": "/index.html"
      }
    ]
  }
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => ({
  server: {
    host: "::",
    port: 8080,
  },
  plugins: [
    react(),
    mode === 'development' &&
    componentTagger(),
  ].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));
</file>

<file path="src/components/Ambassadors/AddAmbassadorModal.tsx">
import { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { User, Mail, Instagram, Building2 } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { InstagramConnect } from "@/components/Instagram/InstagramConnect";

interface AddAmbassadorModalProps {
  isOpen: boolean;
  onClose: () => void;
  onAmbassadorAdded: () => void;
}

interface AmbassadorFormData {
  first_name: string;
  last_name: string;
  email: string;
  instagram_user: string;
  organization_id: string;
}

interface Organization {
  id: string;
  name: string;
}

export default function AddAmbassadorModal({ isOpen, onClose, onAmbassadorAdded }: AddAmbassadorModalProps) {
  const [formData, setFormData] = useState<AmbassadorFormData>({
    first_name: "",
    last_name: "",
    email: "",
    instagram_user: "",
    organization_id: ""
  });

  const [organizations, setOrganizations] = useState<Organization[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (isOpen) {
      fetchOrganizations();
    }
  }, [isOpen]);

  const fetchOrganizations = async () => {
    try {
      const { data, error } = await supabase
        .from('organizations')
        .select('id, name')
        .order('name');

      if (error) {
        console.error('Error fetching organizations:', error);
        toast.error('Error al cargar organizaciones');
        return;
      }
      
      setOrganizations(data || []);
    } catch (error) {
      console.error('Error al obtener organizaciones:', error);
      setOrganizations([]);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      // Validaciones b‡∏£‡∏Åsicas
      if (!formData.first_name || !formData.last_name || !formData.email || !formData.instagram_user || !formData.organization_id) {
        toast.error('Todos los campos obligatorios deben estar completos');
        return;
      }

      // Validar formato de email
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(formData.email)) {
        toast.error('El formato del email no es v‡∏£‡∏Ålido');
        return;
      }

      // Validar que el usuario de Instagram no comience con @
      const instagramUser = formData.instagram_user.startsWith('@') 
        ? formData.instagram_user.slice(1) 
        : formData.instagram_user;

      // Crear el embajador directamente en Supabase
      const ambassadorData = {
        first_name: formData.first_name,
        last_name: formData.last_name,
        email: formData.email,
        instagram_user: instagramUser,
        organization_id: formData.organization_id,
        status: 'active'
      };

      console.log('Creando embajador con datos:', ambassadorData);

      const { data: newAmbassador, error: ambassadorError } = await supabase
        .from('embassadors')
        .insert(ambassadorData)
        .select()
        .single();

      if (ambassadorError) {
        console.error('Error creating ambassador:', ambassadorError);
        toast.error('Error al crear embajador: ' + ambassadorError.message);
        return;
      }

      toast.success('Embajador creado exitosamente');
      resetForm();
      onClose();
      onAmbassadorAdded();
    } catch (error) {
      console.error('Error creating ambassador:', error);
      toast.error('Error al crear embajador');
    } finally {
      setLoading(false);
    }
  };

  const resetForm = () => {
    setFormData({
      first_name: "",
      last_name: "",
      email: "",
      instagram_user: "",
      organization_id: ""
    });
  };

  const handleInstagramChange = (value: string) => {
    // Auto-agregar @ si no est‡∏£‡∏Å presente
    const cleanValue = value.replace('@', '');
    setFormData({ ...formData, instagram_user: cleanValue });
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Agregar Nuevo Embajador</DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-6">
          {/* Selecci‡∏£‡∏ìn de Organizaci‡∏£‡∏ìn */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium flex items-center gap-2">
              <Building2 className="w-5 h-5" />
              Organizaci‡∏£‡∏ìn
            </h3>
            
            <div>
              <Label htmlFor="organization_id">Seleccionar Organizaci‡∏£‡∏ìn/Fiesta *</Label>
              <Select 
                value={formData.organization_id} 
                onValueChange={(value) => setFormData({ ...formData, organization_id: value })}
                required
              >
                <SelectTrigger>
                  <SelectValue placeholder="Selecciona una organizaci‡∏£‡∏ìn..." />
                </SelectTrigger>
                <SelectContent>
                  {organizations.map((org) => (
                    <SelectItem key={org.id} value={org.id}>
                      {org.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Informaci‡∏£‡∏ìn Personal */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium">Informaci‡∏£‡∏ìn Personal</h3>
            
            <div className="grid grid-cols-2 gap-4">
              <div>
                <Label htmlFor="first_name">Nombre *</Label>
                <div className="relative">
                  <User className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
                  <Input
                    id="first_name"
                    value={formData.first_name}
                    onChange={(e) => setFormData({ ...formData, first_name: e.target.value })}
                    placeholder="Nombre"
                    className="pl-10"
                    required
                  />
                </div>
              </div>
              <div>
                <Label htmlFor="last_name">Apellido *</Label>
                <Input
                  id="last_name"
                  value={formData.last_name}
                  onChange={(e) => setFormData({ ...formData, last_name: e.target.value })}
                  placeholder="Apellido"
                  required
                />
              </div>
            </div>

            <div>
              <Label htmlFor="email">Email *</Label>
              <div className="relative">
                <Mail className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
                <Input
                  id="email"
                  type="email"
                  value={formData.email}
                  onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                  placeholder="email@ejemplo.com"
                  className="pl-10"
                  required
                />
              </div>
            </div>

            <div>
              <Label htmlFor="instagram_user">Usuario de Instagram *</Label>
              <div className="relative">
                <Instagram className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
                <div className="absolute left-8 top-3 text-muted-foreground">@</div>
                <Input
                  id="instagram_user"
                  value={formData.instagram_user}
                  onChange={(e) => handleInstagramChange(e.target.value)}
                  placeholder="usuario"
                  className="pl-12"
                  required
                />
              </div>
            </div>

            {/* Instagram Connection */}
            <div>
              <Label>Conexi‡∏£‡∏ìn Instagram (Opcional)</Label>
              <p className="text-sm text-muted-foreground">
                Podr‡∏£‡∏Ås conectar la cuenta de Instagram del embajador despu‡∏£‡∏âs de crearlo, desde el dashboard.
              </p>
            </div>
          </div>

          <div className="flex justify-end gap-2 pt-4 border-t">
            <Button type="button" variant="outline" onClick={onClose} disabled={loading}>
              Cancelar
            </Button>
            <Button type="submit" disabled={loading}>
              {loading ? 'Creando...' : 'Agregar Embajador'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Dashboard/SimpleDashboardContent.tsx">
import { useState, useEffect, useCallback } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Building2, Calendar, Users, Activity } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useAuth } from "@/hooks/useAuth";
import { toast } from "sonner";
import { AmbassadorRanking } from "./AmbassadorRanking";

interface DashboardStats {
  totalOrganizations: number;
  totalEvents: number;
  totalAmbassadors: number;
}

export function SimpleDashboardContent() {
  const { user } = useAuth();
  const [stats, setStats] = useState<DashboardStats>({
    totalOrganizations: 0,
    totalEvents: 0,
    totalAmbassadors: 0
  });
  const [loading, setLoading] = useState(true);

  const fetchDashboardStats = useCallback(async () => {
    try {
      setLoading(true);

      // Obtener organizaciones del usuario
      const { data: organizations, error: orgError } = await supabase
        .from('organizations')
        .select('id')
        .eq('created_by', user!.id);

      if (orgError) throw orgError;

      const organizationIds = organizations?.map(org => org.id) || [];
      
      // Obtener eventos de las organizaciones del usuario
      let totalEvents = 0;
      let totalAmbassadors = 0;

      if (organizationIds.length > 0) {
        const { data: fiestas, error: fiestasError } = await supabase
          .from('fiestas')
          .select('id')
          .in('organization_id', organizationIds);

        if (fiestasError) throw fiestasError;
        totalEvents = fiestas?.length || 0;

        const { data: ambassadors, error: ambassadorsError } = await supabase
          .from('embassadors')
          .select('id')
          .in('organization_id', organizationIds);

        if (ambassadorsError) throw ambassadorsError;
        totalAmbassadors = ambassadors?.length || 0;
      }

      setStats({
        totalOrganizations: organizations?.length || 0,
        totalEvents,
        totalAmbassadors
      });

    } catch (error) {
      console.error('Error fetching dashboard stats:', error);
      toast.error('Error al cargar estad√≠sticas del dashboard');
    } finally {
      setLoading(false);
    }
  }, [user]);

  useEffect(() => {
    if (user) {
      fetchDashboardStats();
    }
  }, [user, fetchDashboardStats]);

  const StatCard = ({ title, value, icon: Icon, description }: {
    title: string;
    value: number;
    icon: React.ComponentType<{ className?: string }>;
    description: string;
  }) => (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">{title}</CardTitle>
        <Icon className="h-4 w-4 text-muted-foreground" />
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{loading ? '...' : value}</div>
        <p className="text-xs text-muted-foreground">{description}</p>
      </CardContent>
    </Card>
  );

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-3xl font-bold tracking-tight">Dashboard</h2>
        <p className="text-muted-foreground">
          Resumen de tu actividad en el sistema EVA
        </p>
      </div>

      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        <StatCard
          title="Organizaciones"
          value={stats.totalOrganizations}
          icon={Building2}
          description="Productoras registradas"
        />
        <StatCard
          title="Eventos"
          value={stats.totalEvents}
          icon={Calendar}
          description="Fiestas organizadas"
        />
        <StatCard
          title="Embajadores"
          value={stats.totalAmbassadors}
          icon={Users}
          description="Personas registradas"
        />
        <StatCard
          title="Sistema"
          value={1}
          icon={Activity}
          description="EVA funcionando"
        />
      </div>

      {stats.totalOrganizations === 0 && !loading && (
        <Card>
          <CardContent className="p-6">
            <div className="text-center">
              <Building2 className="h-12 w-12 mx-auto text-muted-foreground mb-4" />
              <h3 className="text-lg font-semibold mb-2">¬°Bienvenido a EVA!</h3>
              <p className="text-muted-foreground mb-4">
                Para comenzar, crea tu primera organizaci√≥n o productora de eventos.
              </p>
            </div>
          </CardContent>
        </Card>
      )}

      {stats.totalOrganizations > 0 && (
        <AmbassadorRanking />
      )}
    </div>
  );
}
</file>

<file path="src/components/Instagram/InstagramConnect.tsx">
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Instagram, Loader2, CheckCircle, AlertCircle } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { useAuth } from "@/hooks/useAuth";

interface InstagramConnectProps {
  type: "ambassador" | "organization";
  /** For ambassadors: ambassador.id. For org: organization.id */
  entityId: string;
  /** Optional explicit org id; if not provided, we‚Äôll fall back to entityId for org flow */
  organizationId?: string;
  currentStatus?: {
    isConnected: boolean;
    username?: string;
    followerCount?: number;
    lastSync?: string;
  };
  onConnectionChange?: () => void;
}

export function InstagramConnect({
  type,
  entityId,
  organizationId,
  currentStatus = { isConnected: false },
  onConnectionChange,
}: InstagramConnectProps) {
  const [isConnecting, setIsConnecting] = useState(false);
  const { user } = useAuth();

  const handleConnect = async () => {
    try {
      setIsConnecting(true);

      if (!user) {
        toast.error("Debes iniciar sesi√≥n para conectar Instagram");
        return;
      }

      // Determine which organization we‚Äôre acting on
      const orgId = organizationId ?? (type === "organization" ? entityId : undefined);
      if (!orgId) {
        toast.error("No se encontr√≥ la organizaci√≥n asociada");
        return;
      }

      // Build body according to the new edge function contract
      const body: any = {
        type,
        organization_id: orgId,
        // If you ever want a custom UI redirect after success:
        // redirect_base: "https://app.evasystem.cl/ambassadors",
      };

      if (type === "ambassador") {
        body.ambassador_id = entityId;
      }

      console.log("Initiating Instagram connection", {
        type,
        orgId,
        ambassador_id: body.ambassador_id,
      });

      const { data, error } = await supabase.functions.invoke(
        "meta-oauth?action=authorize",
        { body }
      );

      if (error) {
        console.error("Supabase function error:", error);
        let errorMessage = "Error al conectar con Instagram";

        if (error.message?.includes("configuration_error") || error.message?.includes("credentials")) {
          errorMessage =
            "Credenciales de Meta no configuradas. Aseg√∫rate de configurar la app de Meta y el redirect URI: https://app.evasystem.cl/api/meta-oauth?action=callback";
        } else if (error.message?.includes("redirect_uri")) {
          errorMessage =
            "URI de redirecci√≥n no v√°lida. A√±ade esta URL en Meta Developers: https://app.evasystem.cl/api/meta-oauth?action=callback";
        } else if (error.message?.toLowerCase().includes("forbidden")) {
          errorMessage =
            "No tienes permisos para conectar esta organizaci√≥n. Verifica que seas miembro activo.";
        }

        throw new Error(errorMessage);
      }

      if (data?.authUrl) {
        console.log("Redirecting to Instagram OAuth:", data.authUrl);
        window.location.href = data.authUrl;
      } else {
        console.error("No authUrl in response:", data);
        const msg =
          data?.error_description ||
          "No se pudo generar la URL de autorizaci√≥n. Verifica la configuraci√≥n de Meta.";
        throw new Error(msg);
      }
    } catch (err) {
      console.error("Error connecting Instagram:", err);
      const message = err instanceof Error ? err.message : "Error al conectar con Instagram";
      toast.error(message);
      setIsConnecting(false);
    }
  };

  if (currentStatus.isConnected) {
    return (
      <div className="flex items-center gap-2 p-3 border rounded-lg bg-green-50 dark:bg-green-900/20">
        <CheckCircle className="w-4 h-4 text-green-600" />
        <div className="flex-1">
          <div className="flex items-center gap-2">
            <Instagram className="w-4 h-4" />
            {currentStatus.username ? (
              <span className="font-medium">@{currentStatus.username}</span>
            ) : (
              <span className="font-medium">Cuenta conectada</span>
            )}
            {currentStatus.followerCount != null && (
              <Badge variant="secondary">
                {currentStatus.followerCount.toLocaleString()} seguidores
              </Badge>
            )}
          </div>
          {currentStatus.lastSync && (
            <p className="text-sm text-muted-foreground">
              √öltima sincronizaci√≥n:{" "}
              {new Date(currentStatus.lastSync).toLocaleDateString()}
            </p>
          )}
        </div>
        <Button size="sm" variant="outline" onClick={handleConnect} disabled={isConnecting}>
          {isConnecting ? <Loader2 className="w-4 h-4 animate-spin" /> : "Reconectar"}
        </Button>
      </div>
    );
  }

  return (
    <div className="flex items-center gap-2 p-3 border rounded-lg border-dashed">
      <AlertCircle className="w-4 h-4 text-orange-500" />
      <div className="flex-1">
        <p className="font-medium">Instagram no conectado</p>
        <p className="text-sm text-muted-foreground">
          {type === "ambassador"
            ? "Conecta la cuenta de Instagram del embajador para sincronizar datos autom√°ticamente."
            : "Conecta la cuenta business de Instagram de la organizaci√≥n para gestionar contenido."}
        </p>
      </div>
      <Button onClick={handleConnect} disabled={isConnecting} className="gap-2">
        {isConnecting ? (
          <Loader2 className="w-4 h-4 animate-spin" />
        ) : (
          <Instagram className="w-4 h-4" />
        )}
        {isConnecting ? "Conectando..." : "Conectar Instagram"}
      </Button>
    </div>
  );
}
</file>

<file path="src/hooks/useAmbassadorInstagramStatus.ts">
import { useEffect, useState } from "react";
import { supabase } from "@/integrations/supabase/client";

export function useAmbassadorInstagramStatus(ambassadorId: string | null) {
    const [status, setStatus] = useState({
      isConnected: false,
      username: undefined as string | undefined,
      followerCount: undefined as number | undefined,
      lastSync: undefined as string | undefined,
    });
  
    useEffect(() => {
      if (!ambassadorId) return; // nothing to do yet
  
      let cancelled = false;
  
      async function load() {
        // 1) check ambassador_tokens
        const { data: tokenRow, error: tokenError } = await supabase
          .from("ambassador_tokens")
          .select("token_expiry")
          .eq("embassador_id", ambassadorId)
          .maybeSingle();
  
        if (tokenError || !tokenRow) {
          if (!cancelled) setStatus(prev => ({ ...prev, isConnected: false }));
          return;
        }
  
        // 2) read public info from embassadors
        const { data: ambassador, error: ambError } = await supabase
          .from("embassadors")
          .select("instagram_user, follower_count, last_instagram_sync")
          .eq("id", ambassadorId)
          .maybeSingle();
  
        if (!cancelled) {
          setStatus({
            isConnected: true,
            username: ambassador?.instagram_user ?? undefined,
            followerCount: ambassador?.follower_count ?? undefined,
            lastSync: ambassador?.last_instagram_sync ?? undefined,
          });
        }
      }
  
      load();
  
      return () => {
        cancelled = true;
      };
    }, [ambassadorId]);
  
    return status;
  }
</file>

<file path="src/hooks/useAmbassadorMetrics.ts">
import { useState, useEffect, useCallback } from "react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

interface AmbassadorMetrics {
  id: string;
  name: string;
  instagram_user: string;
  email: string;
  status: string;
  global_points: number;
  global_category: string;
  performance_status: string;
  events_participated: number;
  completed_tasks: number;
  failed_tasks: number;
  follower_count: number;
  total_reach: number;
  avg_engagement: number;
  completion_rate: number;
  last_activity: string | null;
  monthly_performance: Array<{
    month: string;
    points: number;
    tasks: number;
    reach: number;
  }>;
  recent_activities: Array<{
    date: string;
    type: string;
    description: string;
    points?: number;
    status?: string;
  }>;
  story_insights?: {
    total_stories: number;
    total_reach: number;
    total_impressions: number;
    total_engagement: number; // replies + shares
    avg_reach_per_story: number;
    avg_impressions_per_story: number;
    total_replies: number;
    total_shares: number;
  };
  insights_error?: boolean; // Flag to indicate if insights failed to load
}

export function useAmbassadorMetrics(ambassadorId?: string) {
  const [metrics, setMetrics] = useState<AmbassadorMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchAmbassadorMetrics = useCallback(async () => {
    if (!ambassadorId) return;

    try {
      setLoading(true);
      setError(null);

      // Fetch ambassador basic info and stats
      const { data: ambassador, error: ambassadorError } = await supabase
        .from('embassadors')
        .select('id, first_name, last_name, email, instagram_user, instagram_user_id, follower_count, profile_picture_url, date_of_birth, rut, global_points, global_category, performance_status, events_participated, completed_tasks, failed_tasks, organization_id, created_by_user_id, status, profile_public, last_instagram_sync, created_at')
        .eq('id', ambassadorId)
        .single();

      if (ambassadorError) throw ambassadorError;

      // Fetch tasks for this ambassador
      const { data: tasks } = await supabase
        .from('tasks')
        .select(`
          id,
          status,
          points_earned,
          reach_count,
          engagement_score,
          created_at,
          task_type,
          events (name)
        `)
        .eq('embassador_id', ambassadorId);

      // Fetch story insights for this ambassador (wrapped in try-catch to not break main flow)
      let storyInsights: AmbassadorMetrics['story_insights'] = undefined;
      let insightsErrorFlag = false;

      try {
        // First get social mentions for this ambassador
        const { data: socialMentions, error: mentionsError } = await supabase
          .from('social_mentions')
          .select('id, instagram_story_id')
          .eq('matched_ambassador_id', ambassadorId)
          .eq('mention_type', 'story_referral');

        if (mentionsError) {
          insightsErrorFlag = true;
          console.warn('Error fetching social mentions for story insights:', mentionsError);
        } else if (socialMentions && socialMentions.length > 0) {
          // Then fetch story insights for those mentions
          const mentionIds = socialMentions.map(m => m.id);
          
          // Use type assertion since story_insights_snapshots may not be in generated types yet
          // We'll cast to any to bypass type checking for this table
          interface StoryInsightSnapshot {
            id: string;
            social_mention_id: string;
            reach: number;
            impressions: number;
            replies: number;
            shares: number;
            snapshot_at: string;
          }
          
          // Cast through unknown first to avoid type errors
          const { data: storyInsightsData, error: insightsError } = await (supabase as unknown as {
            from: (table: string) => {
              select: (columns: string) => {
                in: (column: string, values: string[]) => {
                  order: (column: string, options: { ascending: boolean }) => Promise<{
                    data: StoryInsightSnapshot[] | null;
                    error: Error | null;
                  }>;
                };
              };
            };
          })
            .from('story_insights_snapshots')
            .select(`
              id,
              social_mention_id,
              reach,
              impressions,
              replies,
              shares,
              snapshot_at
            `)
            .in('social_mention_id', mentionIds)
            .order('snapshot_at', { ascending: false });

          if (insightsError) {
            insightsErrorFlag = true;
            console.warn('Error fetching story insights:', insightsError);
          } else if (storyInsightsData && storyInsightsData.length > 0) {
            // Create a map of mention_id -> story_id
            const mentionToStoryMap = new Map<string, string>();
            socialMentions.forEach(mention => {
              if (mention.instagram_story_id) {
                mentionToStoryMap.set(mention.id, mention.instagram_story_id);
              }
            });

            // Group by story ID and get latest snapshot for each
            const storyMap = new Map<string, typeof storyInsightsData[0]>();
            
            storyInsightsData.forEach(snapshot => {
              const storyId = mentionToStoryMap.get(snapshot.social_mention_id) || snapshot.social_mention_id;
              if (!storyMap.has(storyId)) {
                storyMap.set(storyId, snapshot);
              } else {
                // Keep the latest snapshot
                const existing = storyMap.get(storyId)!;
                if (new Date(snapshot.snapshot_at) > new Date(existing.snapshot_at)) {
                  storyMap.set(storyId, snapshot);
                }
              }
            });

            // Aggregate metrics from latest snapshots
            const latestSnapshots = Array.from(storyMap.values());
            const totalReach = latestSnapshots.reduce((sum, s) => sum + (s.reach || 0), 0);
            const totalImpressions = latestSnapshots.reduce((sum, s) => sum + (s.impressions || 0), 0);
            const totalReplies = latestSnapshots.reduce((sum, s) => sum + (s.replies || 0), 0);
            const totalShares = latestSnapshots.reduce((sum, s) => sum + (s.shares || 0), 0);
            const totalEngagement = totalReplies + totalShares;
            const storyCount = latestSnapshots.length;

            storyInsights = {
              total_stories: storyCount,
              total_reach: totalReach,
              total_impressions: totalImpressions,
              total_engagement: totalEngagement,
              avg_reach_per_story: storyCount > 0 ? Math.round(totalReach / storyCount) : 0,
              avg_impressions_per_story: storyCount > 0 ? Math.round(totalImpressions / storyCount) : 0,
              total_replies: totalReplies,
              total_shares: totalShares
            };
          }
        }
      } catch (insightsErr) {
        // Story insights failed but don't break the main metrics
        insightsErrorFlag = true;
        console.warn('Error processing story insights:', insightsErr);
      }

      // Calculate metrics
      const totalReach = tasks?.reduce((sum, t) => sum + (t.reach_count || 0), 0) || 0;
      const avgEngagement = tasks?.length > 0 
        ? tasks.reduce((sum, t) => sum + (t.engagement_score || 0), 0) / tasks.length 
        : 0;
      const completionRate = ambassador.completed_tasks + ambassador.failed_tasks > 0
        ? (ambassador.completed_tasks / (ambassador.completed_tasks + ambassador.failed_tasks)) * 100
        : 0;

      // Generate monthly performance (last 6 months)
      const monthlyPerformance = generateMonthlyPerformance(tasks || []);

      // Generate recent activities
      // Map tasks to ensure events type is correct
      const tasksWithTypedEvents = (tasks || []).map(task => {
        const taskEvents = task.events;
        let typedEvents: { name: string } | null = null;
        
        if (taskEvents && typeof taskEvents === 'object' && !Array.isArray(taskEvents)) {
          const eventsObj = taskEvents as Record<string, unknown>;
          if ('name' in eventsObj) {
            typedEvents = { name: String(eventsObj.name || 'N/A') };
          }
        }
        
        return {
          ...task,
          events: typedEvents
        };
      });
      const recentActivities = generateRecentActivities(tasksWithTypedEvents, ambassador);

      // Find last activity
      const lastActivity = tasks?.length > 0 
        ? tasks.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())[0].created_at
        : null;

      const metricsData: AmbassadorMetrics = {
        id: ambassador.id,
        name: `${ambassador.first_name} ${ambassador.last_name}`,
        instagram_user: ambassador.instagram_user,
        email: ambassador.email,
        status: ambassador.status,
        global_points: ambassador.global_points || 0,
        global_category: ambassador.global_category || 'bronze',
        performance_status: ambassador.performance_status || 'cumple',
        events_participated: ambassador.events_participated || 0,
        completed_tasks: ambassador.completed_tasks || 0,
        failed_tasks: ambassador.failed_tasks || 0,
        follower_count: ambassador.follower_count || 0,
        total_reach: totalReach,
        avg_engagement: Number(avgEngagement.toFixed(1)),
        completion_rate: Number(completionRate.toFixed(1)),
        last_activity: lastActivity,
        monthly_performance: monthlyPerformance,
        recent_activities: recentActivities,
        story_insights: storyInsights,
        insights_error: insightsErrorFlag
      };

      setMetrics(metricsData);

    } catch (err) {
      console.error('Error fetching ambassador metrics:', err);
       toast.error('Error al cargar m√©tricas');
    } finally {
      setLoading(false);
    }
    // generateRecentActivities is a pure function, doesn't need to be in deps
  }, [ambassadorId]);

  useEffect(() => {
    if (ambassadorId) {
      fetchAmbassadorMetrics();
    }
  }, [ambassadorId, fetchAmbassadorMetrics]);

  const generateMonthlyPerformance = (tasks: Array<{
    created_at: string;
    points_earned?: number;
    reach_count?: number;
  }>) => {
    const monthlyData = new Map();
    const now = new Date();

    // Initialize last 6 months
    for (let i = 5; i >= 0; i--) {
      const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
      const key = date.toISOString().slice(0, 7); // YYYY-MM format
      monthlyData.set(key, { 
        month: date.toLocaleDateString('es-ES', { month: 'short', year: 'numeric' }),
        points: 0,
        tasks: 0,
        reach: 0
      });
    }

    // Populate with task data
    tasks.forEach(task => {
      const taskDate = new Date(task.created_at);
      const key = taskDate.toISOString().slice(0, 7);
      
      if (monthlyData.has(key)) {
        const monthData = monthlyData.get(key);
        monthData.points += task.points_earned || 0;
        monthData.tasks += 1;
        monthData.reach += task.reach_count || 0;
      }
    });

    return Array.from(monthlyData.values());
  };

  const generateRecentActivities = (tasks: Array<{
    created_at: string;
    task_type: string;
    points_earned?: number;
    status: string;
    events?: { name: string } | null;
  }>, ambassador: {
    first_name: string;
    last_name: string;
  }) => {
    const activities = [];

    // Add task activities
    tasks.slice(0, 10).forEach(task => {
      activities.push({
        date: task.created_at,
        type: getTaskTypeLabel(task.task_type),
        description: `${getTaskTypeLabel(task.task_type)} para evento ${task.events?.name || 'N/A'}`,
        points: task.points_earned,
        status: task.status
      });
    });

    // Sort by date (most recent first)
    activities.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

    return activities.slice(0, 10);
  };

  const getTaskTypeLabel = (type: string) => {
    const labels: Record<string, string> = {
      'story': 'Historia',
      'post': 'Publicaci√≥n',
      'mention': 'Menci√≥n',
      'hashtag': 'Hashtag'
    };
    return labels[type] || type;
  };

  return {
    metrics,
    loading,
    error,
    refreshMetrics: fetchAmbassadorMetrics
  };
}
</file>

<file path="src/hooks/useOnboardingStatus.ts">
import { useState, useEffect } from "react";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { supabase } from "@/integrations/supabase/client";

interface OnboardingStep {
  id: string;
  title: string;
  description: string;
  completed: boolean;
  required: boolean; // true = obligatorio, false = recomendado
}

export function useOnboardingStatus() {
  const { organization, loading } = useCurrentOrganization();
  const [steps, setSteps] = useState<OnboardingStep[]>([]);
  const [overallProgress, setOverallProgress] = useState(0);
  const [canAccessDashboard, setCanAccessDashboard] = useState(false);

  useEffect(() => {
    if (loading) return;
    
    checkOnboardingStatus();
  }, [organization, loading]);

  const checkOnboardingStatus = async () => {
    if (!organization) {
      // No hay organizaci√≥n, el usuario necesita crearla
      const initialSteps: OnboardingStep[] = [
        {
          id: "organization",
          title: "Crear Organizaci√≥n",
          description: "Configura tu productora de eventos",
          completed: false,
          required: true
        },
        {
          id: "instagram",
          title: "Conectar Instagram (Opcional)",
          description: "Vincula tu cuenta business de Instagram",
          completed: false,
          required: false
        },
        {
          id: "fiesta",
          title: "Crear Primera Fiesta (Opcional)",
          description: "Configura tu primer evento",
          completed: false,
          required: false
        },
        {
          id: "ambassadors",
          title: "A√±adir Embajadores (Opcional)",
          description: "Invita a tus primeros embajadores",
          completed: false,
          required: false
        }
      ];
      
      setSteps(initialSteps);
      setOverallProgress(0);
      setCanAccessDashboard(false);
      return;
    }

    // Verificar el estado de cada paso
    const orgCompleted = organization.name !== "Mi Organizaci√≥n";
    
    // Verificar Instagram - check multiple indicators
    let instagramCompleted = false;
    try {
      // Method 1: Check if organization has Instagram business account linked
      if (organization.instagram_business_account_id) {
        instagramCompleted = true;
      }
      
      // Method 2: If not found via org data, check token status directly
      if (!instagramCompleted) {
        const { data: tokenStatus } = await supabase.functions.invoke('instagram-token-status');
        if (tokenStatus?.success && tokenStatus?.data?.isConnected) {
          instagramCompleted = true;
        }
      }
      
      // Method 3: Check if there's a valid token in the tokens table
      if (!instagramCompleted) {
        const { data: tokenData } = await supabase
          .from('organization_instagram_tokens')
          .select('id, token_expiry')
          .eq('organization_id', organization.id)
          .maybeSingle();
        
        if (tokenData && tokenData.token_expiry) {
          const expiryDate = new Date(tokenData.token_expiry);
          instagramCompleted = expiryDate > new Date();
        }
      }
    } catch (error) {
      console.error('Error checking Instagram status:', error);
    }

    // Verificar fiestas
    let fiestaCompleted = false;
    try {
      const { data: fiestas, error } = await supabase
        .from('fiestas')
        .select('id')
        .eq('organization_id', organization.id)
        .limit(1);
      
      fiestaCompleted = !error && (fiestas?.length || 0) > 0;
    } catch (error) {
      console.error('Error checking fiestas:', error);
    }

    // Verificar embajadores
    let ambassadorsCompleted = false;
    try {
      const { data: ambassadors, error } = await supabase
        .from('embassadors')
        .select('id')
        .eq('organization_id', organization.id)
        .limit(1);
      
      ambassadorsCompleted = !error && (ambassadors?.length || 0) > 0;
    } catch (error) {
      console.error('Error checking ambassadors:', error);
    }

    const updatedSteps: OnboardingStep[] = [
      {
        id: "organization",
        title: "Organizaci√≥n Lista",
        description: "Configura tu productora de eventos",
        completed: orgCompleted,
        required: true
      },
      {
        id: "instagram",
        title: "Conectar Instagram (Opcional)",
        description: "Vincula tu cuenta business de Instagram",
        completed: instagramCompleted,
        required: false
      },
      {
        id: "fiesta",
        title: "Crear Primera Fiesta (Opcional)",
        description: "Configura tu primer evento",
        completed: fiestaCompleted,
        required: false
      },
      {
        id: "ambassadors",
        title: "A√±adir Embajadores (Opcional)",
        description: "Invita a tus primeros embajadores",
        completed: ambassadorsCompleted,
        required: false
      }
    ];

    setSteps(updatedSteps);
    
    // Calcular progreso
    const completedSteps = updatedSteps.filter(step => step.completed).length;
    const progress = (completedSteps / updatedSteps.length) * 100;
    setOverallProgress(progress);
    
    // Puede acceder al dashboard si complet√≥ los pasos obligatorios
    const requiredStepsCompleted = updatedSteps
      .filter(step => step.required)
      .every(step => step.completed);
    
    setCanAccessDashboard(requiredStepsCompleted);
  };

  const refreshOnboardingStatus = () => {
    checkOnboardingStatus();
  };

  return {
    steps,
    overallProgress,
    canAccessDashboard,
    loading,
    refreshOnboardingStatus
  };
}
</file>

<file path="src/hooks/useUserProfile.ts">
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useAuth } from "./useAuth";
import { toast } from "sonner";

interface UserProfile {
  id: string;
  name: string;
  full_name: string | null;
  email: string;
  role: 'admin' | 'user' | 'viewer';
  organization_id: string | null;
  last_login: string | null;
  created_at: string;
  organization?: {
    id: string;
    name: string;
    description: string | null;
    timezone: string;
    logo_url: string | null;
    plan_type: string;
    instagram_connected: boolean;
  } | null;
}

export function useUserProfile() {
  const { user } = useAuth();
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (user) {
      fetchUserProfile();
    } else {
      setProfile(null);
      setLoading(false);
      setError(null);
    }
  }, [user]);

  const retryFetch = () => {
    setError(null);
    fetchUserProfile();
  };

  const fetchUserProfile = async () => {
    if (!user) return;

    try {
      setLoading(true);
      setError(null);

      // First, get user profile without nested organization query
      const { data, error: fetchError } = await supabase
        .from('users')
        .select(`
          id, 
          name, 
          full_name,
          email, 
          role,
          organization_id, 
          last_login,
          created_at
        `)
        .eq('auth_user_id', user.id)
        .maybeSingle();

      if (fetchError) {
        console.error('Error fetching user profile:', fetchError);
        setError('Error al obtener datos del usuario');
        return;
      }

      if (!data) {
        // Auto-create user profile if it doesn't exist
        console.log('User profile not found, creating one...');
        // Create user profile without nested organization query
        const { data: createdUser, error: createError } = await supabase
          .from('users')
          .insert({
            auth_user_id: user.id,
            name: user.user_metadata?.full_name || user.email?.split('@')[0] || 'Usuario',
            email: user.email || '',
            full_name: user.user_metadata?.full_name || null,
            role: 'user'
          })
          .select(`
            id, 
            name, 
            full_name,
            email, 
            role,
            organization_id, 
            last_login,
            created_at
          `)
          .single();

        if (createError) {
          console.error('Error creating user profile:', createError);
          setError('Error al crear el perfil de usuario. Por favor, contacta al soporte.');
          return;
        }

        if (createdUser) {
          // Auto-create default organization for new user
          const { data: orgData, error: orgError } = await supabase
            .from('organizations')
            .insert({
              name: 'Mi Organizaci√≥n',
              description: `Organizaci√≥n de ${createdUser.name}`,
              created_by: user.id
            })
            .select()
            .single();

          if (orgError) {
            console.error('Error creating organization:', orgError);
          } else if (orgData) {
            // Update user with organization_id
            const { data: updatedUser, error: updateError } = await supabase
              .from('users')
              .update({ organization_id: orgData.id })
              .eq('id', createdUser.id)
              .select()
              .single();

            if (!updateError && updatedUser) {
              const profileData: UserProfile = {
                ...updatedUser,
                role: updatedUser.role as 'admin' | 'user' | 'viewer',
                organization: {
                  id: orgData.id,
                  name: orgData.name,
                  description: orgData.description,
                  timezone: orgData.timezone || 'America/Santiago',
                  logo_url: orgData.logo_url,
                  plan_type: orgData.plan_type || 'free',
                  instagram_connected: !!orgData.meta_token
                }
              };
              setProfile(profileData);
              toast.success('Perfil de usuario y organizaci√≥n creados exitosamente');
              return;
            }
          }

          // Fallback if organization creation fails
          const profileData: UserProfile = {
            ...createdUser,
            role: createdUser.role as 'admin' | 'user' | 'viewer',
            organization: null
          };
          setProfile(profileData);
          toast.success('Perfil de usuario creado exitosamente');
        }
        return;
      }

      // If user exists but doesn't have organization_id assigned, check if they have organizations
      if (!data.organization_id) {
        console.log('User exists but no organization assigned, checking for available organizations...');
        
        const { data: userOrganizations, error: orgError } = await supabase
          .from('organizations')
          .select('id, name')
          .eq('created_by', user.id)
          .order('created_at', { ascending: false })
          .limit(1);

        if (orgError) {
          console.error('Error fetching user organizations:', orgError);
        } else if (userOrganizations && userOrganizations.length > 0) {
          // Auto-assign the first organization found
          const firstOrg = userOrganizations[0];
          console.log('Auto-assigning organization:', firstOrg.name);
          
          const { data: updatedUser, error: updateError } = await supabase
            .from('users')
            .update({ organization_id: firstOrg.id })
            .eq('auth_user_id', user.id)
            .select(`
              id, 
              name, 
              full_name,
              email, 
              role,
              organization_id, 
              last_login,
              created_at
            `)
            .single();

          if (updateError) {
            console.error('Error updating user organization:', updateError);
          } else if (updatedUser) {
            // Fetch organization info separately
            const { data: orgInfo } = await supabase
              .rpc('get_organization_safe_info', { org_id: firstOrg.id });

            const orgData = orgInfo?.[0];
            const profileData: UserProfile = {
              ...updatedUser,
              role: updatedUser.role as 'admin' | 'user' | 'viewer',
              organization: orgData ? {
                id: orgData.id,
                name: orgData.name,
                description: orgData.description,
                timezone: orgData.timezone,
                logo_url: orgData.logo_url,
                plan_type: orgData.plan_type,
                instagram_connected: orgData.instagram_connected
              } : null
            };
            setProfile(profileData);
            toast.success(`Organizaci√≥n "${firstOrg.name}" asignada autom√°ticamente`);
            return;
          }
        } else {
          // No organizations found - create one automatically (fallback for users created before trigger fix)
          console.log('No organizations found, creating default organization...');
          
          const { data: newOrg, error: createOrgError } = await supabase
            .from('organizations')
            .insert({
              name: 'Mi Organizaci√≥n',
              description: `Organizaci√≥n de ${data.name}`,
              created_by: user.id,
              timezone: 'America/Santiago',
              plan_type: 'free'
            })
            .select()
            .single();

          if (createOrgError) {
            console.error('Error creating organization:', createOrgError);
            setError('Error al crear organizaci√≥n. Por favor, contacta al soporte.');
          } else if (newOrg) {
            console.log('Created new organization:', newOrg.id);
            
            // Update user with new organization
            const { data: updatedUser, error: updateError } = await supabase
              .from('users')
              .update({ organization_id: newOrg.id })
              .eq('auth_user_id', user.id)
              .select(`
                id, 
                name, 
                full_name,
                email, 
                role,
                organization_id, 
                last_login,
                created_at
              `)
              .single();

            if (!updateError && updatedUser) {
              const profileData: UserProfile = {
                ...updatedUser,
                role: updatedUser.role as 'admin' | 'user' | 'viewer',
                organization: {
                  id: newOrg.id,
                  name: newOrg.name,
                  description: newOrg.description || '',
                  timezone: newOrg.timezone || 'America/Santiago',
                  logo_url: newOrg.logo_url || '',
                  plan_type: newOrg.plan_type || 'free',
                  instagram_connected: !!newOrg.meta_token
                }
              };
              setProfile(profileData);
              toast.success('¬°Organizaci√≥n creada exitosamente!');
              return;
            }
          }
        }
      }

      // Fetch organization info separately if user has organization_id
      let organizationData = null;
      if (data.organization_id) {
        const { data: orgInfo } = await supabase
          .rpc('get_organization_safe_info', { org_id: data.organization_id });
        organizationData = orgInfo?.[0] || null;
      }

      // Type assertion to ensure proper typing
      const profileData: UserProfile = {
        ...data,
        role: data.role as 'admin' | 'user' | 'viewer',
        organization: organizationData ? {
          id: organizationData.id,
          name: organizationData.name,
          description: organizationData.description,
          timezone: organizationData.timezone,
          logo_url: organizationData.logo_url,
          plan_type: organizationData.plan_type,
          instagram_connected: organizationData.instagram_connected
        } : null
      };

      setProfile(profileData);

      // Actualizar last_login si han pasado m√°s de 1 hora
      const lastLogin = data.last_login ? new Date(data.last_login) : null;
      const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
      
      if (!lastLogin || lastLogin < oneHourAgo) {
        await supabase
          .from('users')
          .update({ last_login: new Date().toISOString() })
          .eq('auth_user_id', user.id);
      }

    } catch (err) {
      console.error('Unexpected error:', err);
      setError('Error inesperado al obtener datos del usuario');
    } finally {
      setLoading(false);
    }
  };

  const refreshProfile = () => {
    if (user) {
      fetchUserProfile();
    }
  };

  return {
    profile,
    loading,
    error,
    refreshProfile,
    retryFetch
  };
}
</file>

<file path="src/pages/Ambassadors.tsx">
import { useEffect } from "react";
import { MainLayout } from "@/components/Layout/MainLayout";
import AmbassadorManagement from "@/components/Ambassadors/AmbassadorManagement";
import { ProtectedRoute } from "@/components/Auth/ProtectedRoute";
import { toast } from "sonner";

const Ambassadors = () => {
  // Handle Instagram connection callback
  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const status = params.get('status');
    const error = params.get('error');

    if (status === 'success') {
      toast.success('Instagram conectado exitosamente', {
        description: 'La cuenta de Instagram del embajador ha sido vinculada correctamente'
      });
      
      // Clean up URL parameters
      const url = new URL(window.location.href);
      url.searchParams.delete('status');
      window.history.replaceState({}, '', url.toString());
    } else if (status === 'error' && error) {
      toast.error('Error al conectar Instagram', {
        description: decodeURIComponent(error)
      });
      
      // Clean up URL parameters
      const url = new URL(window.location.href);
      url.searchParams.delete('status');
      url.searchParams.delete('error');
      window.history.replaceState({}, '', url.toString());
    }
  }, []);

  return (
    <ProtectedRoute>
      <MainLayout>
        <AmbassadorManagement />
      </MainLayout>
    </ProtectedRoute>
  );
};

export default Ambassadors;
</file>

<file path="src/pages/Analytics.tsx">
import { MainLayout } from "@/components/Layout/MainLayout";
import { StoryInsightsDashboard } from "@/components/Analytics/StoryInsightsDashboard";
import { ProtectedRoute } from "@/components/Auth/ProtectedRoute";

export default function Analytics() {
  return (
    <ProtectedRoute>
      <MainLayout>
        <StoryInsightsDashboard />
      </MainLayout>
    </ProtectedRoute>
  );
}
</file>

<file path="src/App.tsx">
import { lazy, Suspense } from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { I18nextProvider } from "react-i18next";
import { TooltipProvider } from "@/components/ui/tooltip";
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import i18n from "./i18n";

// Lazy load pages for better performance
const Index = lazy(() => import("./pages/Index"));
const Onboarding = lazy(() => import("./pages/Onboarding"));
const Stories = lazy(() => import("./pages/Stories"));
const Profile = lazy(() => import("./pages/Profile"));
const Settings = lazy(() => import("./pages/Settings"));
const Auth = lazy(() => import("./pages/Auth"));
const Analytics = lazy(() => import("./pages/Analytics"));
const Events = lazy(() => import("./pages/Events"));
const Ambassadors = lazy(() => import("./pages/Ambassadors"));
const Mentions = lazy(() => import("./pages/MentionsOptimized"));
const ImportExport = lazy(() => import("./pages/ImportExport"));
const Notifications = lazy(() => import("./pages/Notifications"));
const StoryMentions = lazy(() => import("./pages/StoryMentions"));
const InstagramDiagnostics = lazy(() => import("./pages/InstagramDiagnostics"));
const InstagramBusiness = lazy(() => import("./pages/InstagramBusiness"));
const AuthCallback = lazy(() => import("./pages/auth-callback"));
const MetaOAuthProxy = lazy(() => import("./pages/MetaOAuthProxy"));
const NotFound = lazy(() => import("./pages/NotFound"));

// QueryClient configuration optimized for performance  
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 10 * 60 * 1000, // 10 minutes - data stays fresh longer
      gcTime: 30 * 60 * 1000, // 30 minutes - keep in cache longer
      retry: (failureCount, error) => {
        if (error && typeof error === 'object' && 'status' in error) {
          const status = error.status as number;
          if (status >= 400 && status < 500) return false;
        }
        return failureCount < 1; // Reduced retries for faster failures
      },
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
      refetchOnMount: false, // Don't refetch if data exists
      networkMode: 'online',
    },
    mutations: {
      retry: false, // Don't retry mutations by default
    },
  },
});

// Loading component optimized for mobile
function PageLoader() {
  return (
    <div className="flex items-center justify-center min-h-screen bg-background">
      <div className="flex flex-col items-center space-y-4">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
        <p className="text-sm text-muted-foreground animate-pulse">Cargando...</p>
      </div>
    </div>
  );
}

const App = () => (
  <QueryClientProvider client={queryClient}>
    <I18nextProvider i18n={i18n}>
      <TooltipProvider>
        <Toaster />
        <Sonner />
        <BrowserRouter>
          <Suspense fallback={<PageLoader />}>
            <Routes>
              <Route path="/" element={<Index />} />
              <Route path="/onboarding" element={<Onboarding />} />
              <Route path="/stories" element={<Stories />} />
              <Route path="/ambassadors" element={<Ambassadors />} />
              <Route path="/events" element={<Events />} />
              <Route path="/analytics" element={<Analytics />} />
              <Route path="/notifications" element={<Notifications />} />
              <Route path="/import-export" element={<ImportExport />} />
              <Route path="/mentions" element={<Mentions />} />
              <Route path="/story-mentions" element={<StoryMentions />} />
              <Route path="/profile" element={<Profile />} />
              <Route path="/settings" element={<Settings />} />
              <Route path="/instagram-diagnostics" element={<InstagramDiagnostics />} />
              <Route path="/instagram-business" element={<InstagramBusiness />} />
              <Route path="/auth" element={<Auth />} />
              <Route path="/auth-callback" element={<AuthCallback />} />
              <Route path="/meta-oauth" element={<MetaOAuthProxy />} />
              <Route path="*" element={<NotFound />} />
            </Routes>
          </Suspense>
        </BrowserRouter>
      </TooltipProvider>
    </I18nextProvider>
  </QueryClientProvider>
);

export default App;
</file>

<file path="supabase/functions/backup-full-database/index.ts">
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface BackupData {
  timestamp: string;
  organizations: Organization[];
  embassadors: Ambassador[];
  fiestas: Fiesta[];
  events: Event[];
  tasks: Task[];
  leaderboards: Leaderboard[];
  users: User[];
  organization_settings: OrganizationSetting[];
  notifications: Notification[];
  import_logs: ImportLog[];
  task_logs: TaskLog[];
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // Get user from JWT
    const authHeader = req.headers.get('Authorization')!;
    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabaseClient.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log('Starting full database backup for user:', user.id);

    // Fetch all data from all tables
    const backupData: BackupData = {
      timestamp: new Date().toISOString(),
      organizations: [],
      embassadors: [],
      fiestas: [],
      events: [],
      tasks: [],
      leaderboards: [],
      users: [],
      organization_settings: [],
      notifications: [],
      import_logs: [],
      task_logs: []
    };

    // Fetch organizations (only user's own)
    const { data: organizations } = await supabaseClient
      .from('organizations')
      .select('*')
      .eq('created_by', user.id);
    backupData.organizations = organizations || [];

    if (organizations && organizations.length > 0) {
      const orgIds = organizations.map(org => org.id);

      // Fetch embassadors for user's organizations
      const { data: embassadors } = await supabaseClient
        .from('embassadors')
        .select('*')
        .in('organization_id', orgIds);
      backupData.embassadors = embassadors || [];

      // Fetch fiestas for user's organizations
      const { data: fiestas } = await supabaseClient
        .from('fiestas')
        .select('*')
        .in('organization_id', orgIds);
      backupData.fiestas = fiestas || [];

      if (fiestas && fiestas.length > 0) {
        const fiestaIds = fiestas.map(f => f.id);
        
        // Fetch events for user's fiestas
        const { data: events } = await supabaseClient
          .from('events')
          .select('*')
          .in('fiesta_id', fiestaIds);
        backupData.events = events || [];
      }

      if (embassadors && embassadors.length > 0) {
        const embassadorIds = embassadors.map(e => e.id);
        
        // Fetch tasks for user's embassadors
        const { data: tasks } = await supabaseClient
          .from('tasks')
          .select('*')
          .in('embassador_id', embassadorIds);
        backupData.tasks = tasks || [];

        if (tasks && tasks.length > 0) {
          const taskIds = tasks.map(t => t.id);
          
          // Fetch task logs
          const { data: taskLogs } = await supabaseClient
            .from('task_logs')
            .select('*')
            .in('task_id', taskIds);
          backupData.task_logs = taskLogs || [];
        }
      }

      if (backupData.events.length > 0) {
        const eventIds = backupData.events.map(e => e.id);
        
        // Fetch leaderboards for user's events
        const { data: leaderboards } = await supabaseClient
          .from('leaderboards')
          .select('*')
          .in('event_id', eventIds);
        backupData.leaderboards = leaderboards || [];
      }

      // Fetch organization settings
      const { data: orgSettings } = await supabaseClient
        .from('organization_settings')
        .select('*')
        .in('organization_id', orgIds);
      backupData.organization_settings = orgSettings || [];

      // Fetch notifications
      const { data: notifications } = await supabaseClient
        .from('notifications')
        .select('*')
        .in('organization_id', orgIds);
      backupData.notifications = notifications || [];
    }

    // Fetch user profile
    const { data: userProfile } = await supabaseClient
      .from('users')
      .select('*')
      .eq('auth_user_id', user.id);
    backupData.users = userProfile || [];

    // Fetch import logs
    const { data: importLogs } = await supabaseClient
      .from('import_logs')
      .select('*')
      .eq('user_id', user.id);
    backupData.import_logs = importLogs || [];

// Sanitize sensitive fields before returning
backupData.organizations = (backupData.organizations || []).map((o: Organization) => {
  const { meta_token, token_expiry, ...safe } = o; return safe;
});
backupData.embassadors = (backupData.embassadors || []).map((a: Ambassador) => {
  const { instagram_access_token, token_expires_at, ...safe } = a; return safe;
});

console.log('Backup completed successfully. Data summary:', {
  organizations: backupData.organizations.length,
  embassadors: backupData.embassadors.length,
  fiestas: backupData.fiestas.length,
  events: backupData.events.length,
  tasks: backupData.tasks.length,
  leaderboards: backupData.leaderboards.length,
  users: backupData.users.length,
  organization_settings: backupData.organization_settings.length,
  notifications: backupData.notifications.length,
  import_logs: backupData.import_logs.length,
  task_logs: backupData.task_logs.length
});

return new Response(
  JSON.stringify(backupData),
  { 
    status: 200, 
    headers: { 
      ...corsHeaders, 
      'Content-Type': 'application/json',
      'Content-Disposition': `attachment; filename="eva-backup-${new Date().toISOString().split('T')[0]}.json"`
    } 
  }
);

  } catch (error) {
    console.error('Error during backup:', error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return new Response(
      JSON.stringify({ error: 'Error creating backup', details: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
</file>

<file path="supabase/functions/instagram-profile/index.ts">
import { corsHeaders, INSTAGRAM_API_BASE } from '../shared/constants.ts';
import { corsPreflightResponse, jsonResponse, unauthorizedResponse, badRequestResponse } from '../shared/responses.ts';
import { authenticateRequest, createSupabaseClient } from '../shared/auth.ts';
import { handleError, validateRequired } from '../shared/error-handler.ts';
import { safeDecryptToken } from '../shared/crypto.ts';

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return corsPreflightResponse();
  }

  try {
    // Authenticate user
    const authResult = await authenticateRequest(req);
    if (authResult instanceof Response) return authResult;
    
    const { user, supabase } = authResult;

    const { organization_id, endpoint } = await req.json();
    validateRequired({ organization_id }, ['organization_id']);

    // SECURITY: Verify user owns this organization
    const { data: org, error: orgError } = await supabase
      .from('organizations')
      .select('id, instagram_user_id, instagram_username')
      .eq('id', organization_id)
      .eq('created_by', user.id) // CRITICAL: Only allow access to owned organizations
      .single();

    if (orgError || !org) {
      return new Response(
        JSON.stringify({ error: 'Organization not found or access denied' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get organization token
    const { data: tokenData, error: tokenError } = await supabase
      .rpc('get_organization_token_info', { org_id: organization_id });

    if (tokenError || !tokenData || tokenData.length === 0) {
      return new Response(
        JSON.stringify({ error: 'No Instagram token found for organization' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const orgToken = tokenData[0];
    if (orgToken.is_expired) {
      return new Response(
        JSON.stringify({ error: 'Instagram token has expired' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Decrypt token
    const accessToken = await safeDecryptToken(orgToken.access_token);

    let result = {};

    switch (endpoint) {
      case 'profile':
        result = await getInstagramProfile(org.instagram_user_id, accessToken);
        break;
      case 'media':
        result = await getInstagramMedia(org.instagram_user_id, accessToken);
        break;
      case 'tags':
        result = await getInstagramTags(org.instagram_user_id, accessToken);
        break;
      default:
        return new Response(
          JSON.stringify({ error: 'Invalid endpoint' }),
          { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
    }

    return new Response(
      JSON.stringify(result),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    return handleError(error);
  }
});

// Obtener perfil b√°sico usando las especificaciones del usuario
async function getInstagramProfile(igUserId: string, accessToken: string) {
  const fields = 'user_id,username,name,account_type,profile_picture_url,followers_count,follows_count,media_count';
  
  const response = await fetch(
    `${INSTAGRAM_API_BASE}/${igUserId}?fields=${fields}&access_token=${accessToken}`
  );

  const data = await response.json();
  
  if (!response.ok) {
    throw new Error(`Instagram API error: ${data.error?.message || 'Unknown error'}`);
  }

  return {
    success: true,
    profile: data
  };
}

// Obtener feed del usuario usando las especificaciones del usuario
async function getInstagramMedia(igUserId: string, accessToken: string) {
  const fields = 'id,caption,comments_count,like_count,media_type,media_url,owner,permalink,username';
  
  const response = await fetch(
    `${INSTAGRAM_API_BASE}/${igUserId}/media?fields=${fields}&access_token=${accessToken}`
  );

  const data = await response.json();
  
  if (!response.ok) {
    throw new Error(`Instagram API error: ${data.error?.message || 'Unknown error'}`);
  }

  return {
    success: true,
    media: data.data || []
  };
}

// Obtener menciones (tags en publicaciones) usando las especificaciones del usuario
async function getInstagramTags(igUserId: string, accessToken: string) {
  const fields = 'id,caption,comments_count,like_count,media_type,media_url,permalink,username';
  
  const response = await fetch(
    `${INSTAGRAM_API_BASE}/${igUserId}/tags?fields=${fields}&access_token=${accessToken}`
  );

  const data = await response.json();
  
  if (!response.ok) {
    throw new Error(`Instagram API error: ${data.error?.message || 'Unknown error'}`);
  }

  return {
    success: true,
    tags: data.data || []
  };
}
</file>

<file path="supabase/functions/instagram-send-message/index.ts">
import { corsHeaders } from '../shared/constants.ts';
import { SupabaseClient } from '../shared/types.ts';
import { corsPreflightResponse, jsonResponse, unauthorizedResponse, badRequestResponse } from '../shared/responses.ts';
import { authenticateRequest, verifyOrganizationAccess } from '../shared/auth.ts';
import { handleError, validateRequired } from '../shared/error-handler.ts';
import { safeDecryptToken } from '../shared/crypto.ts';
import { sendInstagramMessage } from '../shared/instagram-api.ts';

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return corsPreflightResponse();
  }

  try {
    // Authenticate user
    const authResult = await authenticateRequest(req);
    if (authResult instanceof Response) return authResult;
    
    const { user, supabase } = authResult;

    // Parse and validate request body
    const { recipientId, message, organizationId } = await req.json();
    validateRequired({ recipientId, message, organizationId }, ['recipientId', 'message', 'organizationId']);

    // Verify user owns the organization
    const { data: organization, error: orgError } = await supabase
      .from('organizations')
      .select('id, name')
      .eq('id', organizationId)
      .eq('created_by', user.id)
      .single();

    if (orgError || !organization) {
      return jsonResponse({ error: 'Organization not found or unauthorized'       }, { status: 404 });
    }

    // Get organization's Instagram access token
    const { data: tokenData, error: tokenError } = await supabase
      .from('organization_instagram_tokens')
      .select('access_token, token_expiry')
      .eq('organization_id', organizationId)
      .single();

    if (tokenError || !tokenData?.access_token) {
      return jsonResponse({ error: 'Instagram access token not found for organization'}, { status: 400 });
    }

    // Check if token is expired
    if (tokenData.token_expiry && new Date(tokenData.token_expiry) < new Date()) {
      return jsonResponse({ error: 'Instagram access token has expired'       }, { status: 400 });
    }

    // Decrypt token for API call
    const decryptedToken = await safeDecryptToken(tokenData.access_token);

    // Send message via Instagram Messaging API using shared function
    const responseData = await sendInstagramMessage(recipientId, message, decryptedToken);

    // Log the sent message for audit trail
    console.log('Instagram message sent successfully:', {
      organizationId,
      recipientId,
      messageId: responseData.message_id,
      sentBy: user.id
    });

    return jsonResponse({ 
      success: true, 
      messageId: responseData.message_id,
      recipientId 
    });

  } catch (error) {
    return handleError(error);
  }
});
</file>

<file path="supabase/functions/instagram-sync/index.ts">
import { corsHeaders, INSTAGRAM_API_BASE } from '../shared/constants.ts';
import { SupabaseClient, SyncResult, InsightsMap, MediaItem, Ambassador, Fiesta } from '../shared/types.ts';
import { corsPreflightResponse, jsonResponse } from '../shared/responses.ts';
import { createSupabaseClient } from '../shared/auth.ts';
import { handleError } from '../shared/error-handler.ts';
import { encryptToken, safeDecryptToken } from '../shared/crypto.ts';

Deno.serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return corsPreflightResponse();
  }

  try {
    const supabaseClient = createSupabaseClient()

    // Security check: Verify request authenticity
    const authHeader = req.headers.get('Authorization');
    const cronSecretHeader = req.headers.get('x-cron-secret');
    const expectedCronSecret = Deno.env.get('CRON_SECRET');

    // Check if this is a cron job or user request
    const isCronJob = !authHeader;
    let targetOrgId: string | null = null;
    let userId: string | null = null;

    // Security validation
    if (isCronJob) {
      // For cron jobs, require CRON_SECRET header
      if (!cronSecretHeader || !expectedCronSecret || cronSecretHeader !== expectedCronSecret) {
        console.error('Unauthorized cron request: Invalid or missing CRON_SECRET');
        return new Response(
          JSON.stringify({ error: 'Unauthorized: Invalid cron secret' }), 
          { 
            status: 401, 
            headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
          }
        );
      }
      console.log('Starting Instagram sync process... (CRON JOB)');
      
      // For cron jobs, parse any body parameters
      try {
        const body = await req.json()
        targetOrgId = body?.organization_id ?? null
      } catch (_) {
        // No body provided, continue
      }
    } else {
      console.log('Starting Instagram sync process... (USER REQUEST)');
      
      // Parse request body for user requests
      try {
        const body = await req.json()
        targetOrgId = body?.organization_id ?? null
      } catch (_) {
        // No body provided, continue
      }
      // For user requests, authentication is handled by Supabase JWT verification
      // But we still need to get the user context
      const authHeader = req.headers.get('Authorization');
      if (!authHeader) {
        throw new Error('No authorization header');
      }

      const { data: { user }, error: authError } = await supabaseClient.auth.getUser(
        authHeader.replace('Bearer ', '')
      );

      if (authError || !user) {
        throw new Error('Unauthorized');
      }

      userId = user.id;

      // Verify user belongs to organization they're trying to sync
      const { data: userData, error: userError } = await supabaseClient
        .from('users')
        .select('organization_id')
        .eq('auth_user_id', user.id)
        .single();

      if (userError || !userData) {
        throw new Error('User not found');
      }

      // Ensure user can only sync their own organization
      if (targetOrgId && targetOrgId !== userData.organization_id) {
        throw new Error('Cannot sync organization that does not belong to you');
      }

      // If no target specified, use user's organization
      if (!targetOrgId) {
        targetOrgId = userData.organization_id;
      }
    }

    // Fetch organizations that have Instagram connections
    // Note: With Instagram Login, instagram_user_id is the key identifier
    let organizationsQuery = supabaseClient
      .from('organizations')
      .select('id, name, instagram_user_id, instagram_username')
      .not('instagram_user_id', 'is', null)
      .order('last_instagram_sync', { ascending: true, nullsFirst: true });

    // If specific organization requested, filter by it
    if (targetOrgId) {
      organizationsQuery = organizationsQuery.eq('id', targetOrgId);
    }

    const { data: organizations, error: orgsError } = await organizationsQuery;

    if (orgsError) {
      console.error('Error fetching organizations:', orgsError);
      throw new Error('Failed to fetch organizations');
    }

    console.log(`Found ${organizations?.length || 0} organization(s) ${targetOrgId ? `(targeted: ${targetOrgId})` : ''}`)
    
    if (targetOrgId && (!organizations || organizations.length === 0)) {
      console.log(`Target organization ${targetOrgId} not found or has no Instagram connected`)
    }

    const results: SyncResult[] = []
    let totalProcessed = 0;

    for (const org of organizations || []) {
      try {
        console.log(`Syncing data for organization: ${org.name} (${org.id})`);
        
        // Get Instagram token for this organization
        const { data: tokenData, error: tokenError } = await supabaseClient
          .from('organization_instagram_tokens')
          .select('access_token, token_expiry')
          .eq('organization_id', org.id)
          .single();

        if (tokenError || !tokenData) {
          console.log(`No Instagram token found for organization ${org.name}`);
          continue;
        }
        
        // Check if token is expired
        if (tokenData.token_expiry && new Date(tokenData.token_expiry) < new Date()) {
          console.log(`Token expired for organization ${org.name}, creating notification`);
          
          // Create notification about expired token
          await supabaseClient
            .from('notifications')
            .insert({
              organization_id: org.id,
              type: 'token_expired',
              message: 'Tu token de Instagram ha expirado. Reconecta tu cuenta para continuar sincronizando datos.',
              priority: 'high'
            });
          
          continue; // Skip this organization
        }

        if (!org.instagram_user_id) {
          console.log(`No Instagram User ID for organization ${org.name}`);
          continue;
        }

        // Sync Instagram data using decrypted token
        const decryptedToken = await safeDecryptToken(tokenData.access_token);
        const syncResult = await syncOrganizationInstagramData(supabaseClient, org.id, org.instagram_user_id, decryptedToken);
        
        // Update last sync timestamp
        await supabaseClient
          .from('organizations')
          .update({ last_instagram_sync: new Date().toISOString() })
          .eq('id', org.id);
        
        console.log(`Sync completed for ${org.name}:`, syncResult);
        results.push({
          organization_id: org.id,
          organization_name: org.name,
          success: true,
          ...syncResult
        });

        totalProcessed++;
        
      } catch (error) {
        console.error(`Error syncing organization ${org.name}:`, error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        results.push({
          organization_id: org.id,
          organization_name: org.name,
          success: false,
          error: errorMessage
        });
      }
    }

    console.log(`Instagram sync completed: ${totalProcessed} organizations processed`)

    // Create a summary notification for cron jobs
    if (isCronJob && totalProcessed > 0) {
      const successCount = results.filter(r => r.success).length;
      const failureCount = results.filter(r => !r.success).length;
      
      console.log(`Cron sync summary: ${successCount} successful, ${failureCount} failed`);
    }

    return jsonResponse({ 
        success: true, 
        results,
        totalProcessed,
        isCronJob,
        timestamp: new Date().toISOString()
      })

  } catch (error) {
    return handleError(error)
  }
})

async function syncOrganizationInstagramData(supabaseClient: SupabaseClient, organizationId: string, igUserId: string, accessToken: string) {
  console.log(`Syncing Instagram data for organization ${organizationId}, User ID: ${igUserId}`)
  
  try {
    const instagramMetrics = {
      totalFollowers: 0,
      totalPosts: 0,
      totalReach: 0,
      totalImpressions: 0,
      newMentions: 0,
      newTags: 0
    }

    // 1. Get account metrics directly using the user ID
    const metricsUrl = `${INSTAGRAM_API_BASE}/${igUserId}?fields=followers_count,media_count&access_token=${accessToken}`
    const metricsResponse = await fetch(metricsUrl)
    const metricsData = await metricsResponse.json()
    
    if (metricsResponse.ok) {
      instagramMetrics.totalFollowers += metricsData.followers_count || 0
      instagramMetrics.totalPosts += metricsData.media_count || 0
    } else {
      console.warn(`Failed to fetch metrics for user ${igUserId}:`, metricsData)
    }

    // 2. Get recent media insights (last 50 items to cover active stories)
    const mediaUrl = `${INSTAGRAM_API_BASE}/${igUserId}/media?fields=id,media_type,media_product_type,timestamp,username&limit=50&access_token=${accessToken}`
    const mediaResponse = await fetch(mediaUrl)
    const mediaData = await mediaResponse.json()
    
    if (mediaResponse.ok && mediaData.data) {
      for (const media of mediaData.data) {
        try {
          // Check if this is a Story and if it's still active (<24h)
          const isStory = media.media_product_type === 'STORY';
          const mediaTime = new Date(media.timestamp).getTime();
          const now = new Date().getTime();
          const ageHours = (now - mediaTime) / (1000 * 60 * 60);
          const isActive = ageHours < 24;
          
          // Use appropriate metrics based on media type
          const metrics = isStory 
            ? 'impressions,reach,replies,exits,taps_forward,taps_back,shares'
            : 'reach,impressions'; // impressions is deprecated but still available for some media
          
          const insightsUrl = `${INSTAGRAM_API_BASE}/${media.id}/insights?metric=${metrics}&access_token=${accessToken}`
          const insightsResponse = await fetch(insightsUrl)
          const insightsData = await insightsResponse.json()
          
          if (insightsResponse.ok && insightsData.data) {
            // Accumulate metrics for organization totals
            for (const insight of insightsData.data) {
              if (insight.name === 'reach') {
                instagramMetrics.totalReach += insight.values[0]?.value || 0
              } else if (insight.name === 'impressions') {
                instagramMetrics.totalImpressions += insight.values[0]?.value || 0
              }
            }
            
            // If this is an active Story, create a snapshot
            if (isStory && isActive) {
              // Try to find matching social_mention
              const { data: storyMention } = await supabaseClient
                .from('social_mentions')
                .select('id')
                .eq('organization_id', organizationId)
                .or(`instagram_story_id.eq.${media.id},instagram_media_id.eq.${media.id}`)
                .maybeSingle();
              
              if (storyMention) {
                // Parse insights for snapshot
                const insights: InsightsMap = {};
                for (const insight of insightsData.data) {
                  insights[insight.name] = insight.values?.[0]?.value || 0;
                }
                
                // Create snapshot
                const snapshot = {
                  social_mention_id: storyMention.id,
                  organization_id: organizationId,
                  instagram_story_id: media.id,
                  instagram_media_id: media.id,
                  snapshot_at: new Date().toISOString(),
                  story_age_hours: Math.round(ageHours * 100) / 100,
                  impressions: insights.impressions || 0,
                  reach: insights.reach || 0,
                  replies: insights.replies || 0,
                  exits: insights.exits || 0,
                  taps_forward: insights.taps_forward || 0,
                  taps_back: insights.taps_back || 0,
                  shares: insights.shares || 0,
                  navigation: {},
                  raw_insights: insightsData
                };
                
                await supabaseClient
                  .from('story_insights_snapshots')
                  .insert(snapshot);
                
                console.log(`Created story insights snapshot during sync for story ${media.id}`);
              }
            }
          }
        } catch (error) {
          console.warn(`Error getting insights for media ${media.id}:`, error)
        }
      }
    } else {
      console.warn(`Failed to fetch media for user ${igUserId}:`, mediaData)
    }

    // 3. Sync media where the account was mentioned and tagged media
    const mentionResults = await processInstagramMentionsAndTags(supabaseClient, organizationId, igUserId, accessToken)
    instagramMetrics.newMentions += mentionResults.newMentions;
    instagramMetrics.newTags += mentionResults.newTags;

    // Create notification about successful sync only if there's new activity
    if (instagramMetrics.newMentions > 0 || instagramMetrics.newTags > 0) {
      await supabaseClient
        .from('notifications')
        .insert({
          organization_id: organizationId,
          type: 'sync_completed',
          message: `Sincronizaci√≥n completada: ${instagramMetrics.newMentions} nuevas menciones, ${instagramMetrics.newTags} nuevas etiquetas detectadas.`,
          priority: 'normal'
        })
    }

    console.log(`Instagram metrics for organization ${organizationId}:`, instagramMetrics)
    return instagramMetrics

  } catch (error) {
    console.error(`Error syncing Instagram data for organization ${organizationId}:`, error)
    throw error
  }
}

async function processInstagramMentionsAndTags(supabaseClient: SupabaseClient, organizationId: string, igUserId: string, accessToken: string) {
  // Get ambassadors for this organization with normalized usernames
  const { data: ambassadors, error: ambassadorsError } = await supabaseClient
    .from('embassadors')
    .select('id, instagram_user, first_name, last_name')
    .eq('organization_id', organizationId)
    .not('instagram_user', 'is', null)

  if (ambassadorsError) {
    console.warn('Error loading ambassadors for org', organizationId, ambassadorsError)
    return { newMentions: 0, newTags: 0 }
  }

  // Create a normalized map of usernames to ambassador IDs
  const ambassadorMap = new Map()
  for (const ambassador of ambassadors || []) {
    if (ambassador.instagram_user) {
      // Normalize: lowercase, remove @
      const normalizedUsername = ambassador.instagram_user.toLowerCase().replace('@', '')
      ambassadorMap.set(normalizedUsername, ambassador)
    }
  }

  // Resolve active event for this organization
  const { data: fiestas, error: fiestasError } = await supabaseClient
    .from('fiestas')
    .select('id')
    .eq('organization_id', organizationId)
  
  if (fiestasError) {
    console.warn('Error loading fiestas for org', organizationId, fiestasError)
  }
  
  const fiestaIds = (fiestas || []).map((f: Fiesta) => f.id)
  let activeEventId: string | null = null
  
  if (fiestaIds.length > 0) {
    const { data: event, error: eventError } = await supabaseClient
      .from('events')
      .select('id')
      .in('fiesta_id', fiestaIds)
      .eq('active', true)
      .order('created_at', { ascending: false })
      .limit(1)
      .maybeSingle()
    if (!eventError && event) {
      activeEventId = event.id
    }
  }

  let newMentions = 0;
  let newTags = 0;

  // Process mentioned media (when the account is mentioned)
  try {
    const mentionsUrl = `${INSTAGRAM_API_BASE}/${igUserId}/mentioned_media?fields=id,media_type,media_url,permalink,caption,timestamp,username&limit=50&access_token=${accessToken}`
    const mentionsRes = await fetch(mentionsUrl)
    const mentionsData = await mentionsRes.json()

    if (mentionsRes.ok && Array.isArray(mentionsData.data)) {
      console.log(`Found ${mentionsData.data.length} mentioned media for organization ${organizationId}`)
      
      for (const m of mentionsData.data) {
        const isNew = await processMentionOrTag(supabaseClient, organizationId, m, ambassadorMap, activeEventId, 'mention')
        if (isNew) newMentions++;
      }
    } else {
      console.warn('Failed to load mentioned_media:', mentionsData?.error || mentionsData)
    }
  } catch (err) {
    console.warn('Error fetching mentioned_media:', err)
  }

  // Process tagged media (when the account is tagged in posts)
  try {
    const tagsUrl = `${INSTAGRAM_API_BASE}/${igUserId}/tags?fields=id,media_type,media_url,permalink,caption,timestamp,username&limit=50&access_token=${accessToken}`
    const tagsRes = await fetch(tagsUrl)
    const tagsData = await tagsRes.json()

    if (tagsRes.ok && Array.isArray(tagsData.data)) {
      console.log(`Found ${tagsData.data.length} tagged media for organization ${organizationId}`)
      
      for (const t of tagsData.data) {
        const isNew = await processMentionOrTag(supabaseClient, organizationId, t, ambassadorMap, activeEventId, 'tag')
        if (isNew) newTags++;
      }
    } else {
      console.warn('Failed to load tags:', tagsData?.error || tagsData)
    }
  } catch (err) {
    console.warn('Error fetching tags:', err)
  }

  return { newMentions, newTags };
}

async function processMentionOrTag(supabaseClient: SupabaseClient, organizationId: string, mediaItem: MediaItem, ambassadorMap: Map<string, Ambassador>, activeEventId: string | null, type: 'mention' | 'tag'): Promise<boolean> {
  try {
    // Check if already exists in social_mentions
    const { data: existingSocial, error: existSocialError } = await supabaseClient
      .from('social_mentions')
      .select('id')
      .eq('instagram_media_id', mediaItem.id)
      .maybeSingle()
    
    if (existingSocial && !existSocialError) {
      return false // Already processed
    }

    // Check if already exists in tasks (legacy)
    const { data: existingTask, error: existTaskError } = await supabaseClient
      .from('tasks')
      .select('id')
      .eq('instagram_story_id', mediaItem.id)
      .maybeSingle()
    
    if (existingTask && !existTaskError) {
      return false // Already processed
    }

    // Normalize username for matching
    const normalizedUsername = mediaItem.username ? mediaItem.username.toLowerCase().replace('@', '') : null
    const ambassador = normalizedUsername ? ambassadorMap.get(normalizedUsername) : null

    // Create social_mentions entry
    const { data: socialMention, error: socialMentionError } = await supabaseClient
      .from('social_mentions')
      .insert({
        organization_id: organizationId,
        instagram_media_id: mediaItem.id,
        instagram_username: mediaItem.username,
        instagram_user_id: null, // We don't have this from the API
        mention_type: type,
        story_url: mediaItem.permalink || mediaItem.media_url,
        content: mediaItem.caption || null,
        matched_ambassador_id: ambassador ? ambassador.id : null,
        processed: ambassador ? true : false
      })
      .select('id')
      .single()

    if (socialMentionError) {
      console.error('Error creating social mention:', socialMentionError)
      return false
    }

    if (ambassador && activeEventId) {
      // Create task for matched ambassador
      await supabaseClient
        .from('tasks')
        .insert({
          embassador_id: ambassador.id,
          event_id: activeEventId,
          task_type: type,
          status: 'uploaded',
          instagram_story_id: mediaItem.id,
          story_url: mediaItem.permalink || mediaItem.media_url,
          platform: 'instagram',
          verified_through_api: true,
          upload_time: mediaItem.timestamp,
          last_status_update: new Date().toISOString()
        })

      console.log(`Created ${type} task for ambassador ${ambassador.id} (${mediaItem.username})`)
    }

    return true // New item processed

  } catch (err) {
    console.warn(`Error processing ${type} media:`, err)
    return false
  }
}
</file>

<file path="supabase/functions/instagram-webhook/index.ts">
import { corsHeaders, INSTAGRAM_API_BASE, STORY_INSIGHTS_METRICS } from '../shared/constants.ts';
import { SupabaseClient, Organization, Ambassador, InsightsData, MediaData, CommentData, MessageData } from '../shared/types.ts';
import { corsPreflightResponse, jsonResponse } from '../shared/responses.ts';
import { createSupabaseClient } from '../shared/auth.ts';
import { handleError } from '../shared/error-handler.ts';
import { safeDecryptToken } from '../shared/crypto.ts';


async function getOrganizationWebhookToken(supabaseClient: SupabaseClient, instagramUserId: string): Promise<string | undefined> {
  // Try to find organization by Instagram user ID and get its webhook token using secure function
  const { data: creds, error: credsError } = await supabaseClient
    .rpc('get_organization_credentials_by_instagram_user', {
      p_instagram_user_id: instagramUserId
    });

  if (!credsError && creds && creds.length > 0 && creds[0].webhook_verify_token) {
    return creds[0].webhook_verify_token;
  }

  // Fallback to global token
  return Deno.env.get('WEBHOOK_VERIFY_TOKEN');
}

async function getWebhookCredentials(supabaseClient: SupabaseClient, instagramUserId: string) {
  // Try to find organization-specific credentials using secure function
  const { data: creds, error: credsError } = await supabaseClient
    .rpc('get_organization_credentials_by_instagram_user', {
      p_instagram_user_id: instagramUserId
    });

  if (!credsError && creds && creds.length > 0) {
    const orgCreds = creds[0];
    return {
      APP_SECRET: orgCreds.meta_app_secret,
      WEBHOOK_VERIFY_TOKEN: orgCreds.webhook_verify_token
    };
  }

  // Fallback to global credentials
  return {
    APP_SECRET: Deno.env.get('INSTAGRAM_APP_SECRET'),
    WEBHOOK_VERIFY_TOKEN: Deno.env.get('WEBHOOK_VERIFY_TOKEN')
  };
}

async function verifyXHubSignature(supabaseClient: SupabaseClient, payload: string, signatureHeader: string | null, instagramUserId: string): Promise<void> {
  const credentials = await getWebhookCredentials(supabaseClient, instagramUserId);
  const APP_SECRET = credentials.APP_SECRET;
  
  if (!APP_SECRET) throw new Error('APP secret not configured');
  if (!signatureHeader || !signatureHeader.startsWith('sha256=')) throw new Error('Missing signature');
  
  const signature = signatureHeader.slice(7);
  const enc = new TextEncoder();
  const key = await crypto.subtle.importKey('raw', enc.encode(APP_SECRET), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
  const mac = await crypto.subtle.sign('HMAC', key, enc.encode(payload));
  const hashArray = Array.from(new Uint8Array(mac));
  const expected = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  
  if (expected.length !== signature.length || !timingSafeEqual(expected, signature)) {
    throw new Error('Signature mismatch');
  }
}

function timingSafeEqual(a: string, b: string) {
  let mismatch = a.length ^ b.length;
  for (let i = 0; i < Math.min(a.length, b.length); i++) {
    mismatch |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  return mismatch === 0;
}

Deno.serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return corsPreflightResponse();
  }

  const url = new URL(req.url);
  const supabase = createSupabaseClient();
  
  try {
    // Webhook verification (GET request from Meta)
    if (req.method === 'GET') {
      const mode = url.searchParams.get('hub.mode');
      const token = url.searchParams.get('hub.verify_token');
      const challenge = url.searchParams.get('hub.challenge');

      console.log('Webhook verification request:', { mode, token, challenge });

      // For verification, we can use global token as fallback since we don't know the Instagram user yet
      const WEBHOOK_VERIFY_TOKEN = Deno.env.get('WEBHOOK_VERIFY_TOKEN');
      
      if (!WEBHOOK_VERIFY_TOKEN) {
        console.error('WEBHOOK_VERIFY_TOKEN is not configured');
        return new Response('Server misconfigured', { status: 500, headers: corsHeaders });
      }

      if (mode === 'subscribe' && token === WEBHOOK_VERIFY_TOKEN) {
        console.log('Webhook verified successfully');
        return new Response(challenge, { 
          status: 200,
          headers: { 'Content-Type': 'text/plain' }
        });
      } else {
        console.log('Webhook verification failed');
        return new Response('Forbidden', { status: 403, headers: corsHeaders });
      }
    }

    // Handle webhook events (POST request from Instagram)
    if (req.method === 'POST') {
      // Read raw body for signature verification
      const rawBody = await req.text();
      const signatureHeader = req.headers.get('x-hub-signature-256') || req.headers.get('X-Hub-Signature-256');
      
      const body = rawBody ? JSON.parse(rawBody) : {};
      console.log('Instagram webhook received:', { object: body.object, entries: Array.isArray(body.entry) ? body.entry.length : 0 });

      // Process webhook data
      if (body.object === 'instagram') {
        for (const entry of body.entry || []) {
          console.log('Processing entry ID:', entry.id);
          
          // Verify signature using organization-specific credentials if possible
          try {
            await verifyXHubSignature(supabase, rawBody, signatureHeader, entry.id);
            console.log('Webhook signature verified successfully for entry:', entry.id);
          } catch (e) {
            const errorMessage = e instanceof Error ? e.message : String(e);
            console.error('Invalid webhook signature for entry:', entry.id, errorMessage);
            
            // Try to log which credentials were attempted
            try {
              const credentials = await getWebhookCredentials(supabase, entry.id);
              console.error('Signature validation failed using:', {
                has_org_secret: !!credentials.APP_SECRET && credentials.APP_SECRET !== Deno.env.get('INSTAGRAM_APP_SECRET'),
                using_fallback: credentials.APP_SECRET === Deno.env.get('INSTAGRAM_APP_SECRET'),
                signature_header: signatureHeader ? `${signatureHeader.substring(0, 15)}...` : 'missing'
              });
            } catch (credError) {
              console.error('Could not log credential info:', credError);
            }
            
            return new Response(JSON.stringify({ error: 'invalid_signature' }), {
              status: 401,
              headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
          }
          
          // Handle different types of changes
          if (entry.changes) {
            for (const change of entry.changes) {
              switch (change.field) {
                case 'media':
                  await handleMediaChange(supabase, change.value, entry.id);
                  break;
                case 'comments':
                  await handleComments(supabase, change.value, entry.id);
                  break;
                case 'messages':
                  await handleMessages(supabase, change.value, entry.id);
                  break;
                case 'story_insights':
                  await handleStoryInsights(supabase, change.value, entry.id);
                  break;
                default:
                  console.log('Unhandled webhook field:', change.field);
              }
            }
          }

          // Handle messaging events
          if (entry.messaging) {
            for (const message of entry.messaging) {
              // Check if it's a story mention referral
              if (message.referral && message.referral.source === 'SHORTLINK' && message.referral.type === 'STORY') {
                await handleStoryMentionReferral(supabase, message, entry.id);
              } else {
                await handleMessages(supabase, message, entry.id);
              }
            }
          }
        }
      }

      return new Response(JSON.stringify({ received: true }), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    return new Response('Method not allowed', { status: 405 });

  } catch (error) {
    return handleError(error);
  }
});

async function handleMediaChange(supabase: SupabaseClient, mediaData: MediaData, instagramUserId: string): Promise<void> {
  try {
    console.log('Handling media change:', { mediaId: mediaData?.id, instagramUserId });

    // First try to find organization by Instagram user ID
    const { data: organization, error: orgError } = await supabase
      .from('organizations')
      .select('id, name, instagram_handle')
      .eq('instagram_user_id', instagramUserId)
      .maybeSingle();

    if (orgError || !organization) {
      console.log('Organization not found for Instagram user:', instagramUserId);
      return;
    }

    // Try to find ambassador by Instagram user ID first
    let ambassador: Ambassador | null = null;
    
    const { data: ambassadorById, error: ambassadorByIdError } = await supabase
      .from('embassadors')
      .select('*')
      .eq('instagram_user_id', instagramUserId)
      .eq('organization_id', organization.id)
      .maybeSingle();

    if (!ambassadorByIdError && ambassadorById) {
      ambassador = ambassadorById;
    } else {
      // Fallback: try to find by normalized username if we have media info with username
      if (mediaData.username) {
        const normalizedUsername = mediaData.username.toLowerCase().replace('@', '');
        const { data: ambassadorByUsername, error: ambassadorByUsernameError } = await supabase
          .from('embassadors')
          .select('*')
          .eq('organization_id', organization.id)
          .ilike('instagram_user', `%${normalizedUsername}%`)
          .maybeSingle();

        if (!ambassadorByUsernameError && ambassadorByUsername) {
          ambassador = ambassadorByUsername;
        }
      }
    }

    // Create entry in social_mentions table
    const mentionData = {
      organization_id: organization.id,
      instagram_user_id: instagramUserId,
      instagram_username: mediaData.username || null,
      content: `Historia de Instagram subida`,
      mention_type: 'story',
      instagram_media_id: mediaData.id,
      story_url: null, // This will be updated later if available
      platform: 'instagram',
      raw_data: mediaData,
      matched_ambassador_id: ambassador?.id || null,
      processed: ambassador ? true : false
    };

    const { data: socialMention, error: mentionError } = await supabase
      .from('social_mentions')
      .insert(mentionData)
      .select()
      .single();

    if (mentionError) {
      console.error('Error creating social mention:', mentionError);
    }

    if (ambassador) {
      // Create notification for matched ambassador
      await supabase
        .from('notifications')
        .insert({
          organization_id: ambassador.organization_id,
          type: 'story_uploaded',
          message: `${ambassador.first_name} ${ambassador.last_name} subi√≥ nuevo contenido en Instagram`,
          target_type: 'ambassador',
          target_id: ambassador.id,
        });
    } else {
      // Create notification for unassigned story
      await supabase
        .from('notifications')
        .insert({
          organization_id: organization.id,
          type: 'story_unassigned',
          message: `Nueva historia de @${mediaData.username || instagramUserId} no asignada a ning√∫n embajador`,
          target_type: 'story',
          target_id: socialMention?.id,
          priority: 'high'
        });

      console.log('Ambassador not found for Instagram user:', instagramUserId, 'username:', mediaData.username);
    }

  } catch (error) {
    console.error('Error handling media change:', error);
  }
}

async function handleComments(supabase: SupabaseClient, commentData: CommentData, instagramUserId: string): Promise<void> {
  try {
    console.log('Handling comment:', { instagramUserId, commentId: commentData?.id });

    // Find organization by Instagram user ID
    const { data: organization, error: orgError } = await supabase
      .from('organizations')
      .select('id, name, instagram_handle')
      .eq('instagram_user_id', instagramUserId)
      .maybeSingle();

    if (orgError || !organization) {
      console.log('Organization not found for Instagram user:', instagramUserId);
      return;
    }

    // Try to find ambassador by username if available
    let ambassador: Ambassador | null = null;
    if (commentData.from?.username) {
      const { data: ambassadorByUsername, error: ambassadorError } = await supabase
        .from('embassadors')
        .select('*')
        .eq('instagram_user', commentData.from.username)
        .eq('organization_id', organization.id)
        .maybeSingle();

      if (!ambassadorError && ambassadorByUsername) {
        ambassador = ambassadorByUsername;
      }
    }

    // Create entry in social_mentions table
    const mentionData = {
      organization_id: organization.id,
      instagram_user_id: commentData.from?.id || null,
      instagram_username: commentData.from?.username || null,
      content: commentData.text || 'Comentario en Instagram',
      mention_type: 'comment',
      instagram_media_id: commentData.media?.id || null,
      platform: 'instagram',
      raw_data: commentData,
      matched_ambassador_id: ambassador?.id || null,
      processed: ambassador ? true : false
    };

    const { data: socialMention, error: mentionError } = await supabase
      .from('social_mentions')
      .insert(mentionData)
      .select()
      .single();

    if (mentionError) {
      console.error('Error creating social mention for comment:', mentionError);
      return;
    }

    if (ambassador) {
      // Create notification for assigned comment
      await supabase
        .from('notifications')
        .insert({
          organization_id: organization.id,
          type: 'mention',
          message: `${ambassador.first_name} ${ambassador.last_name} ha comentado en Instagram`,
          target_type: 'comment',
          target_id: socialMention.id,
          priority: 'normal'
        });
    } else {
      // Create notification for unassigned comment
      await supabase
        .from('notifications')
        .insert({
          organization_id: organization.id,
          type: 'mention_unassigned',
          message: `Nuevo comentario de @${commentData.from?.username || 'usuario desconocido'} - No asignado a embajador`,
          target_type: 'comment',
          target_id: socialMention.id,
          priority: 'medium'
        });
    }

    console.log('Comment notification created for organization:', organization.id);

  } catch (error) {
    console.error('Error handling comment:', error);
  }
}

async function handleMessages(supabase: SupabaseClient, messageData: MessageData, instagramUserId: string): Promise<void> {
  try {
    console.log('Handling message:', { instagramUserId, messageId: messageData?.id });

    // Find organization by Instagram user ID
    const { data: organization, error: orgError } = await supabase
      .from('organizations')
      .select('id, name, instagram_handle')
      .eq('instagram_user_id', instagramUserId)
      .maybeSingle();

    if (orgError || !organization) {
      console.log('Organization not found for Instagram user:', instagramUserId);
      return;
    }

    // Try to find ambassador by user ID if available
    let ambassador: Ambassador | null = null;
    if (messageData.sender?.id) {
      const { data: ambassadorById, error: ambassadorError } = await supabase
        .from('embassadors')
        .select('*')
        .eq('instagram_user_id', messageData.sender.id)
        .eq('organization_id', organization.id)
        .maybeSingle();

      if (!ambassadorError && ambassadorById) {
        ambassador = ambassadorById;
      }
    }

    // Create entry in social_mentions table
    const mentionData = {
      organization_id: organization.id,
      instagram_user_id: messageData.sender?.id || null,
      instagram_username: messageData.sender?.username || null,
      content: messageData.text || 'Mensaje directo de Instagram',
      mention_type: 'mention',
      platform: 'instagram',
      raw_data: messageData,
      matched_ambassador_id: ambassador?.id || null,
      processed: ambassador ? true : false
    };

    const { data: socialMention, error: mentionError } = await supabase
      .from('social_mentions')
      .insert(mentionData)
      .select()
      .single();

    if (mentionError) {
      console.error('Error creating social mention for message:', mentionError);
      return;
    }

    if (ambassador) {
      // Create notification for assigned message
      await supabase
        .from('notifications')
        .insert({
          organization_id: organization.id,
          type: 'message',
          message: `${ambassador.first_name} ${ambassador.last_name} ha enviado un mensaje directo`,
          target_type: 'message',
          target_id: socialMention.id,
          priority: 'normal'
        });
    } else {
      // Create notification for unassigned message
      await supabase
        .from('notifications')
        .insert({
          organization_id: organization.id,
          type: 'message_unassigned',
          message: `Nuevo mensaje directo de @${messageData.sender?.username || 'usuario desconocido'} - No asignado a embajador`,
          target_type: 'message',
          target_id: socialMention.id,
          priority: 'medium'
        });
    }

    console.log('Message notification created for organization:', organization.id);

  } catch (error) {
    console.error('Error handling message:', error);
  }
}

async function handleStoryMentionReferral(supabase: SupabaseClient, messageData: MessageData, instagramBusinessAccountId: string): Promise<void> {
  try {
    console.log('Handling story mention referral (sanitized):', { 
      instagramBusinessAccountId, 
      senderId: messageData.sender?.id,
      referralSource: messageData.referral?.source,
      referralType: messageData.referral?.type,
      hasRefererUri: !!messageData.referral?.referer_uri
    });

    // Find organization by Instagram business account ID
    const { data: organization, error: orgError } = await supabase
      .from('organizations')
      .select('id, name, instagram_username, facebook_page_id')
      .eq('instagram_business_account_id', instagramBusinessAccountId)
      .maybeSingle();

    if (orgError || !organization) {
      console.log('Organization not found for Instagram business account:', instagramBusinessAccountId);
      return;
    }

    // Extract mention time from message timestamp or use current time
    const mentionedAt = messageData.timestamp ? new Date(messageData.timestamp * 1000).toISOString() : new Date().toISOString();

    // Ensure sender exists
    if (!messageData.sender?.id) {
      console.log('No sender ID in story mention referral');
      return;
    }

    // Create unique external event ID for idempotency
    const externalEventId = `story_referral_${messageData.mid || messageData.id}_${messageData.sender.id}`;

    // Check if we already processed this event using the new unique index
    const { data: existingMention, error: checkError } = await supabase
      .from('social_mentions')
      .select('id')
      .eq('organization_id', organization.id)
      .eq('instagram_user_id', messageData.sender.id)
      .eq('mentioned_at', mentionedAt)
      .eq('mention_type', 'story_referral')
      .maybeSingle();

    if (checkError) {
      console.error('Error checking for existing mention:', checkError);
      return;
    }

    if (existingMention) {
      console.log('Story mention referral already processed for user:', messageData.sender.id, 'at:', mentionedAt);
      return;
    }

    // Try to find ambassador by Instagram user ID
    let ambassador: Ambassador | null = null;
    if (messageData.sender?.id) {
      const { data: ambassadorById, error: ambassadorError } = await supabase
        .from('embassadors')
        .select('*')
        .eq('instagram_user_id', messageData.sender.id)
        .eq('organization_id', organization.id)
        .maybeSingle();

      if (!ambassadorError && ambassadorById) {
        ambassador = ambassadorById;
      }
    }

    // Extract story URL and try to build deep link
    const storyUrl = messageData.referral?.referer_uri || null;
    let deepLink: string | null = null;
    
    // Try to extract story ID from referral for deep link
    if (messageData.referral?.ref) {
      const storyId = messageData.referral.ref;
      // Try to build Instagram deep link (may not always work)
      deepLink = `instagram://story-camera/?ref=${storyId}`;
    } else if (storyUrl && storyUrl.includes('instagram.com')) {
      deepLink = storyUrl;
    }
    
    // If no deep link possible, create profile link
    if (!deepLink && messageData.sender?.username) {
      deepLink = `https://instagram.com/${messageData.sender.username}`;
    }

    // Extract conversation ID and build inbox link
    const conversationId = messageData.mid || messageData.id || null;
    let inboxLink: string | null = null;
    
    // Build Instagram inbox link if we have conversation ID and page info
    if (conversationId && organization.facebook_page_id) {
      // Meta Business Inbox link format for Instagram conversations
      inboxLink = `https://business.facebook.com/latest/inbox/instagram/${organization.facebook_page_id}/?conversation_id=${conversationId}`;
    }
    
    // Create entry in social_mentions table
    const mentionData = {
      organization_id: organization.id,
      external_event_id: externalEventId,
      recipient_page_id: organization.facebook_page_id,
      instagram_user_id: messageData.sender?.id || null,
      instagram_username: messageData.sender?.username || null,
      content: `Menci√≥n desde historia de Instagram - ${messageData.text || 'Usuario lleg√≥ a trav√©s de referencia de historia'}`,
      mention_type: 'story_referral',
      platform: 'instagram',
      story_url: storyUrl,
      instagram_story_id: messageData.referral?.ref || null,
      raw_data: messageData,
      matched_ambassador_id: ambassador?.id || null,
      processed: false, // Always start as unprocessed for story mentions
      reach_count: 0,
      engagement_score: 1.0, // Story mentions have high engagement value
      mentioned_at: mentionedAt,
      state: 'new',
      deep_link: deepLink,
      conversation_id: conversationId,
      inbox_link: inboxLink
    };

    const { data: socialMention, error: mentionError } = await supabase
      .from('social_mentions')
      .insert(mentionData)
      .select()
      .single();

    if (mentionError) {
      console.error('Error creating social mention for story referral:', mentionError);
      return;
    }

    // Always create a notification for story mentions (high priority)
    const notificationMessage = ambassador 
      ? `${ambassador.first_name} ${ambassador.last_name} mencion√≥ tu historia y envi√≥ un mensaje`
      : `Nueva menci√≥n de historia de @${messageData.sender?.username || 'usuario desconocido'} - Requiere atenci√≥n`;

    await supabase
      .from('notifications')
      .insert({
        organization_id: organization.id,
        type: 'story_mention_referral',
        message: notificationMessage,
        target_type: 'story_mention',
        target_id: socialMention.id,
        priority: 'high' // Story mentions are always high priority
      });

    console.log('Story mention referral processed successfully for organization:', organization.id);

  } catch (error) {
    console.error('Error handling story mention referral:', error);
  }
}



async function handleStoryInsights(supabase: SupabaseClient, insightsData: InsightsData, instagramBusinessAccountId: string): Promise<void> {
  try {
    console.log('Handling story insights webhook:', { 
      instagramBusinessAccountId,
      mediaId: insightsData?.media_id,
      hasMetrics: !!insightsData?.metric_values
    });

    // Find organization by Instagram business account ID
    const { data: organization, error: orgError } = await supabase
      .from('organizations')
      .select('id, name')
      .eq('instagram_business_account_id', instagramBusinessAccountId)
      .maybeSingle();

    if (orgError || !organization) {
      console.log('Organization not found for Instagram business account:', instagramBusinessAccountId);
      return;
    }

    const mediaId = insightsData?.media_id || insightsData?.id;
    
    if (!mediaId) {
      console.log('No media ID in story insights data');
      return;
    }

    // Try to find the story in our social_mentions table
    const { data: storyMention, error: mentionError } = await supabase
      .from('social_mentions')
      .select('id, instagram_story_id, instagram_media_id, mentioned_at')
      .eq('organization_id', organization.id)
      .or(`instagram_story_id.eq.${mediaId},instagram_media_id.eq.${mediaId}`)
      .maybeSingle();

    if (mentionError) {
      console.error('Error finding story mention:', mentionError);
      return;
    }

    // Parse insights metrics from webhook data
    interface MetricsMap {
      impressions?: number;
      reach?: number;
      replies?: number;
      exits?: number;
      taps_forward?: number;
      taps_back?: number;
      shares?: number;
      navigation?: Record<string, unknown>;
      raw?: InsightsData;
      [key: string]: number | Record<string, unknown> | InsightsData | undefined;
    }
    
    const metrics: MetricsMap = {
      raw: insightsData
    };

    // The webhook data structure varies, but typically contains metric_values
    if (insightsData.metric_values) {
      for (const metric of insightsData.metric_values) {
        if (metric.name && metric.value !== undefined) {
          metrics[metric.name] = metric.value;
        }
      }
    }

    // If we found the story mention, create a snapshot
    if (storyMention) {
      // Calculate story age
      const storyAge = storyMention.mentioned_at 
        ? (new Date().getTime() - new Date(storyMention.mentioned_at).getTime()) / (1000 * 60 * 60)
        : null;

      const snapshot = {
        social_mention_id: storyMention.id,
        organization_id: organization.id,
        instagram_story_id: storyMention.instagram_story_id,
        instagram_media_id: mediaId,
        snapshot_at: new Date().toISOString(),
        story_age_hours: storyAge,
        impressions: metrics.impressions || 0,
        reach: metrics.reach || 0,
        replies: metrics.replies || 0,
        exits: metrics.exits || 0,
        taps_forward: metrics.taps_forward || 0,
        taps_back: metrics.taps_back || 0,
        shares: metrics.shares || 0,
        navigation: metrics.navigation || {},
        raw_insights: metrics.raw || {}
      };

      const { error: insertError } = await supabase
        .from('story_insights_snapshots')
        .insert(snapshot);

      if (insertError) {
        console.error('Error inserting story insights snapshot:', insertError);
      } else {
        console.log(`Created story insights snapshot from webhook for story ${mediaId}`);
      }
    } else {
      // Story not found in our database yet - this might be a story we don't track
      // or it might arrive before the story_mention webhook
      console.log(`Story insights received for media ${mediaId} but story mention not found yet`);
      
      // We could optionally queue this for later processing or create a placeholder
      // For now, we'll just log it
    }

  } catch (error) {
    console.error('Error handling story insights:', error);
  }
}
</file>

<file path="supabase/functions/resolve-story-mentions/index.ts">
import { corsHeaders, INSTAGRAM_API_BASE } from '../shared/constants.ts';
import { MediaItem, SupabaseClient } from '../shared/types.ts';
import { corsPreflightResponse, jsonResponse } from '../shared/responses.ts';
import { createSupabaseClient } from '../shared/auth.ts';
import { handleError } from '../shared/error-handler.ts';
import { safeDecryptToken } from '../shared/crypto.ts';

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return corsPreflightResponse();
  }

  try {
    const supabase = createSupabaseClient();

    const { organizationId, mentionId } = await req.json();
    
    // Validate required parameters
    if (!mentionId) {
      console.error('Missing mentionId parameter');
      return jsonResponse({ 
        success: false, 
        error: 'Missing mentionId parameter' 
      }, { status: 400 });
    }

    if (!organizationId) {
      console.error('Missing organizationId parameter');
      return jsonResponse({ 
        success: false, 
        error: 'Missing organizationId parameter' 
    }, { status: 400 });
    }

    console.log(`Resolving story mention ${mentionId} for organization ${organizationId}`);

    // Get the mention record
    const { data: mention, error: mentionError } = await supabase
      .from('social_mentions')
      .select('*')
      .eq('id', mentionId)
      .eq('mention_type', 'story_referral')
      .single();

    if (mentionError || !mention) {
      console.error('Mention not found:', mentionError);
      return jsonResponse({ 
        success: false, 
        error: 'Mention not found' 
      }, { status: 404 });
    }

    // Get organization Instagram tokens
    const { data: tokenInfo } = await supabase
      .from('organization_instagram_tokens')
      .select('access_token, token_expiry')
      .eq('organization_id', organizationId)
      .single();

    if (!tokenInfo || !tokenInfo.access_token) {
      console.error('No Instagram token found for organization');
      
      // Mark as unverifiable
      await supabase
        .from('social_mentions')
        .update({ 
          state: 'expired_unknown',
          processed: true,
          processed_at: new Date().toISOString()
        })
        .eq('id', mentionId);

      return jsonResponse({ 
        success: false, 
        error: 'No Instagram access token available' 
    }, { status: 400 });
    }

    // Check if token is expired
    if (tokenInfo.token_expiry && new Date(tokenInfo.token_expiry) < new Date()) {
      console.error('Instagram token expired');
      
      await supabase
        .from('social_mentions')
        .update({ 
          state: 'expired_unknown',
          processed: true,
          processed_at: new Date().toISOString()
        })
        .eq('id', mentionId);

      return jsonResponse({ 
        success: false, 
        error: 'Instagram access token expired' 
    }, { status: 400 });
    }

    // Decrypt token for API calls
    const decryptedToken = await safeDecryptToken(tokenInfo.access_token);

    // Try to resolve mentioned_media from Instagram API
    if (mention.instagram_user_id) {
      try {
        const response = await fetch(
          `${INSTAGRAM_API_BASE}/${mention.instagram_user_id}?fields=mentioned_media.media_type,media_product_type,owner,username,timestamp,permalink&access_token=${decryptedToken}`
        );

        if (response.ok) {
          const data = await response.json();
          
          if (data.mentioned_media && data.mentioned_media.data) {
            // Find story media close to the mention timestamp
            const mentionTime = new Date(mention.mentioned_at).getTime();
            const timeWindow = 5 * 60 * 1000; // 5 minutes window
            
            const storyMedia = data.mentioned_media.data.find((media: MediaItem) => {
              const mediaTime = new Date(media.timestamp).getTime();
              return (
                media.media_product_type === 'STORY' &&
                Math.abs(mediaTime - mentionTime) <= timeWindow
              );
            });

            if (storyMedia) {
              // Update mention with resolved data
              const { error: updateError } = await supabase
                .from('social_mentions')
                .update({
                  story_url: storyMedia.permalink || null,
                  instagram_story_id: storyMedia.id || null,
                  raw_data: { ...mention.raw_data, resolved_media: storyMedia }
                })
                .eq('id', mentionId);

              if (updateError) {
                console.error('Error updating mention with resolved data:', updateError);
              } else {
                console.log('Successfully resolved story media for mention');
              }

              return jsonResponse({ 
                success: true,
                resolved: true,
                story_url: storyMedia.permalink,
                story_id: storyMedia.id
              });
            }
          }
        }
      } catch (error) {
        console.error('Error calling Instagram API:', error);
      }
    }

    // If we couldn't resolve, create fallback deep link
    const fallbackLink = mention.instagram_username 
      ? `https://www.instagram.com/stories/${mention.instagram_username}/`
      : `https://www.instagram.com/${mention.instagram_username || 'unknown'}/`;

    const { error: updateError } = await supabase
      .from('social_mentions')
      .update({
        deep_link: fallbackLink,
        raw_data: { ...mention.raw_data, resolution_attempt: new Date().toISOString() }
      })
      .eq('id', mentionId);

    if (updateError) {
      console.error('Error updating mention with fallback:', updateError);
    }

    return jsonResponse({ 
      success: true,
      resolved: false,
      fallback_link: fallbackLink
    });

  } catch (error) {
    return handleError(error);
  }
});
</file>

<file path="supabase/functions/shared/constants.ts">
/**
 * Shared constants for Supabase Edge Functions
 * Centralized configuration to reduce duplication
 */

/**
 * CORS headers for all functions
 */
export const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, x-cron-secret',
} as const;

/**
 * Instagram API with Instagram Login - v24.0
 */
export const INSTAGRAM_API_VERSION = 'v24.0' as const;
export const INSTAGRAM_API_BASE = `https://graph.instagram.com/${INSTAGRAM_API_VERSION}` as const;

// Instagram OAuth endpoints
export const INSTAGRAM_OAUTH_AUTHORIZE = 'https://www.instagram.com/oauth/authorize';
export const INSTAGRAM_OAUTH_TOKEN = 'https://api.instagram.com/oauth/access_token';
export const INSTAGRAM_TOKEN_EXCHANGE = `https://graph.instagram.com/access_token`;
export const INSTAGRAM_TOKEN_REFRESH = `https://graph.instagram.com/refresh_access_token`;

// Instagram scopes (new format as of Jan 27, 2025)
export const INSTAGRAM_SCOPES = [
  'instagram_business_basic',           // Required for basic profile access
  'instagram_business_manage_insights', // Required for insights API
  'instagram_business_manage_messages', // For messaging features
  'instagram_business_content_publish'  // For content publishing features
].join(',');

/**
 * Story insights metrics to fetch from Instagram API
 * See: https://developers.facebook.com/docs/instagram-platform/reference/instagram-media/insights
 * 
 * Available STORY metrics:
 * - reach: Unique accounts that viewed the story
 * - replies: Total replies on the story
 * - profile_visits: Number of profile visits from the story
 * - total_interactions: Likes, saves, comments, shares minus unlikes/unsaves/deleted
 * - shares: Number of shares
 * - navigation: Total navigation actions (with breakdown available)
 * - views: Total views (in development)
 * 
 * Note: 'impressions' was deprecated in v22.0+ for media created after July 2, 2024
 */
export const STORY_INSIGHTS_METRICS = [
  'reach',
  'replies',
  'profile_visits',
  'total_interactions',
  'shares',
  'navigation',
  'views'
].join(',');

/**
 * Verification intervals for story state worker (in minutes)
 */
export const VERIFICATION_INTERVALS = [60, 720, 1380] as const; // 1h, 12h, 23h

/**
 * Story expiration time (24 hours in milliseconds)
 */
export const STORY_EXPIRATION_MS = 24 * 60 * 60 * 1000;

/**
 * Default token expiry (60 days in milliseconds) when Meta doesn't provide it
 */
export const DEFAULT_TOKEN_EXPIRY_MS = 60 * 24 * 60 * 60 * 1000;
</file>

<file path="supabase/functions/shared/crypto.test.ts">
/**
 * Test script for crypto functions
 * Run with: deno run --allow-env --allow-net supabase/functions/shared/crypto.test.ts
 */

import { encryptToken, decryptToken, isEncrypted, migrateToken, safeDecryptToken } from './crypto.ts';

async function testCrypto() {
  console.log('üß™ Testing crypto functions...\n');

  // Test token
  const testToken = "p96SboOg6zcEJZPHTNahwAm3B5/y65AESw1Jv91Ox4KaCzguWe+X1ihAG21m1YH7qVOZixTQSwJUNZ8nhzwU/rEHXmVAsLpcSeizDZeGAktdS9DvkE2RxKtCKpmIA6sEhU9Jc3qEKEtyVsvIqzUGbGQyKG0ta1d7wKPacFLqFpOZSC+ttixC2pD8qWk6EoMWtDFEoY0l1ASfHFoAkbcTfsweZcPMt1tuwYiXLOTVH3995lNW0KWLUSEfV2MNFuXBi5OD+n58F2/rwH8tL5jC8hvm7KO+aJ1gatI5eGxRAmSY";

  try {
    // Test 1: Check if token is encrypted
    console.log('Test 1: Checking if token is encrypted...');
    const isEnc = isEncrypted(testToken);
    console.log(`   Result: ${isEnc ? 'Encrypted' : 'Plain text'}\n`);

    // Test 2: Encrypt a plain text token
    console.log('Test 2: Encrypting token...');
    const plainToken = "test_token_12345";
    const encrypted = await encryptToken(plainToken);
    console.log(`   Encrypted: ${encrypted.substring(0, 50)}...\n`);

    // Test 3: Decrypt the encrypted token
    console.log('Test 3: Decrypting token...');
    const decrypted = await decryptToken(encrypted);
    console.log(`   Decrypted: ${decrypted}`);
    console.log(`   Match: ${decrypted === plainToken ? '‚úÖ' : '‚ùå'}\n`);

    // Test 4: Try to decrypt the test token (if it's encrypted)
    if (isEnc) {
      console.log('Test 4: Decrypting provided token...');
      try {
        const decryptedTest = await decryptToken(testToken);
        console.log(`   Decrypted: ${decryptedTest}\n`);
      } catch (error) {
        console.log(`   ‚ö†Ô∏è  Could not decrypt (likely encrypted with different key): ${error instanceof Error ? error.message : String(error)}\n`);
      }
    } else {
      console.log('Test 4: Token is plain text, encrypting it...');
      const encryptedTest = await encryptToken(testToken);
      console.log(`   Encrypted: ${encryptedTest.substring(0, 50)}...\n`);
    }

    // Test 5: Test migrateToken
    console.log('Test 5: Testing migrateToken...');
    const migrated = await migrateToken(plainToken);
    console.log(`   Migrated: ${migrated.substring(0, 50)}...`);
    console.log(`   Is encrypted: ${isEncrypted(migrated) ? '‚úÖ' : '‚ùå'}\n`);

    // Test 6: Test safeDecryptToken
    console.log('Test 6: Testing safeDecryptToken...');
    const safeDecrypted = await safeDecryptToken(encrypted);
    console.log(`   Safe decrypted: ${safeDecrypted}`);
    console.log(`   Match: ${safeDecrypted === plainToken ? '‚úÖ' : '‚ùå'}\n`);

    console.log('‚úÖ All tests completed!');
  } catch (error) {
    console.error('‚ùå Test failed:', error);
    Deno.exit(1);
  }
}

// Run tests
testCrypto();
</file>

<file path="supabase/functions/shared/crypto.ts">
/**
 * Cryptographic utilities for secure token storage
 * Uses AES-GCM encryption with base64 encoding
 */

const ALGORITHM = 'AES-GCM';
const IV_LENGTH = 12; // 96 bits for GCM

/**
 * Get encryption key from environment
 */
async function getEncryptionKey(): Promise<CryptoKey> {
  const keyHex = Deno.env.get('TOKEN_ENCRYPTION_KEY');
  if (!keyHex) {
    throw new Error('TOKEN_ENCRYPTION_KEY not configured');
  }

  // validate: exactly 64 hex chars
  if (!/^[0-9a-fA-F]{64}$/.test(keyHex)) {
    throw new Error('TOKEN_ENCRYPTION_KEY must be 64 hex characters (32 bytes).');
  }

  const keyBytes = new Uint8Array(
    keyHex.match(/.{2}/g)!.map((b) => parseInt(b, 16))
  );

  return await crypto.subtle.importKey(
    'raw',
    keyBytes,
    { name: ALGORITHM },
    false,
    ['encrypt', 'decrypt'],
  );
}

/**
 * Encrypt a token string
 */
export async function encryptToken(token: string): Promise<string> {
  try {
    const key = await getEncryptionKey();
    const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));
    const encodedToken = new TextEncoder().encode(token);
    
    const encrypted = await crypto.subtle.encrypt(
      { name: ALGORITHM, iv },
      key,
      encodedToken
    );
    
    // Combine IV + encrypted data and encode as base64
    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv, 0);
    combined.set(new Uint8Array(encrypted), iv.length);
    
    return btoa(String.fromCharCode(...combined));
  } catch (error) {
    console.error('Token encryption failed (raw):', error);
    throw new Error(
      `Failed to encrypt token: ${
        error instanceof Error ? error.message : String(error)
      }`,
    );
  }
}

/**
 * Decrypt a token string
 */
export async function decryptToken(encryptedToken: string): Promise<string> {
  try {
    const key = await getEncryptionKey();
    const combined = new Uint8Array(
      atob(encryptedToken).split('').map(char => char.charCodeAt(0))
    );
    
    // Extract IV and encrypted data
    const iv = combined.slice(0, IV_LENGTH);
    const encrypted = combined.slice(IV_LENGTH);
    
    const decrypted = await crypto.subtle.decrypt(
      { name: ALGORITHM, iv },
      key,
      encrypted
    );
    
    return new TextDecoder().decode(decrypted);
  } catch (error) {
    console.error('Token decryption failed:', error);
    throw new Error(
      `Failed to decrypt token: ${
        error instanceof Error ? error.message : String(error)
      }`,
    );
  }
}

/**
 * Check if a string looks like an encrypted token (base64)
 */
export function isEncrypted(value: string): boolean {
  try {
    // Check if it's valid base64 and has reasonable length
    const decoded = atob(value);
    return decoded.length > IV_LENGTH && value.length > 16;
  } catch {
    return false;
  }
}

/**
 * Safely migrate plain text token to encrypted
 */
export async function migrateToken(token: string): Promise<string> {
  // If already encrypted, return as-is
  if (isEncrypted(token)) {
    return token;
  }
  
  // Otherwise encrypt it
  return await encryptToken(token);
}

/**
 * Safely decrypt token (handles both encrypted and plain text)
 * This is for backward compatibility during migration
 */
export async function safeDecryptToken(token: string): Promise<string> {
  // If it looks like plain text, return as-is
  if (!isEncrypted(token)) {
    console.warn('Found unencrypted token - consider migrating');
    return token;
  }
  
  // Otherwise decrypt it
  return await decryptToken(token);
}
</file>

<file path="supabase/functions/shared/instagram-api.ts">
/**
 * Instagram API Utilities
 * Centralized Instagram Graph API interactions
 */

import { INSTAGRAM_API_BASE, STORY_INSIGHTS_METRICS } from './constants.ts';
import { StoryInsights, MediaItem } from './types.ts';

export class InstagramApiError extends Error {
  constructor(
    message: string,
    public statusCode?: number,
    public fbError?: unknown
  ) {
    super(message);
    this.name = 'InstagramApiError';
  }
}

/**
 * Build Instagram Graph API URL
 */
export function buildInstagramApiUrl(
  endpoint: string,
  params?: Record<string, string>
): string {
  const url = new URL(`${INSTAGRAM_API_BASE}/${endpoint}`);
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      url.searchParams.set(key, value);
    });
  }
  return url.toString();
}

/**
 * Fetch story insights from Instagram API
 * See: https://developers.facebook.com/docs/instagram-platform/reference/instagram-media/insights
 */
export async function fetchStoryInsights(
  storyId: string,
  accessToken: string
): Promise<StoryInsights | null> {
  try {
    const url = buildInstagramApiUrl(`${storyId}/insights`, {
      metric: STORY_INSIGHTS_METRICS,
      access_token: accessToken
    });
    
    const response = await fetch(url);
    
    if (!response.ok) {
      const error = await response.json();
      throw new InstagramApiError(
        `Failed to fetch insights: ${error.error?.message || 'Unknown error'}`,
        response.status,
        error
      );
    }
    
    const data = await response.json();
    const insights: StoryInsights = {
      reach: 0,
      replies: 0,
      shares: 0,
      profile_visits: 0,
      total_interactions: 0,
      views: 0,
      navigation: undefined
    };
    
    for (const metric of data.data || []) {
      const value = metric.values?.[0]?.value;
      
      switch (metric.name) {
        case 'reach':
          insights.reach = value || 0;
          break;
        case 'replies':
          insights.replies = value || 0;
          break;
        case 'shares':
          insights.shares = value || 0;
          break;
        case 'profile_visits':
          insights.profile_visits = value || 0;
          break;
        case 'total_interactions':
          insights.total_interactions = value || 0;
          break;
        case 'views':
          insights.views = value || 0;
          break;
        case 'navigation':
          // Navigation can be a number or have breakdown data
          if (typeof value === 'number') {
            insights.navigation = value;
          } else if (metric.total_value?.breakdowns?.[0]?.results) {
            // Parse breakdown: tap_forward, tap_back, tap_exit, swipe_forward
            const breakdown: Record<string, number> = {};
            for (const result of metric.total_value.breakdowns[0].results) {
              const key = result.dimension_values?.[0];
              if (key) {
                breakdown[key] = result.value || 0;
              }
            }
            insights.navigation = breakdown;
            // Populate legacy fields for backwards compatibility
            insights.exits = breakdown.tap_exit || 0;
            insights.taps_forward = (breakdown.tap_forward || 0) + (breakdown.swipe_forward || 0);
            insights.taps_back = breakdown.tap_back || 0;
          }
          break;
        // Legacy metric (deprecated but might still be returned for old stories)
        case 'impressions':
          insights.impressions = value || 0;
          break;
      }
    }
    
    return insights;
  } catch (error) {
    if (error instanceof InstagramApiError) throw error;
    console.error('Error fetching story insights:', error);
    return null;
  }
}

/**
 * Fetch media items from Instagram account
 */
export async function fetchAccountMedia(
  accountId: string,
  accessToken: string,
  options: {
    fields?: string;
    limit?: number;
  } = {}
): Promise<MediaItem[]> {
  const {
    fields = 'id,media_type,media_product_type,timestamp',
    limit = 50
  } = options;
  
  const url = buildInstagramApiUrl(`${accountId}/media`, {
    fields,
    limit: limit.toString(),
    access_token: accessToken
  });
  
  const response = await fetch(url);
  
  if (!response.ok) {
    const error = await response.json();
    throw new InstagramApiError(
      `Failed to fetch media: ${error.error?.message || 'Unknown error'}`,
      response.status,
      error
    );
  }
  
  const data = await response.json();
  return data.data || [];
}

/**
 * Story item from Instagram API
 */
export interface StoryItem {
  id: string;
  timestamp?: string;
  media_type?: string;
  media_url?: string;
  permalink?: string;
}

/**
 * Fetch active stories from Instagram account
 * Uses the dedicated /stories endpoint which returns only currently active stories (<24h old)
 */
export async function fetchAccountStories(
  accountId: string,
  accessToken: string,
  options: {
    fields?: string;
  } = {}
): Promise<StoryItem[]> {
  const {
    fields = 'id,timestamp,media_type'
  } = options;
  
  const url = buildInstagramApiUrl(`${accountId}/stories`, {
    fields,
    access_token: accessToken
  });
  
  console.log(`Fetching stories from: ${accountId}/stories`);
  
  const response = await fetch(url);
  
  if (!response.ok) {
    const error = await response.json();
    // Don't throw if no stories found or permission issue
    if (error.error?.code === 100 || error.error?.code === 190) {
      console.log(`No stories accessible for account ${accountId}: ${error.error?.message}`);
      return [];
    }
    throw new InstagramApiError(
      `Failed to fetch stories: ${error.error?.message || 'Unknown error'}`,
      response.status,
      error
    );
  }
  
  const data = await response.json();
  console.log(`Found ${data.data?.length || 0} active stories`);
  return data.data || [];
}

/**
 * Check if story exists (is still accessible)
 */
export async function checkStoryExists(
  storyId: string,
  accessToken: string
): Promise<boolean> {
  try {
    const url = buildInstagramApiUrl(storyId, {
      fields: 'id',
      access_token: accessToken
    });
    
    const response = await fetch(url);
    return response.ok;
  } catch {
    return false;
  }
}

/**
 * Fetch Instagram account info
 */
export async function fetchAccountInfo(
  accountId: string,
  accessToken: string,
  fields = 'id,username,followers_count,media_count'
) {
  const url = buildInstagramApiUrl(accountId, {
    fields,
    access_token: accessToken
  });
  
  const response = await fetch(url);
  
  if (!response.ok) {
    const error = await response.json();
    throw new InstagramApiError(
      `Failed to fetch account info: ${error.error?.message || 'Unknown error'}`,
      response.status,
      error
    );
  }
  
  return await response.json();
}

/**
 * Fetch Instagram media insights (for posts/reels)
 */
export async function fetchMediaInsights(
  mediaId: string,
  accessToken: string,
  metrics = 'reach,impressions'
) {
  const url = buildInstagramApiUrl(`${mediaId}/insights`, {
    metric: metrics,
    access_token: accessToken
  });
  
  const response = await fetch(url);
  
  if (!response.ok) {
    const error = await response.json();
    // Don't throw for insights that aren't available yet
    if (error.error?.code === 10 || error.error?.message?.includes('Insights')) {
      return null;
    }
    throw new InstagramApiError(
      `Failed to fetch media insights: ${error.error?.message || 'Unknown error'}`,
      response.status,
      error
    );
  }
  
  return await response.json();
}

/**
 * Fetch mentioned media (tags)
 */
export async function fetchMentionedMedia(
  accountId: string,
  accessToken: string,
  limit = 50
) {
  const url = buildInstagramApiUrl(`${accountId}/tags`, {
    fields: 'id,media_type,media_product_type,timestamp,username',
    limit: limit.toString(),
    access_token: accessToken
  });
  
  const response = await fetch(url);
  
  if (!response.ok) {
    const error = await response.json();
    throw new InstagramApiError(
      `Failed to fetch mentioned media: ${error.error?.message || 'Unknown error'}`,
      response.status,
      error
    );
  }
  
  const data = await response.json();
  return data.data || [];
}

/**
 * Send Instagram direct message
 */
export async function sendInstagramMessage(
  recipientId: string,
  messageText: string,
  accessToken: string
) {
  const url = buildInstagramApiUrl('me/messages', {
    access_token: accessToken
  });
  
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      recipient: { id: recipientId },
      message: { text: messageText }
    })
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new InstagramApiError(
      `Failed to send message: ${error.error?.message || 'Unknown error'}`,
      response.status,
      error
    );
  }
  
  return await response.json();
}
</file>

<file path="supabase/functions/story-mentions-state-worker/index.ts">
import { corsHeaders, STORY_INSIGHTS_METRICS, INSTAGRAM_API_BASE, VERIFICATION_INTERVALS, STORY_EXPIRATION_MS } from '../shared/constants.ts';
import { MentionUpdateData, InsightsMap, SupabaseClient } from '../shared/types.ts';
import { corsPreflightResponse, jsonResponse, errorResponse } from '../shared/responses.ts';
import { createSupabaseClient } from '../shared/auth.ts';
import { handleError } from '../shared/error-handler.ts';
import { safeDecryptToken } from '../shared/crypto.ts';

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return corsPreflightResponse();
  }

  try {
    const supabase = createSupabaseClient();

    const body = await req.json().catch(() => ({}));
    const { source = 'manual', type = 'expiry' } = body;
    
    console.log(`Story mentions state worker started at: ${new Date().toISOString()}, source: ${source}, type: ${type}`);

    let processedCount = 0;
    let notificationCount = 0;
    let verificationCount = 0;

    if (type === 'verification') {
      // Handle story verification at different intervals (1h, 12h, 23h)
      const now = new Date();
      const currentMinutes = now.getMinutes();
      
      // Define verification intervals in minutes since mention creation
      const intervals = [60, 720, 1380]; // 1h, 12h, 23h
      
      for (const intervalMinutes of intervals) {
        const targetTime = new Date(now.getTime() - intervalMinutes * 60 * 1000);
        const windowStart = new Date(targetTime.getTime() - 30 * 60 * 1000); // 30 min before
        const windowEnd = new Date(targetTime.getTime() + 30 * 60 * 1000);   // 30 min after
        
        const { data: mentionsToVerify, error: verifyError } = await supabase
          .from('social_mentions')
          .select('id, organization_id, instagram_username, instagram_user_id, instagram_story_id, mentioned_at, expires_at, checks_count, story_url')
          .eq('mention_type', 'story_referral')
          .eq('state', 'new')
          .lt('checks_count', 3)
          .gte('mentioned_at', windowStart.toISOString())
          .lte('mentioned_at', windowEnd.toISOString());

        if (verifyError) {
          console.error(`Error fetching mentions for ${intervalMinutes}min verification:`, verifyError);
          continue;
        }

        console.log(`Found ${mentionsToVerify?.length || 0} mentions for ${intervalMinutes}min verification`);

        for (const mention of mentionsToVerify || []) {
          try {
            // Get organization tokens
            const { data: tokenInfo } = await supabase
              .from('organization_instagram_tokens')
              .select('access_token, token_expiry')
              .eq('organization_id', mention.organization_id)
              .single();

            let storyExists = false;
            
            if (tokenInfo?.access_token && (!tokenInfo.token_expiry || new Date(tokenInfo.token_expiry) > now)) {
              // Try to verify if story still exists
              if (mention.instagram_story_id) {
                try {
                  const decryptedToken = await safeDecryptToken(tokenInfo.access_token);
                  const response = await fetch(
                    `${INSTAGRAM_API_BASE}/${mention.instagram_story_id}?fields=id&access_token=${decryptedToken}`
                  );
                  storyExists = response.ok;
                } catch (error) {
                  console.error(`Error checking story ${mention.instagram_story_id}:`, error);
                }
              }
            }

            // Update checks count and last check time
            const newChecksCount = mention.checks_count + 1;
            const updateData: MentionUpdateData = {
              checks_count: newChecksCount,
              last_check_at: now.toISOString()
            };

            // Determine if story was deleted early (before 24h and not found)
            const mentionAge = now.getTime() - new Date(mention.mentioned_at).getTime();
            const is24Hours = mentionAge >= 24 * 60 * 60 * 1000;
            
            if (!storyExists && !is24Hours) {
              updateData.state = 'flagged_early_delete';
              updateData.processed = true;
              updateData.processed_at = now.toISOString();
            }

            const { error: updateError } = await supabase
              .from('social_mentions')
              .update(updateData)
              .eq('id', mention.id);

            if (updateError) {
              console.error(`Error updating mention ${mention.id}:`, updateError);
            } else {
              verificationCount++;
              
              if (updateData.state === 'flagged_early_delete') {
                // Create notification for early deletion
                await supabase
                  .from('notifications')
                  .insert({
                    organization_id: mention.organization_id,
                    type: 'story_early_delete',
                    message: `Historia de @${mention.instagram_username || 'usuario desconocido'} fue eliminada antes de 24h`,
                    target_type: 'story_mention',
                    target_id: mention.id,
                    priority: 'medium'
                  });
                notificationCount++;
              }
            }

          } catch (error) {
            console.error(`Error verifying mention ${mention.id}:`, error);
          }
        }
      }
    }

    // Find all story mentions that have expired (past 24h) and are still in 'new' state
    const { data: expiredMentions, error: expiredError } = await supabase
      .from('social_mentions')
      .select('id, organization_id, instagram_username, mentioned_at, expires_at')
      .eq('mention_type', 'story_referral')
      .eq('state', 'new')
      .lt('expires_at', new Date().toISOString());

    if (expiredError) {
      console.error('Error fetching expired mentions:', expiredError);
    } else {
      console.log(`Found ${expiredMentions?.length || 0} expired story mentions to process`);

      // Process each expired mention
      for (const mention of expiredMentions || []) {
        try {
          // Try to collect final insights snapshot before marking as completed
          let finalSnapshotCreated = false;
          
          // Get organization tokens for final insights collection
          const { data: tokenInfo } = await supabase
            .from('organization_instagram_tokens')
            .select('access_token, token_expiry')
            .eq('organization_id', mention.organization_id)
            .single();

          if (tokenInfo?.access_token && mention.instagram_story_id) {
            try {
              const decryptedToken = await safeDecryptToken(tokenInfo.access_token);
              
              // Try to fetch final insights (story might still be available for a short time after 24h)
              const insightsUrl = `${INSTAGRAM_API_BASE}/${mention.instagram_story_id}/insights?metric=${STORY_INSIGHTS_METRICS}&access_token=${decryptedToken}`;
              const insightsResponse = await fetch(insightsUrl);
              
              if (insightsResponse.ok) {
                const insightsData = await insightsResponse.json();
                
                // Parse insights
                const insights: InsightsMap = {};
                for (const metric of insightsData.data || []) {
                  insights[metric.name] = metric.values?.[0]?.value || 0;
                }
                
                // Create final snapshot
                const finalSnapshot = {
                  social_mention_id: mention.id,
                  organization_id: mention.organization_id,
                  instagram_story_id: mention.instagram_story_id,
                  instagram_media_id: mention.instagram_story_id,
                  snapshot_at: new Date().toISOString(),
                  story_age_hours: 24, // Final snapshot at 24h
                  impressions: insights.impressions || 0,
                  reach: insights.reach || 0,
                  replies: insights.replies || 0,
                  exits: insights.exits || 0,
                  taps_forward: insights.taps_forward || 0,
                  taps_back: insights.taps_back || 0,
                  shares: insights.shares || 0,
                  navigation: {},
                  raw_insights: insightsData
                };
                
                const { error: snapshotError } = await supabase
                  .from('story_insights_snapshots')
                  .insert(finalSnapshot);
                
                if (!snapshotError) {
                  finalSnapshotCreated = true;
                  console.log(`Created final insights snapshot for story ${mention.instagram_story_id}`);
                } else {
                  console.error(`Error creating final snapshot:`, snapshotError);
                }
              }
            } catch (error) {
              console.error(`Error fetching final insights for story ${mention.instagram_story_id}:`, error);
            }
          }

          // Update state to 'completed' (natural 24h expiration)
          const { error: updateError } = await supabase
            .from('social_mentions')
            .update({ 
              state: 'completed',
              processed: true,
              processed_at: new Date().toISOString()
            })
            .eq('id', mention.id);

          if (updateError) {
            console.error(`Error updating mention ${mention.id}:`, updateError);
            continue;
          }

          processedCount++;

          // Create notification for completed story mention (low priority)
          const notificationMessage = finalSnapshotCreated
            ? `Historia de @${mention.instagram_username || 'usuario desconocido'} complet√≥ su ciclo de 24h (insights finales guardados)`
            : `Historia de @${mention.instagram_username || 'usuario desconocido'} complet√≥ su ciclo de 24h naturalmente`;
            
          const { error: notificationError } = await supabase
            .from('notifications')
            .insert({
              organization_id: mention.organization_id,
              type: 'story_mention_completed',
              message: notificationMessage,
              target_type: 'story_mention',
              target_id: mention.id,
              priority: 'low'
            });

          if (!notificationError) {
            notificationCount++;
          }

        } catch (error) {
          console.error(`Error processing expired mention ${mention.id}:`, error);
        }
      }
    }

    console.log(`Story mentions worker completed. Verified: ${verificationCount}, Expired processed: ${processedCount}, Notifications sent: ${notificationCount}`);

    return jsonResponse({ 
      success: true,
      verified: verificationCount,
      processed: processedCount,
      notifications_sent: notificationCount,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    return handleError(error);
  }
});
</file>

<file path="src/components/Ambassadors/AmbassadorMetricsCards.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { MetricCard } from "@/components/Dashboard/MetricCard";
import { Users, Trophy, Target, TrendingUp, Eye, Heart, Image, AlertTriangle } from "lucide-react";

interface AmbassadorMetricsCardsProps {
  metrics: {
    name: string;
    instagram_user: string;
    status: string;
    global_points: number;
    global_category: string;
    performance_status: string;
    events_participated: number;
    completed_tasks: number;
    failed_tasks: number;
    follower_count: number;
    total_reach: number;
    avg_engagement: number;
    completion_rate: number;
    last_activity: string | null;
    story_insights?: {
      total_stories: number;
      total_reach: number;
      total_impressions: number;
      total_engagement: number;
      avg_reach_per_story: number;
      avg_impressions_per_story: number;
      total_replies: number;
      total_shares: number;
    };
    insights_error?: boolean;
  };
}

export function AmbassadorMetricsCards({ metrics }: AmbassadorMetricsCardsProps) {
  const getCategoryColor = (category: string) => {
    const colors = {
      'bronze': 'bg-amber-100 text-amber-800',
      'silver': 'bg-gray-100 text-gray-800',
      'gold': 'bg-yellow-100 text-yellow-800',
      'diamond': 'bg-purple-100 text-purple-800'
    };
    return colors[category as keyof typeof colors] || colors.bronze;
  };

  const getPerformanceColor = (status: string) => {
    const colors = {
      'cumple': 'bg-green-100 text-green-800',
      'advertencia': 'bg-yellow-100 text-yellow-800',
      'no_cumple': 'bg-red-100 text-red-800',
      'exclusivo': 'bg-purple-100 text-purple-800'
    };
    return colors[status as keyof typeof colors] || colors.cumple;
  };

  return (
    <div className="space-y-6">
      {/* Ambassador Header Card */}
      <Card>
        <CardContent className="p-6">
          <div className="flex items-center space-x-4">
            <Avatar className="w-16 h-16">
              <AvatarFallback className="text-lg">
                {metrics.name.split(' ').map(n => n[0]).join('')}
              </AvatarFallback>
            </Avatar>
            <div className="flex-1">
              <h2 className="text-2xl font-bold">{metrics.name}</h2>
              <p className="text-muted-foreground">@{metrics.instagram_user}</p>
              <div className="flex gap-2 mt-2">
                <Badge variant={metrics.status === 'active' ? 'default' : 'secondary'}>
                  {metrics.status === 'active' ? 'Activo' : 'Inactivo'}
                </Badge>
                <Badge className={getCategoryColor(metrics.global_category)}>
                  {metrics.global_category.charAt(0).toUpperCase() + metrics.global_category.slice(1)}
                </Badge>
                <Badge className={getPerformanceColor(metrics.performance_status)}>
                  {metrics.performance_status === 'cumple' ? 'Cumple' :
                   metrics.performance_status === 'advertencia' ? 'Advertencia' :
                   metrics.performance_status === 'no_cumple' ? 'No Cumple' : 'Exclusivo'}
                </Badge>
              </div>
            </div>
            <div className="text-right">
              <div className="text-3xl font-bold text-primary">
                {metrics.global_points}
              </div>
              <p className="text-sm text-muted-foreground">Puntos Globales</p>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Metrics Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <MetricCard
          title="Eventos Participados"
          value={metrics.events_participated}
          icon={<Users className="w-4 h-4" />}
          description="Total de eventos"
        />
        
        <MetricCard
          title="Tareas Completadas"
          value={metrics.completed_tasks}
          icon={<Trophy className="w-4 h-4" />}
          description={`${metrics.failed_tasks} fallidas`}
        />
        
        <MetricCard
          title="Tasa de Cumplimiento"
          value={`${metrics.completion_rate}%`}
          icon={<Target className="w-4 h-4" />}
          trend={{
            value: metrics.completion_rate > 80 ? 5 : -2,
            isPositive: metrics.completion_rate > 80
          }}
        />
        
        <MetricCard
          title="Alcance Total"
          value={metrics.total_reach.toLocaleString()}
          icon={<Eye className="w-4 h-4" />}
          description="Visualizaciones totales"
        />
        
        <MetricCard
          title="Engagement Promedio"
          value={`${metrics.avg_engagement}%`}
          icon={<Heart className="w-4 h-4" />}
          description="Interacci√≥n media"
        />
        
        <MetricCard
          title="Seguidores"
          value={metrics.follower_count.toLocaleString()}
          icon={<TrendingUp className="w-4 h-4" />}
          description="Instagram followers"
        />
      </div>

      {/* Story Insights Section - Powered by instagram_manage_insights API */}
      {metrics.insights_error && (
        <div className="mt-6">
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              No se pudieron cargar los insights de Stories. Los datos b√°sicos del embajador est√°n disponibles.
            </AlertDescription>
          </Alert>
        </div>
      )}
      
      {metrics.story_insights && metrics.story_insights.total_stories > 0 && !metrics.insights_error && (
        <div className="mt-6">
          <Card className="border-pink-200 bg-gradient-to-br from-pink-50/50 to-purple-50/50">
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="flex items-center gap-2">
                  <Image className="w-5 h-5 text-pink-600" />
                  Insights de Stories
                </CardTitle>
                <Badge variant="outline" className="text-xs bg-pink-100 text-pink-700 border-pink-300">
                  üìä Instagram Insights API
                </Badge>
              </div>
              <p className="text-sm text-muted-foreground">
                M√©tricas de rendimiento obtenidas de la API de Instagram
              </p>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <MetricCard
                  title="Stories Totales"
                  value={metrics.story_insights.total_stories}
                  icon={<Image className="w-4 h-4" />}
                  description="Historias con insights"
                />
                
                <MetricCard
                  title="Alcance Stories"
                  value={metrics.story_insights.total_reach.toLocaleString()}
                  icon={<Eye className="w-4 h-4" />}
                  description={`Promedio: ${metrics.story_insights.avg_reach_per_story.toLocaleString()}`}
                />
                
                <MetricCard
                  title="Impresiones"
                  value={metrics.story_insights.total_impressions.toLocaleString()}
                  icon={<TrendingUp className="w-4 h-4" />}
                  description={`Promedio: ${metrics.story_insights.avg_impressions_per_story.toLocaleString()}`}
                />
                
                <MetricCard
                  title="Engagement"
                  value={metrics.story_insights.total_engagement.toLocaleString()}
                  icon={<Heart className="w-4 h-4" />}
                  description={`${metrics.story_insights.total_replies} respuestas, ${metrics.story_insights.total_shares} shares`}
                />
              </div>
            </CardContent>
          </Card>
        </div>
      )}
      
      {/* Show placeholder when no insights but connection exists */}
      {!metrics.story_insights && !metrics.insights_error && (
        <div className="mt-6">
          <Card className="border-dashed border-2 border-muted">
            <CardContent className="pt-6">
              <div className="text-center text-muted-foreground">
                <Image className="w-12 h-12 mx-auto mb-4 opacity-50" />
                <p className="font-medium mb-2">Insights de Stories</p>
                <p className="text-sm">
                  Los insights aparecer√°n aqu√≠ cuando el embajador publique Stories mencionando la marca
                </p>
                <Badge variant="outline" className="mt-3 text-xs">
                  Requiere: instagram_manage_insights
                </Badge>
              </div>
            </CardContent>
          </Card>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/Ambassadors/EditAmbassadorModal.tsx">
import { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { toast } from "sonner";
import { supabase } from "@/integrations/supabase/client";
import { InstagramConnect } from "@/components/Instagram/InstagramConnect";
import { useAmbassadorInstagramStatus } from "@/hooks/useAmbassadorInstagramStatus";

interface Ambassador {
  id: string;
  first_name: string;
  last_name: string;
  email?: string; // Optional - only available with manage_ambassadors permission
  instagram_user: string;
  organization_id: string;
  status: string;
  performance_status: string;
  date_of_birth?: string;
  rut?: string;
}

interface EditAmbassadorModalProps {
  isOpen: boolean;
  onClose: () => void;
  ambassador: Ambassador | null;
  onAmbassadorUpdated: () => void;
}

export function EditAmbassadorModal({ 
  isOpen, 
  onClose, 
  ambassador, 
  onAmbassadorUpdated 
}: EditAmbassadorModalProps) {
  const instagramStatus = useAmbassadorInstagramStatus(ambassador?.id ?? null);
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState({
    first_name: "",
    last_name: "",
    email: "",
    instagram_user: "",
    status: "active",
    performance_status: "cumple",
    date_of_birth: "",
    rut: ""
  });

  useEffect(() => {
    if (ambassador) {
      setFormData({
        first_name: ambassador.first_name || "",
        last_name: ambassador.last_name || "",
        email: ambassador.email || "",
        instagram_user: ambassador.instagram_user || "",
        status: ambassador.status || "active",
        performance_status: ambassador.performance_status || "cumple",
        date_of_birth: ambassador.date_of_birth || "",
        rut: ambassador.rut || ""
      });
    }
  }, [ambassador]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!ambassador) return;

    try {
      setLoading(true);

      // Validate required fields
      if (!formData.first_name || !formData.last_name || !formData.email || !formData.instagram_user) {
        toast.error("Por favor completa todos los campos requeridos");
        return;
      }

      // Validate email format
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(formData.email)) {
        toast.error("Por favor ingresa un email v√°lido");
        return;
      }

      // Clean Instagram username
      const cleanInstagram = formData.instagram_user.replace(/^@/, '');

      const { error } = await supabase
        .from('embassadors')
        .update({
          first_name: formData.first_name,
          last_name: formData.last_name,
          email: formData.email,
          instagram_user: cleanInstagram,
          status: formData.status,
          performance_status: formData.performance_status,
          date_of_birth: formData.date_of_birth || null,
          rut: formData.rut || null
        })
        .eq('id', ambassador.id);

      if (error) throw error;

      toast.success("Embajador actualizado exitosamente");
      onAmbassadorUpdated();
      onClose();
    } catch (error) {
      console.error('Error updating ambassador:', error);
      toast.error("Error al actualizar embajador");
    } finally {
      setLoading(false);
    }
  };

  const handleInstagramChange = (value: string) => {
    const cleanValue = value.startsWith('@') ? value.slice(1) : value;
    setFormData(prev => ({ ...prev, instagram_user: cleanValue }));
  };

  if (!ambassador) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Editar Embajador</DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-6">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="first_name">Nombre *</Label>
              <Input
                id="first_name"
                value={formData.first_name}
                onChange={(e) => setFormData(prev => ({ ...prev, first_name: e.target.value }))}
                placeholder="Nombre"
                required
              />
            </div>
            <div>
              <Label htmlFor="last_name">Apellido *</Label>
              <Input
                id="last_name"
                value={formData.last_name}
                onChange={(e) => setFormData(prev => ({ ...prev, last_name: e.target.value }))}
                placeholder="Apellido"
                required
              />
            </div>
          </div>

          <div>
            <Label htmlFor="email">Email *</Label>
            <Input
              id="email"
              type="email"
              value={formData.email}
              onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
              placeholder="correo@ejemplo.com"
              required
            />
          </div>

          <div>
            <Label htmlFor="instagram_user">Usuario de Instagram *</Label>
            <Input
              id="instagram_user"
              value={formData.instagram_user}
              onChange={(e) => handleInstagramChange(e.target.value)}
              placeholder="nombreusuario"
              required
            />
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="rut">RUT</Label>
              <Input
                id="rut"
                value={formData.rut}
                onChange={(e) => setFormData(prev => ({ ...prev, rut: e.target.value }))}
                placeholder="12.345.678-9"
              />
            </div>
            <div>
              <Label htmlFor="date_of_birth">Fecha de Nacimiento</Label>
              <Input
                id="date_of_birth"
                type="date"
                value={formData.date_of_birth}
                onChange={(e) => setFormData(prev => ({ ...prev, date_of_birth: e.target.value }))}
              />
            </div>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="status">Estado</Label>
              <Select value={formData.status} onValueChange={(value) => setFormData(prev => ({ ...prev, status: value }))}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="active">Activo</SelectItem>
                  <SelectItem value="inactive">Inactivo</SelectItem>
                  <SelectItem value="pending">Pendiente</SelectItem>
                </SelectContent>
              </Select>
            </div>
            <div>
              <Label htmlFor="performance_status">Estado de Performance</Label>
              <Select value={formData.performance_status} onValueChange={(value) => setFormData(prev => ({ ...prev, performance_status: value }))}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="cumple">Cumple</SelectItem>
                  <SelectItem value="advertencia">Advertencia</SelectItem>
                  <SelectItem value="no_cumple">No Cumple</SelectItem>
                  <SelectItem value="exclusivo">Exclusivo</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Instagram Connection */}
          <div className="space-y-3">
            <Label>Conexi√≥n de Instagram</Label>
            <InstagramConnect
              type="ambassador"
              entityId={ambassador.id}
              organizationId={ambassador.organization_id}
              currentStatus={instagramStatus}
              onConnectionChange={onAmbassadorUpdated}
            />
          </div>

          <div className="flex justify-end space-x-3 pt-4">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancelar
            </Button>
            <Button type="submit" disabled={loading}>
              {loading ? "Actualizando..." : "Actualizar Embajador"}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/Analytics/AdvancedDashboard.tsx">
import { useState, useEffect, useCallback } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { MetricCard } from "../Dashboard/MetricCard";
import { PageHeader } from "@/components/Layout/PageHeader";
import { GlassPanel } from "@/components/Layout/GlassPanel";
import {
  TrendingUp,
  Users,
  Calendar,
  Instagram,
  Eye,
  Heart,
  MessageCircle,
  Trophy,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Download,
  Filter,
  RefreshCw
} from "lucide-react";
import { LineChart, Line, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, PieChart, Pie, Cell } from "recharts";
import { supabase } from "@/integrations/supabase/client";
import { useAdvancedAnalytics } from "@/hooks/useAdvancedAnalytics";
import { useFiestas } from "@/hooks/useFiestas";
import { FiestaSelector } from "@/components/Dashboard/FiestaSelector";
import { useInstagramSync } from "@/hooks/useInstagramSync";
import { toast } from "sonner";

export function AdvancedDashboard() {
  const { selectedFiesta, selectedFiestaId } = useFiestas();
  const [selectedPeriod, setSelectedPeriod] = useState("30d");
  const [selectedEvent, setSelectedEvent] = useState("all");
  const [events, setEvents] = useState<Array<{ id: string; name: string }>>([]);
  
  // Always call hooks at the top level, even when selectedFiestaId is null
  const { analyticsData, loading, error, refreshAnalytics } = useAdvancedAnalytics(selectedFiestaId, selectedEvent, selectedPeriod);
  const { isSyncing, syncInstagramData } = useInstagramSync();

  const fetchEvents = useCallback(async () => {
    if (!selectedFiestaId) return;
    
    try {
      const { data, error } = await supabase
        .from('events')
        .select('id')
        .eq('fiesta_id', selectedFiestaId)
        .order('created_at', { ascending: true });

      if (error) throw error;
      setEvents(data?.map(e => ({ id: e.id, name: `Evento ${e.id.slice(0, 8)}` })) || []);
    } catch (err) {
      console.error('Error fetching events:', err);
    }
  }, [selectedFiestaId]);

  // This useEffect must be called before any early returns to maintain hook order
  useEffect(() => {
    if (selectedFiestaId) {
      fetchEvents();
    }
  }, [selectedFiestaId, fetchEvents]);

  // Show message if no fiesta is selected (after all hooks are called)
  if (!selectedFiestaId) {
    return (
      <div className="space-y-6">
        <PageHeader 
          title="Anal√≠ticas" 
          description="An√°lisis avanzado de rendimiento y m√©tricas"
        />
        <GlassPanel>
          <div className="text-center text-muted-foreground py-12">
            <AlertTriangle className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>Selecciona una fiesta para ver las anal√≠ticas</p>
          </div>
        </GlassPanel>
      </div>
    );
  }

  const exportAnalytics = async () => {
    try {
      toast.success("Funcionalidad de exportaci√≥n en desarrollo");
    } catch (error) {
      toast.error("Error al exportar datos");
    }
  };

  const handleManualSync = async () => {
    const success = await syncInstagramData();
    if (success) {
      refreshAnalytics();
    }
  };

  const getCategoryBadge = (category: string) => {
    const colors = {
      bronze: "bg-amber-100 text-amber-800",
      silver: "bg-gray-100 text-gray-800",
      gold: "bg-yellow-100 text-yellow-800",
      diamond: "bg-blue-100 text-blue-800"
    };
    return colors[category as keyof typeof colors] || colors.bronze;
  };

  if (loading) {
    return (
      <div className="space-y-6">
        <PageHeader 
          title="Anal√≠ticas" 
          description="An√°lisis avanzado de rendimiento y m√©tricas"
        />
        <div className="animate-pulse space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
            {[...Array(4)].map((_, i) => (
              <GlassPanel key={i} className="h-32">
                <div className="animate-pulse bg-muted rounded"></div>
              </GlassPanel>
            ))}
          </div>
          <GlassPanel className="h-96">
            <div className="animate-pulse bg-muted rounded h-full"></div>
          </GlassPanel>
        </div>
      </div>
    );
  }

  if (error || !analyticsData) {
    return (
      <div className="space-y-6">
        <PageHeader 
          title="Anal√≠ticas" 
          description="An√°lisis avanzado de rendimiento y m√©tricas"
        />
        <GlassPanel>
          <div className="text-center text-muted-foreground py-12">
            <AlertTriangle className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>{error || "Error al cargar datos anal√≠ticos"}</p>
            <Button onClick={refreshAnalytics} className="mt-4">
              Reintentar
            </Button>
          </div>
        </GlassPanel>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader 
        title="Dashboard Anal√≠tico" 
        description={`An√°lisis avanzado de ${selectedFiesta?.name}`}
      >
        <div className="w-full flex justify-center">
          <div className="flex items-center space-x-3 flex-wrap gap-2">
            <FiestaSelector 
              onFiestaChange={(fiestaId) => {/* Handle change if needed */}}
              selectedFiestaId={selectedFiestaId}
            />
            <Select value={selectedEvent} onValueChange={setSelectedEvent}>
              <SelectTrigger className="w-48">
                <SelectValue placeholder="Seleccionar evento" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Todos los eventos</SelectItem>
                {events.map((event) => (
                  <SelectItem key={event.id} value={event.id}>
                    {event.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            
            <Select value={selectedPeriod} onValueChange={setSelectedPeriod}>
              <SelectTrigger className="w-36">
                <SelectValue placeholder="Per√≠odo" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="7d">7 d√≠as</SelectItem>
                <SelectItem value="30d">30 d√≠as</SelectItem>
                <SelectItem value="90d">3 meses</SelectItem>
                <SelectItem value="1y">1 a√±o</SelectItem>
              </SelectContent>
            </Select>

            <Button 
              variant="outline" 
              size="sm" 
              onClick={handleManualSync}
              disabled={isSyncing}
            >
              <RefreshCw className={`w-4 h-4 mr-2 ${isSyncing ? 'animate-spin' : ''}`} />
              {isSyncing ? 'Sincronizando...' : 'Sincronizar'}
            </Button>

            <Button variant="outline" size="sm" onClick={exportAnalytics}>
              <Download className="w-4 h-4 mr-2" />
              Exportar
            </Button>
          </div>
        </div>
      </PageHeader>

      <div className="max-w-6xl mx-auto space-y-6">
        {/* Key Metrics - Instagram Insights Powered */}
        <div className="space-y-3">
          <div className="flex items-center gap-2">
            <Badge variant="outline" className="bg-pink-50 text-pink-700 border-pink-200">
              <Instagram className="w-3 h-3 mr-1" />
              M√©tricas de Instagram Insights API
            </Badge>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
            <MetricCard
              title="Alcance Total"
              value={analyticsData.summary.total_reach >= 1000000 
                ? `${(analyticsData.summary.total_reach / 1000000).toFixed(1)}M`
                : analyticsData.summary.total_reach.toLocaleString()}
              description="üìä Via instagram_manage_insights"
              icon={<Eye className="w-4 h-4" />}
            />
            <MetricCard
              title="Total Menciones"
              value={analyticsData.summary.total_mentions.toLocaleString()}
              description="Historias y menciones"
              icon={<MessageCircle className="w-4 h-4" />}
            />
            <MetricCard
              title="Tasa de Completitud"
              value={`${analyticsData.summary.completion_rate}%`}
              description="Tareas completadas"
              icon={<CheckCircle className="w-4 h-4" />}
            />
            <MetricCard
              title="Embajadores Activos"
              value={analyticsData.summary.active_ambassadors}
              description="Con actividad reciente"
              icon={<Users className="w-4 h-4" />}
            />
          </div>
        </div>

        <Tabs defaultValue="overview" className="space-y-6">
          <TabsList className="grid w-full grid-cols-4">
            <TabsTrigger value="overview">Resumen</TabsTrigger>
            <TabsTrigger value="performance">Rendimiento</TabsTrigger>
            <TabsTrigger value="events">Eventos</TabsTrigger>
            <TabsTrigger value="top25">Top 25</TabsTrigger>
          </TabsList>

          <TabsContent value="overview" className="space-y-6">
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              {/* Top Ambassadors */}
              <Card className="shadow-card">
                <CardHeader>
                  <CardTitle className="flex items-center">
                    <Trophy className="w-5 h-5 mr-2 text-primary" />
                    Top 10 Embajadores
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    {analyticsData.top_ambassadors.slice(0, 10).map((ambassador, index) => (
                      <div key={ambassador.id} className="flex items-center justify-between p-3 rounded-lg bg-gradient-card border border-primary/10">
                        <div className="flex items-center space-x-3">
                          <div className="w-8 h-8 rounded-full bg-gradient-primary flex items-center justify-center text-primary-foreground font-bold text-sm">
                            {index + 1}
                          </div>
                          <div>
                            <h4 className="font-medium">{ambassador.name}</h4>
                            <div className="flex items-center space-x-2">
                              <Badge variant="outline" className="text-xs">
                                {ambassador.category}
                              </Badge>
                              <span className="text-xs text-muted-foreground">
                                {ambassador.instagram_user}
                              </span>
                            </div>
                          </div>
                        </div>
                        <div className="text-right">
                          <div className="font-bold text-primary">{ambassador.total_points}</div>
                          <div className="text-xs text-muted-foreground">puntos</div>
                        </div>
                      </div>
                    ))}
                  </div>
                </CardContent>
              </Card>

              {/* Performance Distribution */}
              <Card className="shadow-card">
                <CardHeader>
                  <CardTitle>Distribuci√≥n de Rendimiento</CardTitle>
                </CardHeader>
                <CardContent>
                  {/* Filter out categories with 0% */}
                  {(() => {
                    const filteredData = analyticsData.performance_distribution.filter(
                      (item) => item.count > 0 && item.percentage > 0
                    );
                    
                    if (filteredData.length === 0) {
                      return (
                        <div className="h-64 flex items-center justify-center text-muted-foreground">
                          <div className="text-center">
                            <Users className="h-12 w-12 mx-auto mb-2 opacity-50" />
                            <p>No hay datos de rendimiento disponibles</p>
                          </div>
                        </div>
                      );
                    }

                    return (
                      <div className="space-y-4">
                        <div className="h-64">
                          <ResponsiveContainer width="100%" height="100%">
                            <PieChart>
                              <Pie
                                data={filteredData}
                                cx="50%"
                                cy="50%"
                                innerRadius={60}
                                outerRadius={100}
                                paddingAngle={filteredData.length > 1 ? 2 : 0}
                                dataKey="count"
                              >
                                {filteredData.map((entry, index) => (
                                  <Cell key={`cell-${index}`} fill={entry.color} />
                                ))}
                              </Pie>
                              <Tooltip 
                                formatter={(value: number, name: string, props: { payload: { percentage: number; category: string } }) => [
                                  `${value} embajadores (${props.payload.percentage}%)`,
                                  props.payload.category
                                ]}
                              />
                            </PieChart>
                          </ResponsiveContainer>
                        </div>
                        
                        {/* Legend Menu */}
                        <div className="flex flex-wrap justify-center gap-4 pt-4 border-t">
                          {analyticsData.performance_distribution.map((item) => (
                            <div
                              key={item.category}
                              className={`flex items-center gap-2 px-3 py-2 rounded-lg transition-colors ${
                                item.count > 0
                                  ? 'bg-muted/50 hover:bg-muted cursor-pointer'
                                  : 'opacity-40'
                              }`}
                            >
                              <div
                                className="w-4 h-4 rounded-full flex-shrink-0"
                                style={{ backgroundColor: item.color }}
                              />
                              <div className="flex flex-col">
                                <span className="text-sm font-medium">{item.category}</span>
                                <span className="text-xs text-muted-foreground">
                                  {item.count} ({item.percentage}%)
                                </span>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    );
                  })()}
                </CardContent>
              </Card>
            </div>
          </TabsContent>

          <TabsContent value="performance" className="space-y-6">
            <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
              {analyticsData.performance_distribution.map((perf) => (
                <Card key={perf.category} className="shadow-card">
                  <CardContent className="p-6">
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="text-2xl font-bold" style={{ color: perf.color }}>
                          {perf.count}
                        </div>
                        <div className="text-sm text-muted-foreground">{perf.category}</div>
                        <div className="text-xs text-muted-foreground">{perf.percentage}%</div>
                      </div>
                      {perf.category === "Cumple" && <CheckCircle className="w-8 h-8" style={{ color: perf.color }} />}
                      {perf.category === "Advertencia" && <AlertTriangle className="w-8 h-8" style={{ color: perf.color }} />}
                      {perf.category === "No Cumple" && <XCircle className="w-8 h-8" style={{ color: perf.color }} />}
                      {perf.category === "Exclusivo" && <Trophy className="w-8 h-8" style={{ color: perf.color }} />}
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          </TabsContent>

          <TabsContent value="events" className="space-y-6">
            <Card className="shadow-card">
              <CardHeader>
                <CardTitle>Comparativa de Eventos</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="h-80">
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart data={analyticsData.event_comparison}>
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="name" />
                      <YAxis />
                      <Tooltip />
                      <Bar dataKey="completed" stackId="a" fill="#22c55e" name="Completadas" />
                      <Bar dataKey="pending" stackId="a" fill="#f59e0b" name="Pendientes" />
                      <Bar dataKey="failed" stackId="a" fill="#ef4444" name="Fallidas" />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="top25">
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <div>
                    <CardTitle>Top 25 Embajadores</CardTitle>
                    <p className="text-sm text-muted-foreground">
                      Ranking de los mejores embajadores por puntos totales
                    </p>
                  </div>
                  <Button onClick={exportAnalytics} variant="outline">
                    <Download className="h-4 w-4 mr-2" />
                    Exportar Ranking
                  </Button>
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-3">
                  {analyticsData.top_ambassadors.map((ambassador, index) => (
                    <div key={ambassador.id} className="flex items-center justify-between p-4 rounded-lg border bg-card hover:bg-accent/50 transition-colors">
                      <div className="flex items-center space-x-4">
                        <div className="flex items-center justify-center w-10 h-10 rounded-full bg-primary text-primary-foreground font-bold">
                          {index + 1}
                        </div>
                        <div>
                          <h4 className="font-medium">{ambassador.name}</h4>
                          <p className="text-sm text-muted-foreground">{ambassador.instagram_user}</p>
                        </div>
                      </div>
                      <div className="flex items-center space-x-6 text-sm">
                        <div className="text-center">
                          <div className="font-bold">{ambassador.total_points}</div>
                          <div className="text-muted-foreground">Puntos</div>
                        </div>
                        <div className="text-center">
                          <div className="font-bold">{ambassador.events_participated}</div>
                          <div className="text-muted-foreground">Eventos</div>
                        </div>
                        <div className="text-center">
                          <Badge className={getCategoryBadge(ambassador.category)}>
                            {ambassador.category.charAt(0).toUpperCase() + ambassador.category.slice(1)}
                          </Badge>
                        </div>
                        <div className="text-center">
                          <div className="font-bold">{ambassador.completion_rate}%</div>
                          <div className="text-muted-foreground">Completitud</div>
                        </div>
                        <div className="text-center">
                          <div className="font-bold">{ambassador.total_reach.toLocaleString()}</div>
                          <div className="text-muted-foreground">Alcance</div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>

        {/* Trends Section */}
        <Card className="shadow-card">
          <CardHeader>
            <CardTitle>Evoluci√≥n de M√©tricas (√öltimos 30 d√≠as)</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="h-80">
              <ResponsiveContainer width="100%" height="100%">
                <LineChart data={analyticsData.trends}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis 
                    dataKey="date" 
                    tickFormatter={(date) => new Date(date).getDate().toString()} 
                  />
                  <YAxis yAxisId="left" />
                  <YAxis yAxisId="right" orientation="right" />
                  <Tooltip 
                    labelFormatter={(date) => new Date(date).toLocaleDateString()}
                  />
                  <Line 
                    yAxisId="left" 
                    type="monotone" 
                    dataKey="reach" 
                    stroke="#8b5cf6" 
                    strokeWidth={3}
                    name="Alcance"
                  />
                  <Line 
                    yAxisId="right" 
                    type="monotone" 
                    dataKey="mentions" 
                    stroke="#f59e0b" 
                    strokeWidth={3}
                    name="Menciones"
                  />
                </LineChart>
              </ResponsiveContainer>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="src/components/Settings/SettingsContent.tsx">
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { 
  Settings, 
  Instagram, 
  Bell, 
  Shield, 
  Palette, 
  Zap,
  Save,
  RefreshCw,
  AlertTriangle,
  CheckCircle,
  Building2,
  Users,
  Calendar,
  Upload
} from "lucide-react";
import { toast } from "sonner";
import { EnhancedInstagramSettings } from "@/components/Settings/EnhancedInstagramSettings";
import { N8nConfigurationSection } from "@/components/Settings/N8nConfigurationSection";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";

import { useUserProfile } from "@/hooks/useUserProfile";
import { useOrganizationSettings } from "@/hooks/useOrganizationSettings";


export default function SettingsContent() {
  const { organization, refreshOrganization, updateOrganization } = useCurrentOrganization();
  
  const { profile } = useUserProfile();
  const { 
    settings, 
    loading: settingsLoading, 
    saving, 
    updateGeneralSettings,
    updateInstagramSettings,
    updateNotificationSettings,
    updatePermissionSettings,
    updateAppearanceSettings,
    updateIntegrationSettings
  } = useOrganizationSettings();
  

  const [orgName, setOrgName] = useState<string>(organization?.name || "");
  const [orgDescription, setOrgDescription] = useState<string>(organization?.description || "");
  const [orgLogoUrl, setOrgLogoUrl] = useState<string>(organization?.logo_url || "");

  useEffect(() => {
    setOrgName(organization?.name || "");
    setOrgDescription(organization?.description || "");
    setOrgLogoUrl(organization?.logo_url || "");
  }, [organization?.name, organization?.description, organization?.logo_url]);

  const handleSaveOrganization = async () => {
    const success = await updateOrganization({
      name: orgName,
      description: orgDescription,
      logo_url: orgLogoUrl,
    });
    if (success) {
      refreshOrganization?.();
    }
  };
  // Refresh organization after returning from OAuth and on mount
  useEffect(() => {
    let isMounted = true;
    let hasRefreshed = false; // Flag to ensure we only refresh once

    const refresh = () => {
      if (isMounted && refreshOrganization && !hasRefreshed) {
        hasRefreshed = true;
        console.log('SettingsContent: Refreshing organization...');
        refreshOrganization();
      }
    };

    const params = new URLSearchParams(window.location.search);
    const hasOAuthParams = params.has('status') || params.has('ig') || params.has('instagram');
    
    if (hasOAuthParams) {
      // Clean up URL params immediately to prevent re-processing
      const url = new URL(window.location.href);
      url.searchParams.delete('status');
      url.searchParams.delete('ig');
      url.searchParams.delete('instagram');
      window.history.replaceState({}, '', url.toString());
      
      // Refresh after OAuth callback
      refresh();
    }
    // Note: Removed the else branch that was refreshing on every mount
    // The useInstagramConnection hook now handles organization-based refreshes

    return () => {
      isMounted = false;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Only run once on mount


  if (settingsLoading) {
    return (
      <div className="flex items-center justify-center py-8">
        <div className="text-lg">Cargando configuraciones...</div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold text-gradient">Configuraciones</h1>
      </div>

      <Tabs defaultValue="general" className="space-y-6">
        <TabsList className="grid grid-cols-6 w-full overflow-x-auto">
          <TabsTrigger value="general" className="flex items-center gap-2 shrink-0">
            <Building2 className="w-4 h-4" />
            <span className="hidden sm:inline">General</span>
          </TabsTrigger>
          <TabsTrigger value="instagram" className="flex items-center gap-2 shrink-0">
            <Instagram className="w-4 h-4" />
            <span className="hidden sm:inline">Instagram</span>
          </TabsTrigger>
          <TabsTrigger value="notifications" className="flex items-center gap-2 shrink-0">
            <Bell className="w-4 h-4" />
            <span className="hidden sm:inline">Notificaciones</span>
          </TabsTrigger>
          <TabsTrigger value="permissions" className="flex items-center gap-2 shrink-0">
            <Shield className="w-4 h-4" />
            <span className="hidden sm:inline">Permisos</span>
          </TabsTrigger>
          <TabsTrigger value="appearance" className="flex items-center gap-2 shrink-0">
            <Palette className="w-4 h-4" />
            <span className="hidden sm:inline">Apariencia</span>
          </TabsTrigger>
          <TabsTrigger value="integrations" className="flex items-center gap-2 shrink-0">
            <Zap className="w-4 h-4" />
            <span className="hidden sm:inline">Integraciones</span>
          </TabsTrigger>
        </TabsList>

        <TabsContent value="general">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Building2 className="w-5 h-5" />
                Configuraci√≥n General
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="orgName">Nombre de la Organizaci√≥n</Label>
                  <Input
                    id="orgName"
                    value={orgName}
                    onChange={(e) => setOrgName(e.target.value)}
                    placeholder="Mi Organizaci√≥n"
                  />
                </div>
                <div>
                  <Label htmlFor="timezone">Zona Horaria</Label>
                  <Select 
                    value={settings.general_settings.timezone} 
                    onValueChange={(value) => updateGeneralSettings({ timezone: value })}
                    disabled={saving}
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="America/Santiago">Santiago (GMT-3)</SelectItem>
                      <SelectItem value="America/Buenos_Aires">Buenos Aires (GMT-3)</SelectItem>
                      <SelectItem value="America/Lima">Lima (GMT-5)</SelectItem>
                      <SelectItem value="America/Bogota">Bogot√° (GMT-5)</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>

              <div>
                <Label htmlFor="description">Descripci√≥n</Label>
                <Textarea
                  id="description"
                  value={orgDescription}
                  onChange={(e) => setOrgDescription(e.target.value)}
                  placeholder="Describe tu organizaci√≥n..."
                  rows={3}
                />
              </div>

              <div>
                <Label htmlFor="logoUrl">URL del Logo</Label>
                <div className="flex gap-2">
                  <Input
                    id="logoUrl"
                    value={orgLogoUrl}
                    onChange={(e) => setOrgLogoUrl(e.target.value)}
                    placeholder="https://ejemplo.com/logo.png"
                  />
                  <Button variant="outline">
                    <Upload className="w-4 h-4" />
                  </Button>
                </div>
              </div>

              <Button onClick={handleSaveOrganization}>
                Guardar Cambios
              </Button>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="instagram" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Instagram className="w-5 h-5" />
                Conexi√≥n de Instagram
              </CardTitle>
              <CardDescription>
                Gestiona la conexi√≥n con Instagram para sincronizar historias y embajadores autom√°ticamente.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <EnhancedInstagramSettings />
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="notifications">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Bell className="w-5 h-5" />
                Preferencias de Notificaciones
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div>
                    <Label>Notificaciones por Email</Label>
                    <p className="text-sm text-muted-foreground">
                      Recibir notificaciones importantes por email
                    </p>
                  </div>
                  <Switch
                    checked={settings.notification_settings.email_notifications}
                    onCheckedChange={(checked) => updateNotificationSettings({ email_notifications: checked })}
                  />
                </div>

                <div className="flex items-center justify-between">
                  <div>
                    <Label>Notificaciones Push</Label>
                    <p className="text-sm text-muted-foreground">
                      Recibir notificaciones en tiempo real
                    </p>
                  </div>
                  <Switch
                    checked={settings.notification_settings.push_notifications}
                    onCheckedChange={(checked) => updateNotificationSettings({ push_notifications: checked })}
                  />
                </div>

                <div className="flex items-center justify-between">
                  <div>
                    <Label>Alertas de Expiraci√≥n de Token</Label>
                    <p className="text-sm text-muted-foreground">
                      Avisar cuando el token de Instagram est√© por expirar
                    </p>
                  </div>
                  <Switch
                    checked={settings.notification_settings.token_expiry_alerts}
                    onCheckedChange={(checked) => updateNotificationSettings({ token_expiry_alerts: checked })}
                  />
                </div>

                <div className="flex items-center justify-between">
                  <div>
                    <Label>Reportes Semanales</Label>
                    <p className="text-sm text-muted-foreground">
                      Recibir resumen semanal de actividad
                    </p>
                  </div>
                  <Switch
                    checked={settings.notification_settings.weekly_reports}
                    onCheckedChange={(checked) => updateNotificationSettings({ weekly_reports: checked })}
                  />
                </div>
              </div>

              <Button onClick={() => updateNotificationSettings({})} disabled={saving}>
                {saving ? 'Guardando...' : 'Guardar Preferencias'}
              </Button>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="permissions">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Shield className="w-5 h-5" />
                Configuraci√≥n de Permisos
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div>
                    <Label>Auto-registro de Embajadores</Label>
                    <p className="text-sm text-muted-foreground">
                      Permitir que los embajadores se registren autom√°ticamente
                    </p>
                  </div>
                  <Switch
                    checked={settings.permission_settings.allow_ambassador_self_registration}
                    onCheckedChange={(checked) => updatePermissionSettings({ allow_ambassador_self_registration: checked })}
                  />
                </div>

                <div className="flex items-center justify-between">
                  <div>
                    <Label>Aprobaci√≥n Manual de Tareas</Label>
                    <p className="text-sm text-muted-foreground">
                      Requerir aprobaci√≥n manual para completar tareas
                    </p>
                  </div>
                  <Switch
                    checked={settings.permission_settings.require_approval_for_tasks}
                    onCheckedChange={(checked) => updatePermissionSettings({ require_approval_for_tasks: checked })}
                  />
                </div>

                <div className="flex items-center justify-between">
                  <div>
                    <Label>Validaci√≥n Autom√°tica</Label>
                    <p className="text-sm text-muted-foreground">
                      Validar tareas autom√°ticamente despu√©s de 24 horas
                    </p>
                  </div>
                  <Switch
                    checked={settings.permission_settings.auto_validate_tasks}
                    onCheckedChange={(checked) => updatePermissionSettings({ auto_validate_tasks: checked })}
                  />
                </div>
              </div>

              <Button onClick={() => updatePermissionSettings({})} disabled={saving}>
                {saving ? 'Guardando...' : 'Guardar Permisos'}
              </Button>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="appearance">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Palette className="w-5 h-5" />
                Configuraci√≥n de Apariencia
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="theme">Tema</Label>
                  <Select 
                    value={settings.appearance_settings.theme} 
                    onValueChange={(value) => updateAppearanceSettings({ theme: value })}
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="light">Claro</SelectItem>
                      <SelectItem value="dark">Oscuro</SelectItem>
                      <SelectItem value="system">Sistema</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Label htmlFor="language">Idioma</Label>
                  <Select 
                    value={settings.general_settings.language} 
                    onValueChange={(value) => updateGeneralSettings({ language: value })}
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="es">Espa√±ol</SelectItem>
                      <SelectItem value="en">English</SelectItem>
                      <SelectItem value="pt">Portugu√™s</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>

              <div className="flex items-center justify-between">
                <div>
                  <Label>Modo Compacto</Label>
                  <p className="text-sm text-muted-foreground">
                    Usar un dise√±o m√°s compacto para la interfaz
                  </p>
                </div>
                <Switch
                  checked={settings.appearance_settings.compact_mode}
                  onCheckedChange={(checked) => updateAppearanceSettings({ compact_mode: checked })}
                />
              </div>

              <Button onClick={() => updateAppearanceSettings({})} disabled={saving}>
                {saving ? 'Guardando...' : 'Guardar Apariencia'}
              </Button>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="integrations">
          <div className="space-y-6">
            {/* N8N Configuration Section */}
            <N8nConfigurationSection />
            
            {/* Other Integrations */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Zap className="w-5 h-5" />
                  Otras Integraciones
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-6">
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <Label>Google Drive</Label>
                      <p className="text-sm text-muted-foreground">
                        Conectar con Google Drive para importar/exportar
                      </p>
                    </div>
                    <Switch
                      checked={settings.integration_settings.google_drive_enabled}
                      onCheckedChange={(checked) => updateIntegrationSettings({ google_drive_enabled: checked })}
                    />
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <Label>Zapier</Label>
                      <p className="text-sm text-muted-foreground">
                        Habilitar webhooks para Zapier
                      </p>
                    </div>
                    <Switch
                      checked={settings.integration_settings.zapier_enabled}
                      onCheckedChange={(checked) => updateIntegrationSettings({ zapier_enabled: checked })}
                    />
                  </div>
                </div>

                <Button onClick={() => updateIntegrationSettings({})} disabled={saving}>
                  {saving ? 'Guardando...' : 'Guardar Integraciones'}
                </Button>
              </CardContent>
            </Card>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/hooks/useCurrentOrganization.ts">
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from './useAuth';
import { toast } from 'sonner';

interface OrganizationMembership {
  organization_id: string;
  role: string;
  is_owner: boolean;
  organization: {
    id: string;
    name: string;
    description?: string;
    timezone: string;
    logo_url?: string;
    plan_type: string;
    instagram_username?: string;
    instagram_connected: boolean;
    last_instagram_sync?: string;
    created_at: string;
    facebook_page_id?: string;
    instagram_business_account_id?: string;
    instagram_user_id?: string;
  };
}

export const useCurrentOrganization = () => {
  const { user } = useAuth();
  const [currentOrganization, setCurrentOrganization] = useState<OrganizationMembership | null>(null);
  const [userOrganizations, setUserOrganizations] = useState<OrganizationMembership[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchOrganizations = useCallback(async () => {
    if (!user?.id) return;
    
    setLoading(true);
    setError(null);
    
    try {
      // Get user's accessible organizations
      const { data: userOrgs, error: orgsError } = await supabase
        .rpc('get_user_organizations', { user_auth_id: user.id });

      if (orgsError) {
        throw orgsError;
      }

      // If user has NO organizations at all, create one automatically
      if (!userOrgs || userOrgs.length === 0) {
        // Use localStorage as a global lock to prevent concurrent creation across tabs/instances
        const lockKey = `creating_org_${user.id}`;
        const existingLock = localStorage.getItem(lockKey);
        
        // If there's a recent lock (within last 10 seconds), skip
        if (existingLock) {
          const lockTime = parseInt(existingLock);
          const now = Date.now();
          if (now - lockTime < 10000) { // 10 second lock
            console.log('‚ö†Ô∏è Organization creation in progress (locked), skipping...');
            setLoading(false);
            return;
          }
        }

        // Set the lock
        localStorage.setItem(lockKey, Date.now().toString());
        console.log('User has no organizations, creating default organization...');
        
        try {
          // Get user profile for name
          const { data: userProfile } = await supabase
            .from('users')
            .select('id, name, email, organization_id')
            .eq('auth_user_id', user.id)
            .single();

          // Double-check: maybe another tab just created an org
          if (userProfile?.organization_id) {
            console.log('‚úÖ Organization already exists, refreshing...');
            localStorage.removeItem(lockKey);
            // Retry fetching organizations
            const { data: retryOrgs } = await supabase
              .rpc('get_user_organizations', { user_auth_id: user.id });
            if (retryOrgs && retryOrgs.length > 0) {
              const membership = retryOrgs[0];
              const { data: orgDetails } = await supabase
                .rpc('get_organization_safe_info', { org_id: membership.organization_id });
              
              if (orgDetails && orgDetails.length > 0) {
                setCurrentOrganization({
                  ...membership,
                  organization: orgDetails[0]
                });
                setUserOrganizations([{
                  ...membership,
                  organization: orgDetails[0]
                }]);
              }
            }
            setLoading(false);
            return;
          }

          const userName = userProfile?.name || userProfile?.email || user.email || 'Usuario';

          // Create organization
          const { data: newOrg, error: createError } = await supabase
            .from('organizations')
            .insert({
              name: 'Mi Organizaci√≥n',
              description: `Organizaci√≥n de ${userName}`,
              created_by: user.id,
              timezone: 'America/Santiago',
              plan_type: 'free'
            })
            .select()
            .single();

          if (createError) {
            console.error('Error creating organization:', createError);
            localStorage.removeItem(lockKey);
            throw createError;
          }

          console.log('‚úÖ Organization created:', newOrg.id);
          
          // Don't try to update organization_id - RLS policy prevents it
          // The membership relationship is established through get_user_organizations RPC
          
          // Refresh to get the new organization
          const { data: refreshedOrgs } = await supabase
            .rpc('get_user_organizations', { user_auth_id: user.id });
          
          if (refreshedOrgs && refreshedOrgs.length > 0) {
            const membership = refreshedOrgs[0];
            const { data: orgDetails } = await supabase
              .rpc('get_organization_safe_info', { org_id: membership.organization_id });
            
            if (orgDetails && orgDetails.length > 0) {
              setCurrentOrganization({
                ...membership,
                organization: orgDetails[0]
              });
              setUserOrganizations([{
                ...membership,
                organization: orgDetails[0]
              }]);
              toast.success('¬°Organizaci√≥n creada exitosamente!');
            }
          }
          
          // Clear lock after successful creation
          localStorage.removeItem(lockKey);
        } catch (error) {
          localStorage.removeItem(lockKey);
          throw error;
        } finally {
          setLoading(false);
        }
        
        return;
      }

      // Get organizations with their details
      const orgsWithDetails = await Promise.all(
        (userOrgs || []).map(async (orgMembership) => {
          const { data: orgDetails } = await supabase
            .rpc('get_organization_safe_info', { 
              org_id: orgMembership.organization_id 
            });
          
          return {
            ...orgMembership,
            organization: orgDetails && orgDetails.length > 0 ? orgDetails[0] : null
          };
        })
      );

      setUserOrganizations(orgsWithDetails.filter(org => org.organization));

      // Get user's current organization preference
      const { data: userData } = await supabase
        .from('users')
        .select('organization_id')
        .eq('auth_user_id', user.id)
        .single();

      // Set current organization (prefer user's selected one, or first available)
      const preferredOrgId = userData?.organization_id;
      const currentOrg = orgsWithDetails.find(org => 
        org.organization_id === preferredOrgId
      ) || orgsWithDetails[0];

      setCurrentOrganization(currentOrg && currentOrg.organization ? currentOrg : null);
      
    } catch (error) {
      console.error('Error fetching organizations:', error);
      setError(error as Error);
    } finally {
      setLoading(false);
    }
  }, [user?.id]);

  const switchOrganization = async (organizationId: string) => {
    if (!user?.id) return;
    
    try {
      // Update user's current organization preference
      await supabase
        .from('users')
        .update({ organization_id: organizationId })
        .eq('auth_user_id', user.id);

      // Update local state
      const newCurrentOrg = userOrganizations.find(org => 
        org.organization_id === organizationId
      );
      
      if (newCurrentOrg) {
        setCurrentOrganization(newCurrentOrg);
      }
      
    } catch (error) {
      console.error('Error switching organization:', error);
      throw error;
    }
  };

  // Provide legacy compatibility
  const organization = currentOrganization?.organization || null;
  const updateOrganization = async (updates: Partial<any>) => {
    if (!currentOrganization?.organization) return false;
    
    try {
      const { error } = await supabase
        .from('organizations')
        .update(updates)
        .eq('id', currentOrganization.organization.id);

      if (error) {
        console.error('Error updating organization:', error);
        toast.error('Error al actualizar organizaci√≥n');
        return false;
      }

      // Update local state
      setCurrentOrganization({
        ...currentOrganization,
        organization: { ...currentOrganization.organization, ...updates }
      });
      
      toast.success('Organizaci√≥n actualizada');
      return true;
    } catch (error) {
      console.error('Error updating organization:', error);
      toast.error('Error inesperado');
      return false;
    }
  };

  useEffect(() => {
    fetchOrganizations();
  }, [fetchOrganizations]);

  return {
    // New multi-organization interface
    currentOrganization,
    userOrganizations,
    loading,
    error,
    fetchOrganizations,
    switchOrganization,
    // Legacy compatibility
    organization,
    updateOrganization,
    refreshOrganization: fetchOrganizations
  };
};
</file>

<file path="src/hooks/useInstagramConnection.ts">
import { useState, useEffect, useRef } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { toast } from "sonner";
import { useAuth } from "./useAuth";

export function useInstagramConnection() {
  const { user } = useAuth();
  const { organization, loading, updateOrganization, refreshOrganization } = useCurrentOrganization();
  const [isConnecting, setIsConnecting] = useState(false);

  // Refs to prevent infinite loops
  const isRefreshingRef = useRef(false);
  const previousOrgIdRef = useRef<string | undefined>(undefined);
  const isMountedRef = useRef(true);

  // Token status now comes from secure edge function
  const [tokenStatus, setTokenStatus] = useState<{
    isConnected: boolean;
    isTokenExpired: boolean;
    lastSync?: string;
    username?: string;
    tokenExpiryDate?: string;
  }>({
    isConnected: false,
    isTokenExpired: false
  });

  const refreshTokenStatus = async () => {
    // Prevent concurrent calls
    if (isRefreshingRef.current) {
      console.log('Token status refresh already in progress, skipping...');
      return;
    }

    try {
      isRefreshingRef.current = true;
      const { data, error } = await supabase.functions.invoke('instagram-token-status');
      
      // Handle network/invocation errors (not HTTP errors, since we return 200 always)
      if (error) {
        console.error('Network error invoking token status:', error);
        toast.error('Error de conexi√≥n', {
          description: 'No se pudo conectar con el servidor'
        });
        return;
      }
      
      // Handle response data - should always have success field now
      if (data?.success) {
        // Only update state if component is still mounted
        if (isMountedRef.current) {
          setTokenStatus(data.data);
          console.log('Token status updated:', data.data);
        }
      } else {
        // This is a server-reported error (but still HTTP 200)
        console.log('Token status check reported error:', data);
        // Don't show toast for server errors - they're usually permission-related
        // Just set disconnected state
        if (isMountedRef.current) {
          setTokenStatus({
            isConnected: false,
            isTokenExpired: false
          });
        }
      }
    } catch (error) {
      console.error('Unexpected error refreshing token status:', error);
      toast.error('Error de conexi√≥n', {
        description: 'No se pudo conectar con el servidor'
      });
    } finally {
      isRefreshingRef.current = false;
    }
  };

  // Fetch token status securely
  useEffect(() => {
    // Guard: Only refresh if user and organization exist
    if (!user || !organization) {
      return;
    }

    // Guard: Don't refresh if already in progress
    if (isRefreshingRef.current) {
      return;
    }

    // Check for OAuth callback params FIRST (before org change check)
    const urlParams = new URLSearchParams(window.location.search);
    const hasOAuthParams = urlParams.has('status') || urlParams.has('state') || urlParams.has('code');
    
    if (hasOAuthParams) {
      console.log('OAuth callback detected, refreshing token status...');
      
      // Clean up URL parameters
      try {
        const cleanUrl = window.location.pathname + '?tab=instagram';
        setTimeout(() => {
          try {
            window.history.replaceState({}, document.title, cleanUrl);
          } catch (error) {
            console.warn('Could not clean URL parameters (fallback):', error);
          }
        }, 100);
      } catch (error) {
        console.warn('Could not clean URL parameters:', error);
      }
      
      // Refresh token status immediately and again after a delay
      refreshTokenStatus();
      setTimeout(() => {
        console.log('Refreshing token status again after OAuth callback...');
        refreshTokenStatus();
      }, 2000);
      
      return;
    }

    // Guard: Only refresh if organization ID actually changed (for non-OAuth cases)
    if (previousOrgIdRef.current === organization.id) {
      return;
    }

    console.log('Organization changed, refreshing token status...', organization.id);
    previousOrgIdRef.current = organization.id;
    refreshTokenStatus();
  }, [user?.id, organization?.id]);

  // Cleanup on unmount
  useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  const isConnected = tokenStatus.isConnected;
  const isTokenExpired = tokenStatus.isTokenExpired;

  const connectInstagram = async (onCredentialsNeeded?: () => void) => {
    if (loading) {
      toast.error('Cargando organizaci√≥n...');
      return;
    }

    if (!organization) {
      toast.info('Preparando organizaci√≥n...');
      try {
        await refreshOrganization();
        // Give some time for state to update
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        toast.error('No se pudo preparar tu organizaci√≥n. Reintenta.');
        return;
      }
    }

    // Re-check organization after potential refresh
    if (!organization) {
      toast.error('No se encontr√≥ organizaci√≥n');
      return;
    }

    try {
      setIsConnecting(true);

      // Try to connect - the meta-oauth function will handle credential validation
      console.log('Attempting Instagram connection for organization:', organization.id);
      
      // Call the meta-oauth edge function with action as query parameter
      const { data, error } = await supabase.functions.invoke('meta-oauth?action=authorize', {
        body: {
          user_id: user?.id,
          organization_id: organization.id,
          type: 'organization'
          // redirect_base removed - always using production URL for Meta OAuth
        }
      });

      if (error) {
        console.error('Error initiating Instagram connection:', error);
        
        // Mensajes de error m√°s espec√≠ficos
        let errorMessage = 'Error al conectar con Instagram';
        let errorDescription = undefined;
        
        if (error.message?.includes('configuration_error')) {
          errorMessage = 'Configuraci√≥n de Meta App incorrecta';
          errorDescription = 'Verifica App ID, App Secret y configuraci√≥n de OAuth';
        } else if (error.message?.includes('unauthorized') || error.message?.includes('forbidden')) {
          errorMessage = 'Sin permisos para conectar Instagram';
          errorDescription = 'Verifica que seas miembro de esta organizaci√≥n';
        } else if (error.message?.includes('credentials') || error.message?.includes('configuration_error')) {
          errorMessage = 'Credenciales de Meta no encontradas';
          errorDescription = 'Configura las credenciales de Meta App primero. Aseg√∫rate de que el redirect URI en Meta Developers sea: https://app.evasystem.cl/api/meta-oauth?action=callback';
          if (onCredentialsNeeded) {
            onCredentialsNeeded();
          }
        }
        
        toast.error(errorMessage, {
          description: errorDescription
        });
        return;
      }

      if (data?.authUrl) {
        // Redirect to Meta OAuth
        window.location.href = data.authUrl;
      } else {
        toast.error('No se pudo obtener URL de autorizaci√≥n', {
          description: 'Verifica la configuraci√≥n de Meta App'
        });
      }
    } catch (error) {
      console.error('Error connecting Instagram:', error);
      toast.error('Error inesperado al conectar Instagram');
    } finally {
      setIsConnecting(false);
    }
  };

  const disconnectInstagram = async () => {
    if (!organization) return;

    try {
      setIsConnecting(true);
      console.log('Disconnecting Instagram...');
      
      const { data, error } = await supabase.functions.invoke('disconnect-instagram');

      if (error) {
        console.error('Disconnect error:', error);
        toast.error('Error al desconectar', {
          description: error.message || 'No se pudo desconectar Instagram'
        });
        return;
      }
      
      if (!data?.success) {
        toast.error('Error al desconectar', {
          description: data?.error || 'No se pudo completar la desconexi√≥n'
        });
        return;
      }

      // Refresh token status and organization data
      await refreshTokenStatus();
      await refreshOrganization();
      toast.success('Instagram desconectado exitosamente');
    } catch (error) {
      console.error('Error disconnecting Instagram:', error);
      toast.error('Error inesperado', {
        description: 'No se pudo completar la desconexi√≥n'
      });
    } finally {
      setIsConnecting(false);
    }
  };

  return {
    isConnected,
    isTokenExpired,
    isConnecting: isConnecting || loading,
    connectInstagram,
    disconnectInstagram,
    lastSync: tokenStatus.lastSync,
    refreshTokenStatus: refreshTokenStatus
  };
}
</file>

<file path="supabase/functions/disconnect-instagram/index.ts">
import { corsHeaders } from '../shared/constants.ts';
import { corsPreflightResponse, jsonResponse } from '../shared/responses.ts';
import { authenticateRequest, getUserOrganization, createSupabaseClient } from '../shared/auth.ts';
import { handleError, assert } from '../shared/error-handler.ts';

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return corsPreflightResponse();
  }

  try {
    // Authenticate user
    const authResult = await authenticateRequest(req);
    if (authResult instanceof Response) return authResult;
    
    const { user, supabase: supabaseClient } = authResult;

    // Get user's organization
    const organizationId = await getUserOrganization(supabaseClient, user.id);
    assert(organizationId, 'Organization not found', 404);

    // Delete tokens from secure table
    const { error: tokenError } = await supabaseClient
      .from('organization_instagram_tokens')
      .delete()
      .eq('organization_id', organizationId);

    if (tokenError) {
      console.error('Failed to delete organization tokens:', tokenError);
      throw new Error('Failed to disconnect Instagram tokens');
    }

    // Verify user has access to this organization
    const { data: hasAccess } = await supabaseClient
      .rpc('is_organization_member', {
        user_auth_id: user.id,
        org_id: organizationId
      });

    if (!hasAccess) {
      throw new Error('No access to this organization');
    }

    // Clear Instagram-related fields from organizations table
    const { error: updateError } = await supabaseClient
      .from('organizations')
      .update({
        instagram_user_id: null,
        instagram_username: null,
        facebook_page_id: null,
        instagram_business_account_id: null,
        last_instagram_sync: null
      })
      .eq('id', organizationId);

    if (updateError) {
      console.error('Failed to disconnect Instagram:', updateError);
      throw new Error('Failed to disconnect Instagram account');
    }

    console.log('Instagram account disconnected successfully for organization:', organizationId);

    return jsonResponse({
      success: true,
      message: 'Instagram account disconnected successfully'
    });

  } catch (error) {
    return handleError(error);
  }
});
</file>

<file path="supabase/functions/instagram-diagnostics/index.ts">
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { corsHeaders, INSTAGRAM_API_BASE } from '../shared/constants.ts';
import { Organization, SupabaseClient, Notification } from '../shared/types.ts';
import { corsPreflightResponse, jsonResponse, unauthorizedResponse, badRequestResponse, notFoundResponse } from '../shared/responses.ts';
import { authenticateRequest, createSupabaseClient } from '../shared/auth.ts';
import { handleError } from '../shared/error-handler.ts';

Deno.serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return corsPreflightResponse();
  }

  try {
    // SECURITY: Authenticate user first
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: 'Authentication required' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Verify user authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser(
      authHeader.replace('Bearer ', '')
    );

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Invalid authentication' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const { organization_id, test } = await req.json();

    if (!organization_id) {
      return new Response(
        JSON.stringify({ error: 'Organization ID is required' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // SECURITY: Verify user is a member of this organization
    const { data: isMember } = await supabase
      .rpc('is_organization_member', {
        user_auth_id: user.id,
        org_id: organization_id
      });

    if (!isMember) {
      return new Response(
        JSON.stringify({ error: 'Organization not found or access denied' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get organization data
    const { data: org, error: orgError } = await supabase
      .from('organizations')
      .select('id, instagram_business_account_id, instagram_username')
      .eq('id', organization_id)
      .single();

    if (orgError || !org) {
      return new Response(
        JSON.stringify({ error: 'Organization not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get token from secure table
    const { data: tokenData } = await supabase
      .from('organization_instagram_tokens')
      .select('access_token, token_expiry')
      .eq('organization_id', organization_id)
      .single();

    // Merge token into org object for backwards compatibility with test functions
    const orgWithToken = {
      ...org,
      meta_token: tokenData?.access_token || null,
      token_expiry: tokenData?.token_expiry || null
    };

    let result = {};

    switch (test) {
      case 'token_validity':
        result = await testTokenValidity(orgWithToken);
        break;
      case 'profile_access':
        result = await testProfileAccess(orgWithToken);
        break;
      case 'mentions_permissions':
        result = await testMentionsPermissions(orgWithToken);
        break;
      case 'stories_permissions':
        result = await testStoriesPermissions(orgWithToken);
        break;
      case 'webhook_status':
        result = await testWebhookStatus(supabase, orgWithToken);
        break;
      case 'webhook_test':
        result = await testWebhookDelivery(orgWithToken);
        break;
      default:
        return new Response(
          JSON.stringify({ error: 'Invalid test type' }),
          { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
    }

    return new Response(
      JSON.stringify(result),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    return handleError(error);
  }
});

async function testTokenValidity(org: Organization) {
  // Get credentials from secure table
  const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
  const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
  const supabase = createClient(supabaseUrl, supabaseKey);
  
  const { data: creds, error: credsError } = await supabase
    .rpc('get_organization_credentials_secure', {
      p_organization_id: org.id
    });

  if (credsError || !creds || creds.length === 0) {
    return { 
      valid: false, 
      error: 'No Meta credentials configured for organization',
      credentials_info: {
        app_id: 'Not configured',
        has_app_secret: false,
        has_webhook_token: false
      }
    };
  }

  const orgCreds = creds[0];
  
  if (!org.meta_token) {
    return { 
      valid: false, 
      error: 'No Instagram token found',
      credentials_info: {
        app_id: orgCreds.meta_app_id || 'Not configured',
        has_app_secret: !!orgCreds.meta_app_secret,
        has_webhook_token: !!orgCreds.webhook_verify_token
      }
    };
  }

  try {
    const response = await fetch(
      `${INSTAGRAM_API_BASE}/me?access_token=${org.meta_token}`
    );

    const data = await response.json();
    
    if (data.error) {
      return { 
        valid: false, 
        error: data.error.message,
        credentials_info: {
          app_id: orgCreds.meta_app_id || 'Not configured',
          has_app_secret: !!orgCreds.meta_app_secret,
          has_webhook_token: !!orgCreds.webhook_verify_token
        }
      };
    }

    return { 
      valid: true, 
      token_info: {
        account: data.name || data.username,
        id: data.id
      },
      credentials_info: {
        app_id: orgCreds.meta_app_id || 'Not configured',
        has_app_secret: !!orgCreds.meta_app_secret,
        has_webhook_token: !!orgCreds.webhook_verify_token
      }
    };
  } catch (error) {
    return { 
      valid: false, 
      error: error.message,
      credentials_info: {
        app_id: orgCreds.meta_app_id || 'Not configured',
        has_app_secret: !!orgCreds.meta_app_secret,
        has_webhook_token: !!orgCreds.webhook_verify_token
      }
    };
  }
}

async function testProfileAccess(org: Organization) {
  if (!org.meta_token || !org.instagram_business_account_id) {
    throw new Error('Missing token or Instagram business account ID');
  }

  try {
    const response = await fetch(
      `${INSTAGRAM_API_BASE}/${org.instagram_business_account_id}?fields=id,username,followers_count,media_count&access_token=${org.meta_token}`
    );
    const data = await response.json();
    
    if (response.ok) {
      return { 
        accessible: true, 
        profile: data 
      };
    } else {
      throw new Error(data.error?.message || 'Profile access failed');
    }
  } catch (error) {
    throw new Error(`Profile access error: ${error.message}`);
  }
}

async function testMentionsPermissions(org: Organization) {
  if (!org.meta_token || !org.instagram_business_account_id) {
    throw new Error('Missing token or Instagram business account ID');
  }

  try {
    // Test access to mentioned media
    const response = await fetch(
      `${INSTAGRAM_API_BASE}/${org.instagram_business_account_id}/tags?limit=1&access_token=${org.meta_token}`
    );
    const data = await response.json();
    
    if (response.ok) {
      return { 
        accessible: true, 
        mentions_available: data.data ? data.data.length >= 0 : true,
        sample_data: data.data
      };
    } else {
      throw new Error(data.error?.message || 'Mentions access failed');
    }
  } catch (error) {
    throw new Error(`Mentions permissions error: ${error.message}`);
  }
}

async function testStoriesPermissions(org: Organization) {
  if (!org.meta_token || !org.instagram_business_account_id) {
    throw new Error('Missing token or Instagram business account ID');
  }

  try {
    // Test access to stories
    const response = await fetch(
      `${INSTAGRAM_API_BASE}/${org.instagram_business_account_id}/stories?limit=1&access_token=${org.meta_token}`
    );
    const data = await response.json();
    
    if (response.ok) {
      return { 
        accessible: true, 
        stories_available: data.data ? data.data.length >= 0 : true
      };
    } else {
      // Stories might not be available or might require different permissions
      return { 
        accessible: false, 
        error: data.error?.message || 'Stories access not available',
        note: 'This might be normal if no recent stories exist or permissions are limited'
      };
    }
  } catch (error) {
    return { 
      accessible: false, 
      error: `Stories permissions error: ${error.message}`,
      note: 'This might be normal depending on account type and permissions'
    };
  }
}

async function testWebhookStatus(supabase: SupabaseClient, org: Organization) {
  // Get credentials to verify webhook setup
  const { data: creds, error: credsError } = await supabase
    .rpc('get_organization_credentials_secure', {
      p_organization_id: org.id
    });

  const hasCredentials = !credsError && creds && creds.length > 0;
  const orgCreds = hasCredentials ? creds[0] : null;

  // Check for recent webhook notifications in the last 24 hours
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);

  const { data: recentNotifications, error } = await supabase
    .from('notifications')
    .select('created_at, type')
    .eq('organization_id', org.id)
    .gte('created_at', yesterday.toISOString())
    .order('created_at', { ascending: false })
    .limit(5);

  if (error) {
    return { 
      configured: hasCredentials, 
      reachable: false, 
      error: error.message,
      credentials_configured: hasCredentials,
      webhook_url: 'https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-webhook'
    };
  }

  return {
    configured: hasCredentials,
    reachable: recentNotifications && recentNotifications.length > 0,
    recent_activity: recentNotifications?.map((n: Notification) => ({
      type: n.type,
      created_at: n.created_at
    })) || [],
    credentials_configured: hasCredentials,
    app_id: orgCreds?.meta_app_id || null,
    webhook_url: 'https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-webhook',
    verify_token_configured: !!(orgCreds?.webhook_verify_token)
  };
}

async function testWebhookDelivery(org: Organization) {
  // Send a test webhook payload to verify signature validation
  if (!org.instagram_business_account_id) {
    return {
      test_sent: false,
      error: 'No Instagram Business Account ID configured'
    };
  }

  try {
    // Get organization credentials for signing
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);
    
    const { data: creds, error: credsError } = await supabase
      .rpc('get_organization_credentials_secure', {
        p_organization_id: org.id
      });

    if (credsError || !creds || creds.length === 0 || !creds[0].meta_app_secret) {
      return {
        test_sent: false,
        error: 'No Meta App Secret configured for organization'
      };
    }

    const appSecret = creds[0].meta_app_secret;

    // Create test payload
    const testPayload = {
      object: "instagram",
      entry: [{
        id: org.instagram_business_account_id,
        messaging: [{
          sender: { id: "test_user_id" },
          recipient: { id: org.instagram_business_account_id },
          timestamp: Date.now(),
          referral: {
            source: "SHORTLINK",
            type: "STORY",
            referer_uri: "https://www.instagram.com/stories/test_user/123456789/"
          },
          message: {
            text: "EVA Diagnostics Test - Story Mention"
          }
        }]
      }]
    };

    const payloadString = JSON.stringify(testPayload);

    // Generate signature
    const encoder = new TextEncoder();
    const key = await crypto.subtle.importKey(
      'raw',
      encoder.encode(appSecret),
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']
    );
    const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(payloadString));
    const signatureHex = Array.from(new Uint8Array(signature))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');

    // Send test webhook to our own endpoint
    const webhookResponse = await fetch('https://awpfslcepylnipaolmvv.supabase.co/functions/v1/instagram-webhook', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Hub-Signature-256': `sha256=${signatureHex}`,
        'User-Agent': 'EVA-Diagnostics-Test'
      },
      body: payloadString
    });

    const responseText = await webhookResponse.text();
    
    return {
      test_sent: true,
      webhook_response_status: webhookResponse.status,
      webhook_response: responseText,
      success: webhookResponse.status === 200,
      signature_used: `sha256=${signatureHex.substring(0, 8)}...`,
      app_id_used: creds[0].meta_app_id
    };

  } catch (error) {
    console.error('Webhook test error:', error);
    return {
      test_sent: false,
      error: error.message
    };
  }
}
</file>

<file path="supabase/functions/instagram-token-status/index.ts">
import { corsHeaders } from '../shared/constants.ts';
import { corsPreflightResponse, jsonResponse } from '../shared/responses.ts';
import { authenticateRequest, getUserOrganization, createSupabaseClient } from '../shared/auth.ts';
import { handleError } from '../shared/error-handler.ts';

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return corsPreflightResponse();
  }

  try {
    // Initialize Supabase client with service role to access token columns
    const supabaseClient = createSupabaseClient();

    // Get the user from the Authorization header
    const authHeader = req.headers.get('Authorization')
    if (!authHeader) {
      console.log('No authorization header provided');
      return jsonResponse({
          success: true,
          data: {
            isConnected: false,
            isTokenExpired: false,
            lastSync: null,
            username: null,
            tokenExpiryDate: null
          }
        })
    }

    const { data: { user }, error: authError } = await supabaseClient.auth.getUser(
      authHeader.replace('Bearer ', '')
    )

    if (authError || !user) {
      console.log('User authentication failed:', authError?.message);
      return jsonResponse({
          success: true,
          data: {
            isConnected: false,
            isTokenExpired: false,
            lastSync: null,
            username: null,
            tokenExpiryDate: null
          }
        })
    }

    console.log('Checking token status for user:', user.id);

    // Get user's organization via organization_members (same as frontend)
    // This is more reliable than users.organization_id which can be null
    const { data: userOrgs, error: orgsError } = await supabaseClient
      .rpc('get_user_organizations', { user_auth_id: user.id });

    if (orgsError || !userOrgs || userOrgs.length === 0) {
      console.log('No organizations found for user:', orgsError?.message);
      return jsonResponse({
          success: true,
          data: {
            isConnected: false,
            isTokenExpired: false,
            lastSync: null,
            username: null,
            tokenExpiryDate: null
          }
        })
    }

    // Use the first organization (or the one marked as current if available)
    const organizationId = userOrgs[0].organization_id;
    console.log('Found organization for user:', user.id, 'org:', organizationId);

    // Get organization token status from secure table
    const { data: orgData, error: orgError } = await supabaseClient
      .from('organizations')
      .select('instagram_username, last_instagram_sync')
      .eq('id', organizationId)
      .single();

    if (orgError) {
      console.error('Failed to fetch organization data:', orgError);
      return jsonResponse({
          success: false,
          error: 'Organization data not found',
          error_type: 'database_error'
        })
    }

    // Get token info from secure table using service_role
    const { data: tokenData, error: tokenError } = await supabaseClient
      .from('organization_instagram_tokens')
      .select('token_expiry')
      .eq('organization_id', organizationId)
      .single();

    // Token not found is not an error - organization might not be connected
    const hasToken = !tokenError && tokenData;
    console.log('Token status for org', organizationId, ':', hasToken ? 'found' : 'not found');

    const isConnected = !!hasToken;
    const isTokenExpired = hasToken && tokenData.token_expiry ? new Date(tokenData.token_expiry) < new Date() : false;

    return new Response(
      JSON.stringify({
        success: true,
        data: {
          isConnected,
          isTokenExpired,
          lastSync: orgData.last_instagram_sync,
          username: orgData.instagram_username,
          tokenExpiryDate: hasToken ? tokenData.token_expiry : null
        }
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      },
    )

  } catch (error) {
    return handleError(error);
  }
});
</file>

<file path="supabase/functions/shared/types.ts">
/**
 * Shared TypeScript interfaces for Supabase Edge Functions
 * Single source of truth for data structures
 */

import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

/**
 * Supabase client type
 */
export type SupabaseClient = ReturnType<typeof createClient>;

/**
 * Organization data structure
 */
export interface Organization {
  id: string;
  name: string;
  meta_token?: string;
  token_expiry?: string;
  instagram_business_account_id?: string;
  instagram_username?: string;
  instagram_user_id?: string;
  instagram_handle?: string;
  facebook_page_id?: string;
  created_by?: string;
}

/**
 * Ambassador/Embassador data structure
 */
export interface Ambassador {
  id: string;
  organization_id: string;
  first_name: string;
  last_name: string;
  instagram_user?: string;
  instagram_user_id?: string;
  follower_count?: number;
  profile_picture_url?: string;
}

/**
 * Social mention data structure
 */
export interface SocialMention {
  id: string;
  organization_id: string;
  instagram_user_id?: string;
  instagram_username?: string;
  instagram_story_id?: string;
  instagram_media_id?: string;
  content: string;
  mention_type: 'story' | 'story_referral' | 'comment' | 'mention' | 'tag';
  mentioned_at: string;
  expires_at?: string;
  state?: string;
  processed?: boolean;
  checks_count?: number;
  last_check_at?: string;
  matched_ambassador_id?: string;
  story_url?: string;
  conversation_id?: string;
  inbox_link?: string;
}

/**
 * Story insights metrics
 * See: https://developers.facebook.com/docs/instagram-platform/reference/instagram-media/insights
 * 
 * Available STORY metrics:
 * - reach: Unique accounts that viewed the story
 * - replies: Total replies on the story
 * - shares: Number of shares
 * - profile_visits: Number of profile visits from the story
 * - total_interactions: Likes, saves, comments, shares (minus unlikes/unsaves/deleted)
 * - views: Total views (metric in development)
 * - navigation: Total navigation actions with breakdown (tap_forward, tap_back, tap_exit, swipe_forward)
 * 
 * Note: 'impressions' was deprecated in v22.0+ for media created after July 2, 2024
 */
export interface StoryInsights {
  // Core metrics
  reach: number;
  replies: number;
  shares: number;
  
  // Engagement metrics
  profile_visits: number;
  total_interactions: number;
  views: number;
  
  // Navigation breakdown (tap_forward, tap_back, tap_exit, swipe_forward)
  navigation?: number | {
    tap_forward?: number;
    tap_back?: number;
    tap_exit?: number;
    swipe_forward?: number;
  };
  
  // Legacy fields (kept for DB compatibility)
  impressions?: number;
  exits?: number;
  taps_forward?: number;
  taps_back?: number;
}

/**
 * Instagram insights data
 */
export interface InsightsData {
  media_id?: string;
  id?: string;
  metric_values?: Array<{
    name: string;
    value: number;
  }>;
  [key: string]: unknown;
}
/**
 * Dynamic insights map (allows additional metrics)
 */
export interface InsightsMap {
  impressions?: number;
  reach?: number;
  replies?: number;
  exits?: number;
  taps_forward?: number;
  taps_back?: number;
  shares?: number;
  [key: string]: number | undefined;
}

/**
 * Instagram media item
 */
export interface MediaItem {
  id: string;
  username?: string;
  timestamp?: string;
  media_type?: string;
  media_product_type?: string;
  media_url?: string;
  [key: string]: unknown;
}

/**
 * Instagram comment data
 */
export interface CommentData {
  id: string;
  text?: string;
  from?: {
    id: string;
    username?: string;
  };
  media?: {
    id: string;
  };
  [key: string]: unknown;
}

/**
 * Instagram message data
 */
export interface MessageData {
  mid?: string;
  id?: string;
  text?: string;
  sender?: {
    id: string;
    username?: string;
  };
  referral?: {
    source?: string;
    type?: string;
    ref?: string;
    referer_uri?: string;
  };
  timestamp?: number;
  [key: string]: unknown;
}

/**
 * Meta OAuth token data
 */
export type TokenData = {
  access_token: string;
  expires_in: number;   // seconds
};


/**
 * Social mention update data
 */
export interface MentionUpdateData {
  checks_count: number;
  last_check_at: string;
  state?: string;
  processed?: boolean;
  processed_at?: string;
}

/**
 * Notification data structure
 */
export interface Notification {
  created_at: string;
  type: string;
  organization_id?: string;
  message?: string;
  priority?: 'low' | 'normal' | 'high';
  target_type?: string;
  target_id?: string;
}

/**
 * Error with structured message
 */
export interface ErrorWithMessage {
  name?: string;
  message?: string;
  stack?: string;
}

/**
 * Instagram data for ambassadors
 */
export interface InstagramData {
  instagram_user_id: string;
  instagram_user?: string;
  follower_count?: number;
  profile_picture_url?: string;
}

/**
 * Instagram data for organizations
 */
export interface OrganizationInstagramData {
  facebook_page_id: string;
  instagram_business_account_id?: string;
  instagram_username?: string;
  instagram_user_id?: string;
}

/**
 * Fiesta (event) data structure
 */
export interface Fiesta {
  id: string;
  organization_id?: string;
  name?: string;
  created_at?: string;
}


export interface MediaData {
  id: string;
  username?: string;
  media_type?: string;
  timestamp?: string;
  [key: string]: unknown;
}

export interface CommentData {
  id: string;
  text?: string;
  from?: {
    id: string;
    username?: string;
  };
  media?: {
    id: string;
  };
  [key: string]: unknown;
}

export interface MessageData {
  mid?: string;
  id?: string;
  text?: string;
  sender?: {
    id: string;
    username?: string;
  };
  referral?: {
    source?: string;
    type?: string;
    ref?: string;
    referer_uri?: string;
  };
  timestamp?: number;
  [key: string]: unknown;
}


export interface SyncResult {
  organization_id: string;
  organization_name: string;
  success: boolean;
  totalFollowers?: number;
  totalPosts?: number;
  totalReach?: number;
  totalImpressions?: number;
  newMentions?: number;
  newTags?: number;
  error?: string;
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Dependencies
node_modules
.pnp
.pnp.js

# Build outputs
dist
dist-ssr
build
.vite
*.local

# Environment variables
.env
.env.local
.env.*.local
.env.production
.env.development

# Supabase
supabase/.temp
supabase/.branches
.supabase

# Deno
.deno
deno.lock

# Testing & Coverage
coverage
*.lcov
.nyc_output

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
*.swp
*.swo
*~

# OS files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Package manager lock files (uncomment if you want to ignore them)
# package-lock.json
# yarn.lock
# pnpm-lock.yaml
# bun.lockb
</file>

<file path="src/hooks/useStoryInsightsAnalytics.ts">
import { useState, useEffect, useCallback } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useCurrentOrganization } from "./useCurrentOrganization";
import { toast } from "sonner";

// Database row type (not in generated Supabase types yet)
interface StoryInsightsSnapshotRow {
  id: string;
  instagram_story_id: string;
  snapshot_at: string;
  story_age_hours: number | null;
  reach: number;
  views: number;
  profile_visits: number;
  total_interactions: number;
  shares: number;
  replies: number;
  navigation: Record<string, number>;
  organization_id: string;
}

export interface StoryInsightsSummary {
  total_stories: number;
  total_reach: number;
  total_views: number;
  total_profile_visits: number;
  total_interactions: number;
  total_shares: number;
  total_replies: number;
  avg_reach_per_story: number;
  avg_views_per_story: number;
}

export interface StorySnapshot {
  id: string;
  instagram_story_id: string;
  snapshot_at: string;
  story_age_hours: number | null;
  reach: number;
  views: number;
  profile_visits: number;
  total_interactions: number;
  shares: number;
  replies: number;
  navigation: Record<string, number>;
}

export interface DailyStoryMetrics {
  date: string;
  stories_count: number;
  total_reach: number;
  total_views: number;
  total_profile_visits: number;
  total_interactions: number;
  avg_reach: number;
}

export interface StoryByHour {
  instagram_story_id: string;
  reach: number;
  views: number;
  created_at: Date;
}

export interface HourlyMetrics {
  hour: number;
  avg_reach: number;
  avg_views: number;
  stories_count: number;
  stories: StoryByHour[];
  // Dynamic keys for stacked bars: story_0_reach, story_1_reach, story_0_id, etc.
  [key: string]: number | string | StoryByHour[] | undefined;
}

export interface StoryInsightsData {
  summary: StoryInsightsSummary;
  recent_snapshots: StorySnapshot[];
  daily_metrics: DailyStoryMetrics[];
  metrics_by_hour: HourlyMetrics[];
  max_stories_per_hour: number; // For generating dynamic bar keys
}

export function useStoryInsightsAnalytics(selectedPeriod: string = "7d") {
  const { organization } = useCurrentOrganization();
  const [data, setData] = useState<StoryInsightsData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const getPeriodDays = (period: string): number => {
    switch (period) {
      case "24h": return 1;
      case "7d": return 7;
      case "30d": return 30;
      case "90d": return 90;
      default: return 7;
    }
  };

  const fetchStoryInsights = useCallback(async () => {
    if (!organization?.id) return;

    try {
      setLoading(true);
      setError(null);

      const days = getPeriodDays(selectedPeriod);
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      // Fetch all snapshots for the period
      // Type assertion needed because story_insights_snapshots is not in generated Supabase types
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { data: snapshots, error: snapshotsError } = await (supabase as any)
        .from("story_insights_snapshots")
        .select("*")
        .eq("organization_id", organization.id)
        .gte("snapshot_at", startDate.toISOString())
        .order("snapshot_at", { ascending: false }) as { 
          data: StoryInsightsSnapshotRow[] | null; 
          error: { message: string } | null 
        };

      if (snapshotsError) {
        throw new Error(snapshotsError.message);
      }

      // Get unique stories (latest snapshot per story)
      const uniqueStories = new Map<string, typeof snapshots[0]>();
      for (const snapshot of snapshots || []) {
        if (!uniqueStories.has(snapshot.instagram_story_id)) {
          uniqueStories.set(snapshot.instagram_story_id, snapshot);
        }
      }

      const latestSnapshots = Array.from(uniqueStories.values());

      // Calculate summary metrics from latest snapshots
      const summary: StoryInsightsSummary = {
        total_stories: latestSnapshots.length,
        total_reach: latestSnapshots.reduce((sum, s) => sum + (s.reach || 0), 0),
        total_views: latestSnapshots.reduce((sum, s) => sum + (s.views || 0), 0),
        total_profile_visits: latestSnapshots.reduce((sum, s) => sum + (s.profile_visits || 0), 0),
        total_interactions: latestSnapshots.reduce((sum, s) => sum + (s.total_interactions || 0), 0),
        total_shares: latestSnapshots.reduce((sum, s) => sum + (s.shares || 0), 0),
        total_replies: latestSnapshots.reduce((sum, s) => sum + (s.replies || 0), 0),
        avg_reach_per_story: latestSnapshots.length > 0 
          ? Math.round(latestSnapshots.reduce((sum, s) => sum + (s.reach || 0), 0) / latestSnapshots.length)
          : 0,
        avg_views_per_story: latestSnapshots.length > 0
          ? Math.round(latestSnapshots.reduce((sum, s) => sum + (s.views || 0), 0) / latestSnapshots.length)
          : 0,
      };

      // Group by date for daily metrics
      const dailyMap = new Map<string, {
        stories: Set<string>;
        reach: number;
        views: number;
        profile_visits: number;
        interactions: number;
      }>();

      for (const snapshot of snapshots || []) {
        const date = new Date(snapshot.snapshot_at).toISOString().split("T")[0];
        if (!dailyMap.has(date)) {
          dailyMap.set(date, {
            stories: new Set(),
            reach: 0,
            views: 0,
            profile_visits: 0,
            interactions: 0,
          });
        }
        const day = dailyMap.get(date)!;
        // Only count metrics from the latest snapshot per story per day
        // Since snapshots are ordered DESC, first occurrence is the latest
        if (!day.stories.has(snapshot.instagram_story_id)) {
          day.stories.add(snapshot.instagram_story_id);
          day.reach += snapshot.reach || 0;
          day.views += snapshot.views || 0;
          day.profile_visits += snapshot.profile_visits || 0;
          day.interactions += snapshot.total_interactions || 0;
        }
      }

      // Fill in missing days with zeros
      const daily_metrics: DailyStoryMetrics[] = [];
      for (let i = days - 1; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split("T")[0];
        const dayData = dailyMap.get(dateStr);
        
        daily_metrics.push({
          date: dateStr,
          stories_count: dayData?.stories.size || 0,
          total_reach: dayData?.reach || 0,
          total_views: dayData?.views || 0,
          total_profile_visits: dayData?.profile_visits || 0,
          total_interactions: dayData?.interactions || 0,
          avg_reach: dayData && dayData.stories.size > 0 
            ? Math.round(dayData.reach / dayData.stories.size) 
            : 0,
        });
      }

      // Group by hour for optimal posting time analysis
      // Use ONLY latest snapshot per story to avoid counting same story multiple times
      const hourMap = new Map<number, { 
        reach: number; 
        views: number; 
        stories: StoryByHour[];
      }>();
      
      for (const snapshot of latestSnapshots) {
        // Calculate story creation time from snapshot_at minus story_age_hours
        const snapshotDate = new Date(snapshot.snapshot_at);
        const storyAgeMs = snapshot.story_age_hours 
          ? snapshot.story_age_hours * 60 * 60 * 1000 
          : 0;
        const storyCreatedAt = new Date(snapshotDate.getTime() - storyAgeMs);
        const hour = storyCreatedAt.getHours();
        
        if (!hourMap.has(hour)) {
          hourMap.set(hour, { reach: 0, views: 0, stories: [] });
        }
        const h = hourMap.get(hour)!;
        h.reach += snapshot.reach || 0;
        h.views += snapshot.views || 0;
        h.stories.push({
          instagram_story_id: snapshot.instagram_story_id,
          reach: snapshot.reach || 0,
          views: snapshot.views || 0,
          created_at: storyCreatedAt,
        });
      }

      // Find max stories in any hour for generating dynamic keys
      let max_stories_per_hour = 0;
      for (const [, hourData] of hourMap) {
        if (hourData.stories.length > max_stories_per_hour) {
          max_stories_per_hour = hourData.stories.length;
        }
      }

      const metrics_by_hour: HourlyMetrics[] = Array.from({ length: 24 }, (_, hour) => {
        const data = hourMap.get(hour) || { reach: 0, views: 0, stories: [] };
        const count = data.stories.length;
        // Sort by creation date (earliest first) so colors represent chronological order
        const sortedStories = data.stories.sort((a, b) => 
          a.created_at.getTime() - b.created_at.getTime()
        );
        
        // Create base metrics
        const metrics: HourlyMetrics = {
          hour,
          avg_reach: count > 0 ? Math.round(data.reach / count) : 0,
          avg_views: count > 0 ? Math.round(data.views / count) : 0,
          stories_count: count,
          stories: sortedStories,
        };
        
        // Add dynamic keys for each story position (for stacked bars)
        for (let i = 0; i < max_stories_per_hour; i++) {
          const story = sortedStories[i];
          metrics[`story_${i}_reach`] = story?.reach || 0;
          metrics[`story_${i}_id`] = story?.instagram_story_id || '';
        }
        
        return metrics;
      });

      // Recent snapshots (top 10) - sorted by story creation date (newest first)
      const recent_snapshots: StorySnapshot[] = latestSnapshots
        .sort((a, b) => {
          // Calculate story creation time for sorting
          const aSnapshotDate = new Date(a.snapshot_at).getTime();
          const bSnapshotDate = new Date(b.snapshot_at).getTime();
          const aCreatedAt = aSnapshotDate - (a.story_age_hours || 0) * 60 * 60 * 1000;
          const bCreatedAt = bSnapshotDate - (b.story_age_hours || 0) * 60 * 60 * 1000;
          return bCreatedAt - aCreatedAt; // Newest first
        })
        .slice(0, 10)
        .map(s => ({
          id: s.id,
          instagram_story_id: s.instagram_story_id,
          snapshot_at: s.snapshot_at,
          story_age_hours: s.story_age_hours,
          reach: s.reach || 0,
          views: s.views || 0,
          profile_visits: s.profile_visits || 0,
          total_interactions: s.total_interactions || 0,
          shares: s.shares || 0,
          replies: s.replies || 0,
          navigation: s.navigation || {},
        }));

      setData({
        summary,
        recent_snapshots,
        daily_metrics,
        metrics_by_hour,
        max_stories_per_hour,
      });

    } catch (err) {
      console.error("Error fetching story insights:", err);
      setError(err instanceof Error ? err.message : "Error al cargar insights de Stories");
      toast.error("Error al cargar analytics de Stories");
    } finally {
      setLoading(false);
    }
  }, [organization?.id, selectedPeriod]);

  useEffect(() => {
    fetchStoryInsights();
  }, [fetchStoryInsights]);

  return {
    data,
    loading,
    error,
    refresh: fetchStoryInsights,
  };
}
</file>

<file path="supabase/functions/shared/auth.ts">
/**
 * Authentication and Authorization Utilities
 * Centralized authentication logic for all edge functions
 */

import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { corsHeaders } from './constants.ts';
import { SupabaseClient } from './types.ts';

export interface AuthResult {
  user: { id: string; [key: string]: unknown };
  supabase: SupabaseClient;
  isCron?: boolean;
}

export interface AuthOptions {
  requireAuth?: boolean;
  allowCron?: boolean;
}

/**
 * Create authenticated Supabase client
 */
export function createSupabaseClient(): SupabaseClient {
  return createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );
}

/**
 * Authenticate request and return user + client
 * Returns Response if authentication fails, AuthResult if successful
 */
export async function authenticateRequest(
  req: Request,
  options: AuthOptions = { requireAuth: true, allowCron: false }
): Promise<AuthResult | Response> {
  const authHeader = req.headers.get('Authorization');
  const cronSecret = req.headers.get('x-cron-secret');
  const supabase = createSupabaseClient();

  // Handle cron requests - check cron secret FIRST (before user auth)
  // This allows cron jobs to include Authorization header for service role access
  if (options.allowCron && cronSecret) {
    const expectedSecret = Deno.env.get('CRON_SECRET');
    if (expectedSecret && cronSecret === expectedSecret) {
      // Return a system user for cron jobs
      return {
        user: { id: 'system', isCron: true },
        supabase,
        isCron: true
      };
    }
  }

  // Require authentication
  if (!authHeader && options.requireAuth) {
    return new Response(
      JSON.stringify({ error: 'Authentication required' }),
      { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  if (authHeader) {
    const { data: { user }, error: authError } = await supabase.auth.getUser(
      authHeader.replace('Bearer ', '')
    );

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Invalid authentication' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    return { user, supabase };
  }

  // No auth required
  return { user: { id: 'anonymous' }, supabase };
}

/**
 * Verify organization ownership
 */
export async function verifyOrganizationAccess(
  supabase: SupabaseClient,
  userId: string,
  organizationId: string
): Promise<boolean> {
  if (userId === 'system') return true; // Cron jobs have full access
  
  const { data: org, error } = await supabase
    .from('organizations')
    .select('id')
    .eq('id', organizationId)
    .eq('created_by', userId)
    .single();

  return !error && !!org;
}

/**
 * Verify organization membership (user is member but not necessarily owner)
 */
export async function verifyOrganizationMembership(
  supabase: SupabaseClient,
  userId: string,
  organizationId: string
): Promise<boolean> {
  const { data: isMember, error } = await supabase
    .rpc('is_organization_member', {
      user_auth_id: userId,
      org_id: organizationId
    });

  return !error && isMember === true;
}

/**
 * Get user's organization via organization_members (more reliable than users.organization_id)
 */
export async function getUserOrganization(
  supabase: SupabaseClient,
  userId: string
): Promise<string | null> {
  // Use get_user_organizations RPC which queries organization_members
  const { data: userOrgs, error } = await supabase
    .rpc('get_user_organizations', { user_auth_id: userId });

  if (error || !userOrgs || userOrgs.length === 0) {
    // Fallback to users.organization_id for backwards compatibility
    const { data: userData } = await supabase
      .from('users')
      .select('organization_id')
      .eq('auth_user_id', userId)
      .single();
    
    return userData?.organization_id ?? null;
  }

  return userOrgs[0].organization_id;
}

/**
 * Get organization with Instagram credentials
 */
export async function getOrganizationWithCredentials(
  supabase: SupabaseClient,
  organizationId: string
) {
  const { data: org, error } = await supabase
    .from('organizations')
    .select('id, name, instagram_business_account_id, instagram_username')
    .eq('id', organizationId)
    .single();

  if (error || !org) {
    throw new Error('Organization not found');
  }

  // Get encrypted token from secure table
  const { data: tokenData, error: tokenError } = await supabase
    .from('organization_instagram_tokens')
    .select('access_token, token_expiry')
    .eq('organization_id', organizationId)
    .single();

  if (tokenError || !tokenData) {
    throw new Error('No Instagram token found for organization');
  }

  return {
    ...org,
    access_token: tokenData.access_token,
    token_expiry: tokenData.token_expiry
  };
}
</file>

<file path="src/components/Analytics/StoryInsightsDashboard.tsx">
import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { PageHeader } from "@/components/Layout/PageHeader";
import { GlassPanel } from "@/components/Layout/GlassPanel";
import { HelpCircle } from "lucide-react";
import {
  Eye,
  Users,
  Share2,
  MessageCircle,
  TrendingUp,
  Clock,
  Instagram,
  RefreshCw,
  BarChart3,
  Activity,
  Target,
  Sparkles,
} from "lucide-react";
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip as RechartsTooltip,
  ResponsiveContainer,
  AreaChart,
  Area,
  ReferenceLine,
  Cell,
  Rectangle,
} from "recharts";
import { useStoryInsightsAnalytics } from "@/hooks/useStoryInsightsAnalytics";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

export function StoryInsightsDashboard() {
  const [selectedPeriod, setSelectedPeriod] = useState("7d");
  const { data, loading, error, refresh } = useStoryInsightsAnalytics(selectedPeriod);
  const [isCollecting, setIsCollecting] = useState(false);

  const handleCollectInsights = async () => {
    setIsCollecting(true);
    try {
      const { data: result, error } = await supabase.functions.invoke("collect-story-insights");
      
      if (error) throw error;
      
      toast.success(`Insights recolectados: ${result.totalSnapshotsCreated || 0} snapshots creados`);
      refresh();
    } catch (err) {
      console.error("Error collecting insights:", err);
      toast.error("Error al recolectar insights de Stories");
    } finally {
      setIsCollecting(false);
    }
  };

  const formatNumber = (num: number) => {
    if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
    if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
    return num.toLocaleString();
  };

  if (loading) {
    return (
      <div className="space-y-6">
        <PageHeader
          title="Story Insights"
          description="An√°lisis de rendimiento de Instagram Stories"
        />
        <div className="animate-pulse space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            {[...Array(4)].map((_, i) => (
              <GlassPanel key={i} className="h-28">
                <div className="animate-pulse bg-muted rounded h-full"></div>
              </GlassPanel>
            ))}
          </div>
        </div>
      </div>
    );
  }

  if (error || !data) {
    return (
      <div className="space-y-6">
        <PageHeader
          title="Story Insights"
          description="An√°lisis de rendimiento de Instagram Stories"
        />
        <GlassPanel>
          <div className="text-center text-muted-foreground py-12">
            <Instagram className="h-12 w-12 mx-auto mb-4 opacity-50" />
            <p className="text-lg font-medium mb-2">No hay datos de Stories disponibles</p>
            <p className="text-sm mb-4">Recolecta insights de tus Stories activas para ver m√©tricas</p>
            <Button onClick={handleCollectInsights} disabled={isCollecting}>
              <RefreshCw className={`w-4 h-4 mr-2 ${isCollecting ? "animate-spin" : ""}`} />
              {isCollecting ? "Recolectando..." : "Recolectar Insights"}
            </Button>
          </div>
        </GlassPanel>
      </div>
    );
  }

  const { summary, daily_metrics, metrics_by_hour, recent_snapshots, max_stories_per_hour } = data;
  
  // Color palette for stacked story bars
  const storyColors = [
    "#8b5cf6", // Purple
    "#10b981", // Green
    "#f59e0b", // Amber
    "#ef4444", // Red
    "#3b82f6", // Blue
    "#ec4899", // Pink
    "#14b8a6", // Teal
    "#f97316", // Orange
  ];

  return (
    <div className="space-y-6">
      <PageHeader
        title="Story Insights"
        description="An√°lisis de rendimiento de Instagram Stories"
      >
        <div className="w-full flex justify-center">
          <div className="flex items-center space-x-3 flex-wrap gap-2">
            <Select value={selectedPeriod} onValueChange={setSelectedPeriod}>
              <SelectTrigger className="w-36">
                <SelectValue placeholder="Per√≠odo" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="24h">24 horas</SelectItem>
                <SelectItem value="7d">7 d√≠as</SelectItem>
                <SelectItem value="30d">30 d√≠as</SelectItem>
                <SelectItem value="90d">3 meses</SelectItem>
              </SelectContent>
            </Select>

            <Button
              variant="outline"
              size="sm"
              onClick={handleCollectInsights}
              disabled={isCollecting}
            >
              <RefreshCw className={`w-4 h-4 mr-2 ${isCollecting ? "animate-spin" : ""}`} />
              {isCollecting ? "Recolectando..." : "Actualizar"}
            </Button>
          </div>
        </div>
      </PageHeader>

      <div className="max-w-7xl mx-auto space-y-6">
        {/* Key Metrics */}
        <div className="space-y-3">
          <div className="flex items-center gap-2">
            <Badge variant="outline" className="bg-gradient-to-r from-pink-500/10 to-purple-500/10 text-pink-700 border-pink-200">
              <Instagram className="w-3 h-3 mr-1" />
              Instagram Stories API v24.0
            </Badge>
          </div>

          <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-7 gap-4">
            <Card className="bg-gradient-to-br from-violet-500/10 to-purple-500/10 border-violet-200/50">
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-xs text-muted-foreground uppercase tracking-wide">Stories</p>
                    <p className="text-2xl font-bold text-violet-700">{summary.total_stories}</p>
                  </div>
                  <BarChart3 className="w-8 h-8 text-violet-500/50" />
                </div>
              </CardContent>
            </Card>

            <Card className="bg-gradient-to-br from-blue-500/10 to-cyan-500/10 border-blue-200/50">
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <TooltipProvider>
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <div className="flex items-center gap-1 cursor-help">
                            <p className="text-xs text-muted-foreground uppercase tracking-wide">Alcance</p>
                            <HelpCircle className="w-3 h-3 text-muted-foreground/50" />
                          </div>
                        </TooltipTrigger>
                        <TooltipContent side="bottom" className="max-w-xs">
                          <p className="font-medium">Alcance (Reach)</p>
                          <p className="text-sm text-muted-foreground mt-1">
                            N√∫mero de <strong>cuentas √∫nicas</strong> que vieron tu Story. Cada persona se cuenta una sola vez, sin importar cu√°ntas veces la vio.
                          </p>
                        </TooltipContent>
                      </Tooltip>
                    </TooltipProvider>
                    <p className="text-2xl font-bold text-blue-700">{formatNumber(summary.total_reach)}</p>
                  </div>
                  <Eye className="w-8 h-8 text-blue-500/50" />
                </div>
              </CardContent>
            </Card>

            <Card className="bg-gradient-to-br from-emerald-500/10 to-teal-500/10 border-emerald-200/50">
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <TooltipProvider>
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <div className="flex items-center gap-1 cursor-help">
                            <p className="text-xs text-muted-foreground uppercase tracking-wide">Vistas</p>
                            <HelpCircle className="w-3 h-3 text-muted-foreground/50" />
                          </div>
                        </TooltipTrigger>
                        <TooltipContent side="bottom" className="max-w-xs">
                          <p className="font-medium">Vistas (Views)</p>
                          <p className="text-sm text-muted-foreground mt-1">
                            <strong>Total de reproducciones</strong> de tu Story. Incluye vistas repetidas de la misma persona. Si alguien ve tu Story 3 veces, cuenta como 3 vistas.
                          </p>
                        </TooltipContent>
                      </Tooltip>
                    </TooltipProvider>
                    <p className="text-2xl font-bold text-emerald-700">{formatNumber(summary.total_views)}</p>
                  </div>
                  <Activity className="w-8 h-8 text-emerald-500/50" />
                </div>
              </CardContent>
            </Card>

            <Card className="bg-gradient-to-br from-orange-500/10 to-amber-500/10 border-orange-200/50">
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-xs text-muted-foreground uppercase tracking-wide">Visitas Perfil</p>
                    <p className="text-2xl font-bold text-orange-700">{formatNumber(summary.total_profile_visits)}</p>
                  </div>
                  <Users className="w-8 h-8 text-orange-500/50" />
                </div>
              </CardContent>
            </Card>

            <Card className="bg-gradient-to-br from-pink-500/10 to-rose-500/10 border-pink-200/50">
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-xs text-muted-foreground uppercase tracking-wide">Interacciones</p>
                    <p className="text-2xl font-bold text-pink-700">{formatNumber(summary.total_interactions)}</p>
                  </div>
                  <Sparkles className="w-8 h-8 text-pink-500/50" />
                </div>
              </CardContent>
            </Card>

            <Card className="bg-gradient-to-br from-indigo-500/10 to-blue-500/10 border-indigo-200/50">
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-xs text-muted-foreground uppercase tracking-wide">Compartidos</p>
                    <p className="text-2xl font-bold text-indigo-700">{formatNumber(summary.total_shares)}</p>
                  </div>
                  <Share2 className="w-8 h-8 text-indigo-500/50" />
                </div>
              </CardContent>
            </Card>

            <Card className="bg-gradient-to-br from-cyan-500/10 to-sky-500/10 border-cyan-200/50">
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-xs text-muted-foreground uppercase tracking-wide">Respuestas</p>
                    <p className="text-2xl font-bold text-cyan-700">{formatNumber(summary.total_replies)}</p>
                  </div>
                  <MessageCircle className="w-8 h-8 text-cyan-500/50" />
                </div>
              </CardContent>
            </Card>
          </div>
        </div>

        {/* Averages Row */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <Card>
            <CardContent className="p-6">
              <div className="flex items-center gap-4">
                <div className="p-3 rounded-full bg-violet-100">
                  <Target className="w-6 h-6 text-violet-600" />
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Alcance promedio por Story</p>
                  <p className="text-3xl font-bold">{formatNumber(summary.avg_reach_per_story)}</p>
                </div>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-6">
              <div className="flex items-center gap-4">
                <div className="p-3 rounded-full bg-emerald-100">
                  <TrendingUp className="w-6 h-6 text-emerald-600" />
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Vistas promedio por Story</p>
                  <p className="text-3xl font-bold">{formatNumber(summary.avg_views_per_story)}</p>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>

        <Tabs defaultValue="trends" className="space-y-6">
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="trends">Tendencias</TabsTrigger>
            <TabsTrigger value="timing">Mejor Horario</TabsTrigger>
            <TabsTrigger value="stories">Stories Recientes</TabsTrigger>
          </TabsList>

          <TabsContent value="trends" className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <TrendingUp className="w-5 h-5 text-primary" />
                  Evoluci√≥n de M√©tricas
                </CardTitle>
                <CardDescription>
                  Alcance, vistas y visitas al perfil por d√≠a
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="h-80">
                  <ResponsiveContainer width="100%" height="100%">
                    <AreaChart data={daily_metrics}>
                      <defs>
                        <linearGradient id="reachGradient" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="5%" stopColor="#8b5cf6" stopOpacity={0.3} />
                          <stop offset="95%" stopColor="#8b5cf6" stopOpacity={0} />
                        </linearGradient>
                        <linearGradient id="viewsGradient" x1="0" y1="0" x2="0" y2="1">
                          <stop offset="5%" stopColor="#10b981" stopOpacity={0.3} />
                          <stop offset="95%" stopColor="#10b981" stopOpacity={0} />
                        </linearGradient>
                      </defs>
                      <CartesianGrid strokeDasharray="3 3" className="stroke-muted" />
                      <XAxis
                        dataKey="date"
                        tickFormatter={(date) => {
                          const d = new Date(date);
                          return `${d.getDate()}/${d.getMonth() + 1}`;
                        }}
                        className="text-xs"
                      />
                      <YAxis className="text-xs" />
                      <RechartsTooltip
                        labelFormatter={(date) => new Date(date).toLocaleDateString("es-ES", {
                          weekday: "short",
                          day: "numeric",
                          month: "short",
                        })}
                        formatter={(value: number, name: string) => [
                          formatNumber(value),
                          name === "total_reach" ? "Alcance" :
                          name === "total_views" ? "Vistas" :
                          name === "total_profile_visits" ? "Visitas Perfil" : name,
                        ]}
                      />
                      <Area
                        type="monotone"
                        dataKey="total_reach"
                        stroke="#8b5cf6"
                        strokeWidth={2}
                        fill="url(#reachGradient)"
                        name="Alcance"
                      />
                      <Area
                        type="monotone"
                        dataKey="total_views"
                        stroke="#10b981"
                        strokeWidth={2}
                        fill="url(#viewsGradient)"
                        name="Vistas"
                      />
                      <Line
                        type="monotone"
                        dataKey="total_profile_visits"
                        stroke="#f59e0b"
                        strokeWidth={2}
                        dot={false}
                        name="Visitas Perfil"
                      />
                    </AreaChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <BarChart3 className="w-5 h-5 text-primary" />
                  Stories por D√≠a
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="h-64">
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart data={daily_metrics}>
                      <CartesianGrid strokeDasharray="3 3" className="stroke-muted" />
                      <XAxis
                        dataKey="date"
                        tickFormatter={(date) => {
                          const d = new Date(date);
                          return `${d.getDate()}/${d.getMonth() + 1}`;
                        }}
                        className="text-xs"
                      />
                      <YAxis className="text-xs" />
                      <RechartsTooltip
                        labelFormatter={(date) => new Date(date).toLocaleDateString("es-ES")}
                        formatter={(value: number) => [value, "Stories"]}
                      />
                      <Bar
                        dataKey="stories_count"
                        fill="#8b5cf6"
                        radius={[4, 4, 0, 0]}
                        name="Stories"
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="timing" className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Clock className="w-5 h-5 text-primary" />
                  Rendimiento por Hora
                </CardTitle>
                <CardDescription>
                  Cada segmento de color representa una story individual, ordenadas cronol√≥gicamente (m√°s antigua a m√°s reciente). La l√≠nea punteada muestra el alcance promedio por hora.
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="h-80">
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart data={metrics_by_hour}>
                      <defs>
                        <pattern id="avgPattern" patternUnits="userSpaceOnUse" width="4" height="4">
                          <path d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" stroke="#666" strokeWidth="0.5" />
                        </pattern>
                      </defs>
                      <CartesianGrid strokeDasharray="3 3" className="stroke-muted" />
                      <XAxis
                        dataKey="hour"
                        tickFormatter={(hour) => `${hour}:00`}
                        className="text-xs"
                      />
                      <YAxis className="text-xs" />
                      <RechartsTooltip
                        content={({ active, payload, label }) => {
                          if (!active || !payload?.length) return null;
                          const hourData = metrics_by_hour.find(h => h.hour === label);
                          if (!hourData) return null;
                          
                          return (
                            <div className="bg-popover border rounded-lg p-3 shadow-lg min-w-[200px]">
                              <p className="font-medium mb-2">{label}:00 - {label}:59</p>
                              <div className="space-y-1 text-sm border-b pb-2 mb-2">
                                <p className="flex justify-between">
                                  <span className="text-muted-foreground">Promedio:</span>
                                  <span className="font-medium">{formatNumber(hourData.avg_reach)} alcance</span>
                                </p>
                                <p className="flex justify-between">
                                  <span className="text-muted-foreground">Stories:</span>
                                  <span className="font-medium">{hourData.stories_count}</span>
                                </p>
                              </div>
                              {hourData.stories.length > 0 && (
                                <div className="space-y-2">
                                  {hourData.stories.map((story, idx) => (
                                    <div 
                                      key={story.instagram_story_id} 
                                      className="flex items-center gap-2 text-xs"
                                    >
                                      <div 
                                        className="w-3 h-3 rounded-sm flex-shrink-0" 
                                        style={{ backgroundColor: storyColors[idx % storyColors.length] }}
                                      />
                                      <div className="flex-1 min-w-0">
                                        <div className="flex items-center gap-2">
                                          <span className="text-muted-foreground">
                                            #{story.instagram_story_id?.slice(-8) || "N/A"}
                                          </span>
                                          <span className="text-muted-foreground text-[10px]">
                                            {new Date(story.created_at).toLocaleTimeString("es-ES", { 
                                              hour: "2-digit", 
                                              minute: "2-digit" 
                                            })}
                                          </span>
                                        </div>
                                      </div>
                                      <span className="ml-auto font-medium">
                                        {formatNumber(story.reach)}
                                      </span>
                                    </div>
                                  ))}
                                </div>
                              )}
                            </div>
                          );
                        }}
                      />
                      {/* Stacked bars for each story position */}
                      {Array.from({ length: max_stories_per_hour }, (_, i) => {
                        // Custom shape that applies rounded corners to the last non-zero bar in each stack
                        const CustomBarShape = (props: {
                          payload?: Record<string, unknown>;
                          [key: string]: unknown;
                        }) => {
                          const { payload, ...barProps } = props;
                          // Find the last non-zero story index for this hour
                          let lastNonZeroIndex = -1;
                          for (let j = max_stories_per_hour - 1; j >= 0; j--) {
                            const value = payload?.[`story_${j}_reach`];
                            if (typeof value === 'number' && value > 0) {
                              lastNonZeroIndex = j;
                              break;
                            }
                          }
                          // Apply rounded corners only to the last non-zero bar
                          const radius: [number, number, number, number] = i === lastNonZeroIndex 
                            ? [4, 4, 0, 0] 
                            : [0, 0, 0, 0];
                          return <Rectangle {...barProps} radius={radius} />;
                        };
                        
                        return (
                          <Bar
                            key={`story_${i}`}
                            dataKey={`story_${i}_reach`}
                            stackId="stories"
                            fill={storyColors[i % storyColors.length]}
                            shape={CustomBarShape}
                            name={`Story ${i + 1}`}
                          />
                        );
                      })}
                      {/* Reference line for average - shown as dashed line at avg_reach level */}
                      <ReferenceLine 
                        y={Math.round(metrics_by_hour.filter(h => h.avg_reach > 0).reduce((sum, h) => sum + h.avg_reach, 0) / Math.max(1, metrics_by_hour.filter(h => h.avg_reach > 0).length))} 
                        stroke="#666" 
                        strokeDasharray="5 5" 
                        label={{ value: "Promedio global", position: "insideTopRight", fontSize: 10, fill: "#666" }}
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </div>

                {/* Legend */}
                <div className="mt-4 flex flex-wrap gap-3 justify-center text-xs">
                  <span className="text-muted-foreground text-[10px] w-full text-center mb-1">
                    Colores ordenados cronol√≥gicamente (m√°s antigua ‚Üí m√°s reciente)
                  </span>
                  {Array.from({ length: Math.min(max_stories_per_hour, 8) }, (_, i) => (
                    <div key={i} className="flex items-center gap-1.5">
                      <div 
                        className="w-3 h-3 rounded-sm" 
                        style={{ backgroundColor: storyColors[i % storyColors.length] }}
                      />
                      <span className="text-muted-foreground">
                        {i === 0 ? "1¬™ story" : i === 1 ? "2¬™ story" : i === 2 ? "3¬™ story" : `${i + 1}¬™ story`}
                      </span>
                    </div>
                  ))}
                  <div className="flex items-center gap-1.5">
                    <div className="w-6 border-t-2 border-dashed border-gray-500" />
                    <span className="text-muted-foreground">Promedio global</span>
                  </div>
                </div>

                {/* Best hours summary */}
                <div className="mt-6 p-4 rounded-lg bg-muted/50">
                  <h4 className="font-medium mb-2">üìä Mejores Horarios</h4>
                  <div className="flex flex-wrap gap-2">
                    {metrics_by_hour
                      .filter(h => h.avg_reach > 0)
                      .sort((a, b) => b.avg_reach - a.avg_reach)
                      .slice(0, 5)
                      .map((h, i) => (
                        <Badge key={h.hour} variant={i === 0 ? "default" : "outline"}>
                          {h.hour}:00 - {formatNumber(h.avg_reach)} alcance ({h.stories_count} {h.stories_count === 1 ? 'story' : 'stories'})
                        </Badge>
                      ))}
                  </div>
                </div>

                {/* Hours with multiple stories */}
                {metrics_by_hour.filter(h => h.stories_count > 1).length > 0 && (
                  <div className="mt-4 p-4 rounded-lg bg-amber-500/10 border border-amber-500/20">
                    <h4 className="font-medium mb-2 text-amber-600">üìå Horas con m√∫ltiples Stories</h4>
                    <div className="space-y-3">
                      {metrics_by_hour
                        .filter(h => h.stories_count > 1)
                        .sort((a, b) => b.stories_count - a.stories_count)
                        .map(h => (
                          <div key={h.hour} className="text-sm">
                            <p className="font-medium">{h.hour}:00 - {h.stories_count} stories</p>
                            <div className="ml-4 mt-1 space-y-1">
                              {h.stories.map((story, idx) => (
                                <div key={story.instagram_story_id} className="flex items-center gap-2 text-muted-foreground text-xs">
                                  <div 
                                    className="w-2 h-2 rounded-sm" 
                                    style={{ backgroundColor: storyColors[idx % storyColors.length] }}
                                  />
                                  <span>#{story.instagram_story_id?.slice(-8) || "N/A"}</span>
                                  <span className="ml-auto">{formatNumber(story.reach)} alcance / {formatNumber(story.views)} vistas</span>
                                </div>
                              ))}
                            </div>
                          </div>
                        ))}
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="stories" className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Instagram className="w-5 h-5 text-primary" />
                  Stories Recientes
                </CardTitle>
                <CardDescription>
                  √öltimos snapshots de insights recolectados
                </CardDescription>
              </CardHeader>
              <CardContent>
                {recent_snapshots.length === 0 ? (
                  <div className="text-center py-8 text-muted-foreground">
                    <Instagram className="w-12 h-12 mx-auto mb-2 opacity-50" />
                    <p>No hay snapshots recientes</p>
                  </div>
                ) : (
                  <div className="space-y-3">
                    {recent_snapshots.map((snapshot) => {
                      // Calculate story creation date from snapshot_at minus story_age_hours
                      const snapshotDate = new Date(snapshot.snapshot_at);
                      const storyCreatedAt = snapshot.story_age_hours
                        ? new Date(snapshotDate.getTime() - snapshot.story_age_hours * 60 * 60 * 1000)
                        : snapshotDate;
                      
                      return (
                        <div
                          key={snapshot.id}
                          className="flex items-center justify-between p-4 rounded-lg border bg-card hover:bg-accent/50 transition-colors"
                        >
                          <div className="flex items-center gap-4">
                            <div className="p-2 rounded-full bg-gradient-to-br from-pink-500 to-purple-500">
                              <Instagram className="w-4 h-4 text-white" />
                            </div>
                            <div>
                              <p className="font-medium text-sm">
                                Story #{snapshot.instagram_story_id?.slice(-8) || 'N/A'}
                              </p>
                              <p className="text-xs text-muted-foreground">
                                üìÖ {storyCreatedAt.toLocaleDateString("es-ES", {
                                  weekday: "short",
                                  day: "numeric",
                                  month: "short",
                                  hour: "2-digit",
                                  minute: "2-digit",
                                })}
                              </p>
                              {snapshot.story_age_hours && (
                                <p className="text-xs text-muted-foreground/70">
                                  ‚è±Ô∏è Snapshot tomado a las {snapshot.story_age_hours.toFixed(1)}h
                                </p>
                              )}
                            </div>
                          </div>
                          <div className="flex items-center gap-6 text-sm">
                            <div className="text-center">
                              <p className="font-bold">{formatNumber(snapshot.reach)}</p>
                              <p className="text-xs text-muted-foreground">Alcance</p>
                            </div>
                            <div className="text-center">
                              <p className="font-bold">{formatNumber(snapshot.views)}</p>
                              <p className="text-xs text-muted-foreground">Vistas</p>
                            </div>
                            <div className="text-center">
                              <p className="font-bold">{snapshot.profile_visits}</p>
                              <p className="text-xs text-muted-foreground">Perfil</p>
                            </div>
                            <div className="text-center">
                              <p className="font-bold">{snapshot.shares}</p>
                              <p className="text-xs text-muted-foreground">Shares</p>
                            </div>
                            <div className="text-center">
                              <p className="font-bold">{snapshot.replies}</p>
                              <p className="text-xs text-muted-foreground">Replies</p>
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
}
</file>

<file path="supabase/functions/collect-story-insights/index.ts">
/**
 * Collect Story Insights Function
 * 
 * This function fetches insights for active Instagram Stories (<24h old)
 * using the Instagram Graph API and stores snapshots in Supabase.
 * 
 * Flow:
 * 1. GET /{instagram_business_account_id}/stories - Get all active story IDs
 * 2. GET /{story_id}/insights?metric=... - Get insights for each story
 * 3. Store snapshots in story_insights_snapshots table
 * 
 * Designed to be called by a cron job every 2 hours.
 */

import { corsHeaders, STORY_INSIGHTS_METRICS } from '../shared/constants.ts';
import { Organization, SupabaseClient, StoryInsights } from '../shared/types.ts';
import { corsPreflightResponse, jsonResponse, errorResponse } from '../shared/responses.ts';
import { authenticateRequest, getUserOrganization } from '../shared/auth.ts';
import { handleError } from '../shared/error-handler.ts';
import { safeDecryptToken } from '../shared/crypto.ts';
import { fetchAccountStories, fetchStoryInsights, StoryItem } from '../shared/instagram-api.ts';

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return corsPreflightResponse();
  }

  try {
    // Authenticate request (allows both cron and user requests)
    const authResult = await authenticateRequest(req, { requireAuth: false, allowCron: true });
    if (authResult instanceof Response) return authResult;
    
    const { user, supabase, isCron } = authResult;
    
    let targetOrgId: string | null = null;

    if (isCron) {
      console.log('Starting Story insights collection... (CRON JOB)');
      // Parse optional target organization
      try {
        const body = await req.json();
        targetOrgId = body?.organization_id ?? null;
      } catch (_) {
        // No body provided
      }
    } else {
      console.log('Starting Story insights collection... (USER REQUEST)');
      // Get user's organization
      targetOrgId = await getUserOrganization(supabase, user.id);
    }

    // Get organizations with Instagram connections
    let organizationsQuery = supabase
      .from('organizations')
      .select('id, name, instagram_business_account_id')
      .not('instagram_business_account_id', 'is', null);

    if (targetOrgId) {
      organizationsQuery = organizationsQuery.eq('id', targetOrgId);
    }

    const { data: organizations, error: orgsError } = await organizationsQuery;

    if (orgsError) {
      console.error('Error fetching organizations:', orgsError);
      throw new Error('Failed to fetch organizations');
    }

    console.log(`Found ${organizations?.length || 0} organization(s) to process`);

    interface OrgResult {
      organization_id: string;
      organization_name: string;
      success: boolean;
      storiesFound?: number;
      snapshotsCreated?: number;
      errors?: string[];
      error?: string;
    }

    const results: OrgResult[] = [];
    let totalStoriesFound = 0;
    let totalSnapshotsCreated = 0;

    for (const org of organizations || []) {
      try {
        console.log(`Processing organization: ${org.name} (${org.id})`);

        // Get Instagram token
        const { data: tokenData, error: tokenError } = await supabase
          .from('organization_instagram_tokens')
          .select('access_token, token_expiry')
          .eq('organization_id', org.id)
          .single();

        if (tokenError || !tokenData) {
          console.log(`No Instagram token found for organization ${org.name}`);
          results.push({
            organization_id: org.id,
            organization_name: org.name,
            success: false,
            error: 'No Instagram token found'
          });
          continue;
        }

        // Check token expiry
        if (tokenData.token_expiry && new Date(tokenData.token_expiry) < new Date()) {
          console.log(`Token expired for organization ${org.name}`);
          
          await supabase
            .from('notifications')
            .insert({
              organization_id: org.id,
              type: 'token_expired',
              message: 'Tu token de Instagram ha expirado. Reconecta tu cuenta para continuar recolectando insights de Stories.',
              priority: 'high'
            });
          
          results.push({
            organization_id: org.id,
            organization_name: org.name,
            success: false,
            error: 'Token expired'
          });
          continue;
        }

        const decryptedToken = await safeDecryptToken(tokenData.access_token);
        
        // Collect insights for this organization
        const orgResult = await collectOrganizationStoryInsights(
          supabase,
          org,
          decryptedToken
        );

        totalStoriesFound += orgResult.storiesFound;
        totalSnapshotsCreated += orgResult.snapshotsCreated;

        results.push({
          organization_id: org.id,
          organization_name: org.name,
          success: true,
          ...orgResult
        });

      } catch (error) {
        console.error(`Error processing organization ${org.name}:`, error);
        results.push({
          organization_id: org.id,
          organization_name: org.name,
          success: false,
          error: error.message
        });
      }
    }

    console.log(
      `Story insights collection completed: ` +
      `${totalStoriesFound} stories found, ` +
      `${totalSnapshotsCreated} snapshots created`
    );

    return jsonResponse({
      success: true,
      results,
      totalStoriesFound,
      totalSnapshotsCreated,
      isCron,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    return handleError(error);
  }
});

/**
 * Collect Story insights for a specific organization
 */
async function collectOrganizationStoryInsights(
  supabase: SupabaseClient,
  organization: Organization,
  accessToken: string
): Promise<{ storiesFound: number; snapshotsCreated: number; errors: string[] }> {
  
  let storiesFound = 0;
  let snapshotsCreated = 0;
  const errors: string[] = [];
  const now = new Date();

  try {
    // Step 1: Fetch active stories using the /stories endpoint
    // This returns only stories that are currently active (<24h old)
    const stories = await fetchAccountStories(
      organization.instagram_business_account_id!,
      accessToken,
      { fields: 'id,timestamp,media_type' }
    );

    storiesFound = stories.length;
    console.log(`Found ${storiesFound} active stories for ${organization.name}`);

    if (storiesFound === 0) {
      return { storiesFound, snapshotsCreated, errors };
    }

    // Step 2: For each story, fetch insights and store snapshot
    for (const story of stories) {
      try {
        const storyId = story.id;
        
        if (!storyId) {
          console.log('Skipping story without ID');
          continue;
        }

        // Calculate story age for metadata
        const storyAge = story.timestamp ? calculateStoryAgeHours(story.timestamp) : null;

        console.log(`Fetching insights for story ${storyId} (age: ${storyAge?.toFixed(1) || 'unknown'}h)`);

        // Step 2a: Fetch insights from Instagram API
        // GET /{story_id}/insights?metric=impressions,reach,replies,...
        const insights = await fetchStoryInsights(storyId, accessToken);

        if (!insights) {
          console.log(`No insights available for story ${storyId}`);
          continue;
        }

        console.log(`Story ${storyId} insights:`, JSON.stringify(insights));

        // Step 2b: Try to find matching social_mention record
        const { data: existingMention } = await supabase
          .from('social_mentions')
          .select('id')
          .eq('organization_id', organization.id)
          .eq('instagram_story_id', storyId)
          .single();

        // Step 2c: Store snapshot in database
        // Parse navigation breakdown if available
        const navBreakdown = typeof insights.navigation === 'object' ? insights.navigation : null;
        
        const snapshot = {
          social_mention_id: existingMention?.id || null,
          organization_id: organization.id,
          instagram_story_id: storyId,
          instagram_media_id: storyId, // Story ID is also the media ID
          snapshot_at: now.toISOString(),
          story_age_hours: storyAge,
          // Core metrics
          reach: insights.reach || 0,
          replies: insights.replies || 0,
          shares: insights.shares || 0,
          // New engagement metrics
          profile_visits: insights.profile_visits || 0,
          total_interactions: insights.total_interactions || 0,
          views: insights.views || 0,
          // Navigation breakdown
          exits: navBreakdown?.tap_exit ?? insights.exits ?? 0,
          taps_forward: navBreakdown 
            ? ((navBreakdown.tap_forward ?? 0) + (navBreakdown.swipe_forward ?? 0))
            : (insights.taps_forward ?? 0),
          taps_back: navBreakdown?.tap_back ?? insights.taps_back ?? 0,
          navigation: insights.navigation ?? {},
          // Legacy (deprecated)
          impressions: insights.impressions ?? 0,
          raw_insights: insights
        };

        const { error: insertError } = await supabase
          .from('story_insights_snapshots')
          .insert(snapshot);

        if (insertError) {
          console.error(`Error inserting snapshot for story ${storyId}:`, insertError);
          errors.push(`Failed to insert snapshot for ${storyId}: ${insertError.message}`);
        } else {
          snapshotsCreated++;
          console.log(`Created snapshot for story ${storyId}`);
        }

      } catch (error) {
        console.error(`Error processing story ${story.id}:`, error);
        errors.push(`Story ${story.id} error: ${error.message}`);
      }
    }

  } catch (error) {
    console.error(`Error in collectOrganizationStoryInsights:`, error);
    errors.push(`Organization processing error: ${error.message}`);
  }

  return { storiesFound, snapshotsCreated, errors };
}

/**
 * Calculate story age in hours
 */
function calculateStoryAgeHours(timestamp: string): number {
  const now = new Date().getTime();
  const storyTime = new Date(timestamp).getTime();
  const ageMs = now - storyTime;
  return Math.round((ageMs / (1000 * 60 * 60)) * 100) / 100; // Round to 2 decimals
}
</file>

<file path="src/components/Settings/EnhancedInstagramSettings.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { 
  Instagram, 
  AlertCircle, 
  CheckCircle, 
  RefreshCw, 
  Eye,
  AlertTriangle,
  Info,
  ExternalLink,
  Shield,
  Search,
  ChevronDown,
  ChevronUp
} from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";
import { useInstagramConnection } from "@/hooks/useInstagramConnection";
import { useInstagramSync } from "@/hooks/useInstagramSync";
import { useCurrentOrganization } from "@/hooks/useCurrentOrganization";
import { supabase } from "@/integrations/supabase/client";

interface PageDiagnostic {
  id: string;
  name: string;
  instagram_business_account: {
    id: string;
    username?: string;
    followers_count?: number;
  } | null;
}

interface DiagnosticResult {
  total_pages: number;
  pages_with_instagram: number;
  pages_without_instagram: number;
  pages: PageDiagnostic[];
}

export function EnhancedInstagramSettings() {
  const { organization, loading: orgLoading, refreshOrganization } = useCurrentOrganization();
  const { isConnected, isTokenExpired, isConnecting, connectInstagram, disconnectInstagram, refreshTokenStatus } = useInstagramConnection();
  const { isSyncing, syncInstagramData, refreshToken } = useInstagramSync();
  
  const [isDiagnosing, setIsDiagnosing] = useState(false);
  const [diagnosticResult, setDiagnosticResult] = useState<DiagnosticResult | null>(null);
  const [showDiagnostics, setShowDiagnostics] = useState(false);

  const runAccountDiagnostic = async () => {
    setIsDiagnosing(true);
    setDiagnosticResult(null);
    try {
      const { data, error } = await supabase.functions.invoke('meta-oauth?action=diagnose');
      
      if (error) {
        toast.error('Error al ejecutar diagn√≥stico', { description: error.message });
        return;
      }
      
      if (data?.success && data?.data) {
        setDiagnosticResult(data.data);
        if (data.data.pages_with_instagram === 0) {
          toast.warning('No se encontraron cuentas de Instagram vinculadas');
        } else {
          toast.success(`Se encontraron ${data.data.pages_with_instagram} cuenta(s) de Instagram`);
        }
      } else {
        toast.error(data?.error_description || 'Error desconocido');
      }
    } catch (err) {
      toast.error('Error de conexi√≥n');
    } finally {
      setIsDiagnosing(false);
    }
  };

  const handleRefreshAll = async () => {
    await refreshTokenStatus();
    await refreshOrganization();
    toast.success('Estado actualizado');
  };

  // Safe data access with null checks
  const instagramUsername = organization?.instagram_username || null;
  const lastSync = organization?.last_instagram_sync || null;
  const businessAccountId = organization?.instagram_business_account_id || null;

  const getStatusInfo = () => {
    if (!isConnected) {
      return {
        status: 'Desconectado',
        variant: 'destructive' as const,
        icon: <AlertCircle className="h-4 w-4" />,
        description: 'Instagram no est√° conectado a tu organizaci√≥n'
      };
    }
    
    if (isTokenExpired) {
      return {
        status: 'Token Expirado',
        variant: 'destructive' as const,
        icon: <AlertCircle className="h-4 w-4" />,
        description: 'El token de acceso ha expirado y necesita ser renovado'
      };
    }
    
    return {
      status: 'Conectado',
      variant: 'default' as const,
      icon: <CheckCircle className="h-4 w-4" />,
      description: 'Instagram est√° conectado y funcionando correctamente'
    };
  };

  const statusInfo = getStatusInfo();

  return (
    <div className="space-y-6">
      {/* Main Connection Card */}
      <Card className="border-pink-200 bg-gradient-to-br from-pink-50/30 to-purple-50/30">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Instagram className="h-5 w-5 text-pink-600" />
            Conexi√≥n de Instagram
          </CardTitle>
          <CardDescription>
            Conecta tu cuenta de Instagram Business para sincronizar historias y gestionar embajadores autom√°ticamente.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Status Badge */}
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
            <div className="space-y-2">
              <div className="flex flex-wrap items-center gap-2">
                <Badge variant={statusInfo.variant} className="flex items-center gap-1">
                  {statusInfo.icon}
                  {statusInfo.status}
                </Badge>
                {instagramUsername && (
                  <Badge variant="outline" className="flex items-center gap-1 bg-white">
                    <Instagram className="h-3 w-3" />
                    @{instagramUsername}
                  </Badge>
                )}
              </div>
              <p className="text-sm text-muted-foreground">
                {statusInfo.description}
              </p>
            </div>
            
            {/* Action Buttons */}
            <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
              {isConnected ? (
                <>
                  {isTokenExpired ? (
                    <Button
                      onClick={refreshToken}
                      disabled={isSyncing}
                      variant="default"
                      className="w-full sm:w-auto"
                    >
                      <RefreshCw className={`h-4 w-4 mr-2 ${isSyncing ? 'animate-spin' : ''}`} />
                      Renovar Conexi√≥n
                    </Button>
                  ) : (
                    <Button
                      onClick={syncInstagramData}
                      disabled={isSyncing}
                      variant="outline"
                      className="w-full sm:w-auto"
                    >
                      <RefreshCw className={`h-4 w-4 mr-2 ${isSyncing ? 'animate-spin' : ''}`} />
                      Sincronizar
                    </Button>
                  )}
                  <Button
                    onClick={disconnectInstagram}
                    disabled={isConnecting}
                    variant="destructive"
                    className="w-full sm:w-auto"
                  >
                    Desconectar
                  </Button>
                </>
              ) : (
                <Button
                  onClick={() => connectInstagram()}
                  disabled={isConnecting || orgLoading || !organization}
                  className="flex items-center gap-2 w-full sm:w-auto bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600"
                  size="lg"
                >
                  <Instagram className="h-5 w-5" />
                  {orgLoading ? 'Cargando...' : 
                   !organization ? 'Preparando...' :
                   isConnecting ? 'Conectando...' : 'Conectar con Instagram'}
                </Button>
              )}
            </div>
          </div>

          {/* Help text for not connected */}
          {!isConnected && (
            <div className="flex items-start gap-3 text-sm bg-blue-50 text-blue-700 p-4 rounded-lg">
              <Info className="h-5 w-5 mt-0.5 flex-shrink-0" />
              <div className="space-y-2">
                <p className="font-medium">¬øQu√© necesitas para conectar?</p>
                <ul className="space-y-1 text-blue-600">
                  <li>‚Ä¢ Una cuenta de Instagram Business o Creator</li>
                  <li>‚Ä¢ Acceso a tu cuenta de Instagram profesional</li>
                </ul>
                <Button
                  variant="link"
                  size="sm"
                  className="p-0 h-auto text-blue-700 hover:text-blue-800"
                  onClick={() => window.open('https://help.instagram.com/502981923235522', '_blank')}
                >
                  <ExternalLink className="h-3 w-3 mr-1" />
                  ¬øC√≥mo convertir mi cuenta a Business?
                </Button>
              </div>
            </div>
          )}

          {/* Post-OAuth hint */}
          {!isConnected && (
            <div className="flex items-center gap-2 text-sm text-muted-foreground bg-muted/50 p-3 rounded-lg">
              <RefreshCw className="h-4 w-4" />
              <span>Si acabas de conectar Instagram, pulsa aqu√≠ para actualizar:</span>
              <Button
                onClick={refreshTokenStatus}
                disabled={isConnecting}
                variant="ghost"
                size="sm"
              >
                Actualizar Estado
              </Button>
            </div>
          )}

          {/* Last sync info */}
          {isConnected && lastSync && (
            <div className="text-sm text-muted-foreground">
              √öltima sincronizaci√≥n: {new Date(lastSync).toLocaleString('es-ES')}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Account Details Card - Only when connected */}
      {isConnected && (
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <CardTitle className="flex items-center gap-2">
                <Eye className="h-5 w-5" />
                Detalles de la Cuenta
              </CardTitle>
              <Button
                onClick={handleRefreshAll}
                variant="ghost"
                size="sm"
                disabled={isConnecting}
              >
                <RefreshCw className={`h-4 w-4 mr-2 ${isConnecting ? 'animate-spin' : ''}`} />
                Actualizar
              </Button>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
              <div className="p-4 bg-muted/50 rounded-lg">
                <p className="text-sm text-muted-foreground mb-1">Usuario</p>
                <p className="font-medium">
                  {instagramUsername ? `@${instagramUsername}` : 
                    <span className="text-yellow-600">No detectado</span>}
                </p>
              </div>
              <div className="p-4 bg-muted/50 rounded-lg">
                <p className="text-sm text-muted-foreground mb-1">Estado del Token</p>
                <Badge variant={isTokenExpired ? "destructive" : "default"} className={!isTokenExpired ? "bg-green-600" : ""}>
                  {isTokenExpired ? "Expirado" : "Activo"}
                </Badge>
              </div>
              <div className="p-4 bg-muted/50 rounded-lg">
                <p className="text-sm text-muted-foreground mb-1">Cuenta Business</p>
                <p className={`font-medium ${businessAccountId ? 'text-green-600' : 'text-yellow-600'}`}>
                  {businessAccountId ? '‚úì Conectada' : 'No vinculada'}
                </p>
              </div>
            </div>

            {/* Warning and diagnostic option if data seems incomplete */}
            {!businessAccountId && (
              <div className="space-y-3">
                <div className="flex items-start gap-3 text-sm text-yellow-700 bg-yellow-50 p-4 rounded-lg">
                  <AlertTriangle className="h-5 w-5 mt-0.5 flex-shrink-0" />
                  <div className="flex-1">
                    <p className="font-medium mb-1">Informaci√≥n incompleta</p>
                    <p className="text-yellow-600 mb-3">
                      Puede que los datos no se hayan cargado completamente. Intenta actualizar o ejecutar un diagn√≥stico.
                    </p>
                    <div className="flex flex-wrap gap-2">
                      <Button
                        onClick={handleRefreshAll}
                        variant="outline"
                        size="sm"
                        disabled={isConnecting}
                      >
                        <RefreshCw className={`h-4 w-4 mr-2 ${isConnecting ? 'animate-spin' : ''}`} />
                        Actualizar datos
                      </Button>
                      <Button
                        onClick={() => setShowDiagnostics(!showDiagnostics)}
                        variant="outline"
                        size="sm"
                      >
                        <Search className="h-4 w-4 mr-2" />
                        {showDiagnostics ? 'Ocultar diagn√≥stico' : 'Ver diagn√≥stico'}
                        {showDiagnostics ? <ChevronUp className="h-4 w-4 ml-1" /> : <ChevronDown className="h-4 w-4 ml-1" />}
                      </Button>
                    </div>
                  </div>
                </div>

                {/* Diagnostic Panel */}
                {showDiagnostics && (
                  <div className="border rounded-lg p-4 space-y-4">
                    <div className="flex items-center justify-between">
                      <h4 className="font-medium">Diagn√≥stico de P√°ginas</h4>
                      <Button
                        onClick={runAccountDiagnostic}
                        disabled={isDiagnosing}
                        size="sm"
                      >
                        <Search className={`h-4 w-4 mr-2 ${isDiagnosing ? 'animate-pulse' : ''}`} />
                        {isDiagnosing ? 'Analizando...' : 'Ejecutar diagn√≥stico'}
                      </Button>
                    </div>

                    {diagnosticResult && (
                      <div className="space-y-3">
                        <div className="grid grid-cols-3 gap-3 text-sm">
                          <div className="p-3 bg-muted rounded-lg text-center">
                            <p className="text-2xl font-bold">{diagnosticResult.total_pages}</p>
                            <p className="text-muted-foreground">P√°ginas encontradas</p>
                          </div>
                          <div className="p-3 bg-green-50 rounded-lg text-center">
                            <p className="text-2xl font-bold text-green-600">{diagnosticResult.pages_with_instagram}</p>
                            <p className="text-green-700">Con Instagram</p>
                          </div>
                          <div className="p-3 bg-yellow-50 rounded-lg text-center">
                            <p className="text-2xl font-bold text-yellow-600">{diagnosticResult.pages_without_instagram}</p>
                            <p className="text-yellow-700">Sin Instagram</p>
                          </div>
                        </div>

                        {diagnosticResult.pages.length > 0 && (
                          <div className="space-y-2">
                            <p className="text-sm font-medium">Detalle:</p>
                            {diagnosticResult.pages.map((page) => (
                              <div key={page.id} className="text-sm bg-muted/50 p-3 rounded-lg flex items-center justify-between">
                                <div>
                                  <p className="font-medium">{page.name}</p>
                                  <p className="text-muted-foreground text-xs">ID: {page.id}</p>
                                </div>
                                {page.instagram_business_account ? (
                                  <div className="text-right">
                                    <Badge variant="default" className="bg-green-600">
                                      @{page.instagram_business_account.username || page.instagram_business_account.id}
                                    </Badge>
                                    {page.instagram_business_account.followers_count && (
                                      <p className="text-xs text-muted-foreground mt-1">
                                        {page.instagram_business_account.followers_count.toLocaleString()} seguidores
                                      </p>
                                    )}
                                  </div>
                                ) : (
                                  <Badge variant="secondary">Sin Instagram</Badge>
                                )}
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    )}

                    {!diagnosticResult && (
                      <p className="text-sm text-muted-foreground text-center py-4">
                        Haz clic en "Ejecutar diagn√≥stico" para ver las p√°ginas de Facebook disponibles
                      </p>
                    )}
                  </div>
                )}
              </div>
            )}
          </CardContent>
        </Card>
      )}

      {/* Privacy & Security Info */}
      <Card className="border-green-200 bg-green-50/30">
        <CardContent className="pt-6">
          <div className="flex items-start gap-3">
            <Shield className="h-5 w-5 text-green-600 mt-0.5" />
            <div className="space-y-1">
              <p className="font-medium text-green-800">Tu privacidad est√° protegida</p>
              <p className="text-sm text-green-700">
                EVA System solo accede a la informaci√≥n necesaria para gestionar tus embajadores. 
                Puedes desconectar tu cuenta en cualquier momento y tus datos ser√°n eliminados.
              </p>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="supabase/functions/meta-oauth/index.ts">
import { corsHeaders, INSTAGRAM_API_BASE, INSTAGRAM_OAUTH_AUTHORIZE, INSTAGRAM_OAUTH_TOKEN, INSTAGRAM_TOKEN_EXCHANGE, INSTAGRAM_TOKEN_REFRESH, INSTAGRAM_SCOPES } from '../shared/constants.ts';
import { 
  SupabaseClient, 
  TokenData, 
  ErrorWithMessage, 
  InstagramData, 
  OrganizationInstagramData 
} from '../shared/types.ts';
import { corsPreflightResponse, jsonResponse } from '../shared/responses.ts';
import { createSupabaseClient } from '../shared/auth.ts';
import { handleError } from '../shared/error-handler.ts';
import { encryptToken, safeDecryptToken } from '../shared/crypto.ts';

Deno.serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return corsPreflightResponse();
  }

  console.log('=== INSTAGRAM OAUTH REQUEST DEBUG ===')
  console.log('Request method:', req.method)
  console.log('Request URL:', req.url)
  
  try {
    const supabaseClient = createSupabaseClient()

    const url = new URL(req.url)
    let action = url.searchParams.get('action')
    
    // Fallback: try to read action from JSON body when missing (proxy calls)
    if (!action) {
      try {
        const body = await req.clone().json()
        if (typeof body?.action === 'string') {
          action = body.action
        }
      } catch (_err) {
        // ignore JSON parse errors
      }
    }
    
    console.log('Action parameter:', action)

    switch (action) {
      case 'authorize':
        return handleAuthorize(req, supabaseClient)
      case 'callback':
        return handleCallback(req, supabaseClient)
      case 'refresh':
        return handleTokenRefresh(req, supabaseClient)
      case 'diagnose':
        return handleDiagnose(req, supabaseClient)
      default:
        console.log('Invalid action or no action specified:', action)
        return new Response(
          JSON.stringify({ 
            error: 'invalid_action', 
            error_description: 'Invalid or missing action parameter' 
          }),
          { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        )
    }
  } catch (error) {
    console.error('=== INSTAGRAM OAUTH MAIN ERROR ===')
    const errorMessage = error instanceof Error ? error.message : String(error);
    const errorName = error instanceof Error ? error.name : 'Error';
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error('Error details:', {
      name: errorName,
      message: errorMessage,
      stack: errorStack
    })
    return new Response(
      JSON.stringify({ 
        error: 'server_error', 
        error_description: 'Internal server error',
        debug_info: errorMessage
      }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})

async function getOrganizationCredentials(supabaseClient: SupabaseClient, organizationId: string) {
  // Try to get organization-specific credentials using secure function
  const { data: orgCreds, error: orgError } = await supabaseClient
    .rpc('get_organization_credentials_secure', {
      p_organization_id: organizationId
    });

  if (!orgError && orgCreds && orgCreds.length > 0) {
    const creds = orgCreds[0];
    console.log('Using organization-specific Instagram credentials');
    return {
      app_id: creds.meta_app_id,
      app_secret: creds.meta_app_secret,
      webhook_verify_token: creds.webhook_verify_token
    };
  }

  console.log('Using global Instagram credentials as fallback');
  return {
    app_id: Deno.env.get('INSTAGRAM_APP_ID'),
    app_secret: Deno.env.get('INSTAGRAM_APP_SECRET'),
    webhook_verify_token: Deno.env.get('WEBHOOK_VERIFY_TOKEN')
  };
}

async function handleAuthorize(req: Request, supabaseClient: SupabaseClient) {
  try {
    const authHeader = req.headers.get('Authorization') || '';
    const token = authHeader.startsWith('Bearer ') ? authHeader.replace('Bearer ', '') : null;

    if (!token) {
      return jsonResponse(
        { error: 'unauthorized', error_description: 'Missing auth token' },
        { status: 401 }
      );
    }

    const { data: { user: authUser } } = await supabaseClient.auth.getUser(token);
    if (!authUser) {
      return jsonResponse(
        { error: 'unauthorized', error_description: 'Invalid auth token' },
        { status: 401 }
      );
    }

    type AuthorizeBody =
      | {
          type: 'ambassador';
          ambassador_id: string;
          organization_id: string;
          redirect_base?: string;
        }
      | {
          type: 'organization';
          organization_id: string;
          redirect_base?: string;
        };

    const body = await req.json();
    const { type, ambassador_id, organization_id, redirect_base } = body as AuthorizeBody & {
      ambassador_id?: string;
    };

    if (!type || !organization_id) {
      return jsonResponse(
        {
          error: 'invalid_request',
          error_description: 'type and organization_id are required',
        },
        { status: 400 }
      );
    }

    if (type === 'ambassador' && !ambassador_id) {
      return jsonResponse(
        {
          error: 'invalid_request',
          error_description: 'ambassador_id is required for ambassador flow',
        },
        { status: 400 }
      );
    }

    // ----- NEW: organization_members-based membership check -----
    const { data: membership, error: membershipError } = await supabaseClient
      .from('organization_members')
      .select('id, organization_id, status, permissions')
      .eq('user_id', authUser.id)              // auth.users.id
      .eq('organization_id', organization_id)
      .eq('status', 'active')
      .single();

    if (membershipError || !membership) {
      return jsonResponse(
        {
          error: 'forbidden',
          error_description: 'No access to this organization',
        },
        { status: 403 }
      );
    }

    // Optional: enforce permissions
    const perms = (membership as any).permissions || {};
    const canManageAmbassadors =
      perms.manage_ambassadors === true || perms.manage_instagram === true;

    if (!canManageAmbassadors && type === 'ambassador') {
      return jsonResponse(
        {
          error: 'forbidden',
          error_description:
            'You do not have permissions to manage ambassadors for this organization',
        },
        { status: 403 }
      );
    }

    // Still get the internal app user row, but only for storing oauth_states.user_id
    const { data: appUser } = await supabaseClient
      .from('users')
      .select('id')
      .eq('auth_user_id', authUser.id)
      .single();

    // Use global Instagram App credentials for all users
    const appId = Deno.env.get('INSTAGRAM_APP_ID');
    const appSecret = Deno.env.get('INSTAGRAM_APP_SECRET');

    const REDIRECT_URI = `https://app.evasystem.cl/meta-oauth`;

    if (!appId || !appSecret) {
      console.error('Missing Instagram credentials');
      return jsonResponse(
        {
          error: 'configuration_error',
          error_description:
            'Instagram connection is not available. Instagram App credentials are not configured.',
        },
        { status: 500 }
      );
    }

    // Build state payload
    const statePayload =
      type === 'ambassador'
        ? {
            type: 'ambassador' as const,
            ambassador_id,
            organization_id,
            auth_user_id: authUser.id,
            redirect_base: redirect_base || 'https://app.evasystem.cl/ambassadors',
            nonce: crypto.randomUUID(),
          }
        : {
            type: 'organization' as const,
            organization_id,
            auth_user_id: authUser.id,
            redirect_base: redirect_base || 'https://app.evasystem.cl/settings',
            nonce: crypto.randomUUID(),
          };

    const state = btoa(JSON.stringify(statePayload));

    const expiresAt = new Date(Date.now() + 10 * 60 * 1000).toISOString();

    const { error: stateError } = await supabaseClient.from('oauth_states').insert({
      state,
      user_id: appUser?.id ?? null, // internal app user (can be null if not found)
      ambassador_id: type === 'ambassador' ? ambassador_id : null,
      organization_id,
      type,
      redirect_base: redirect_base || null,
      created_at: new Date().toISOString(),
      expires_at: expiresAt,
    });

    if (stateError) {
      console.error('Error storing OAuth state:', stateError);
      return jsonResponse(
        {
          error: 'database_error',
          error_description: `Failed to initialize Instagram connection: ${
            stateError.message || 'Database error'
          }`,
        },
        { status: 500 }
      );
    }

    const authUrl =
      `${INSTAGRAM_OAUTH_AUTHORIZE}?` +
      `client_id=${encodeURIComponent(appId)}&` +
      `redirect_uri=${encodeURIComponent(REDIRECT_URI)}&` +
      `response_type=code&` +
      `scope=${encodeURIComponent(INSTAGRAM_SCOPES)}&` +
      `state=${encodeURIComponent(state)}`;


    return jsonResponse({ authUrl });
  } catch (error) {
    console.error('Error in handleAuthorize:', error);
    return jsonResponse(
      {
        error: 'authorization_failed',
        error_description: `Failed to create Instagram authorization: ${
          error instanceof Error ? error.message : 'Unknown error'
        }`,
      },
      { status: 500 }
    );
  }
}



async function handleCallback(req: Request, supabaseClient: SupabaseClient) {
  // Try to get data from body (proxy call from frontend)
  let code: string | undefined;
  let state: string | undefined;
  let metaError: string | undefined;
  let isProxyCall = false;

  try {
    const body = await req.json();
    if (body.action === 'callback') {
      code = body.code;
      state = body.state;
      metaError = body.error;
      isProxyCall = true;
    }
  } catch {
    // We no longer support direct Meta -> Edge callbacks
    isProxyCall = false;
  }

  if (!isProxyCall) {
    return jsonResponse(
      {
        success: false,
        error: 'unsupported_flow',
        error_description:
          'Direct callbacks are not supported. Use the frontend /meta-oauth proxy route.',
      },
      { status: 400 },
    );
  }

  if (metaError) {
    console.error('Instagram OAuth error received from frontend:', metaError);
    return jsonResponse(
      {
        success: false,
        error: 'meta_oauth_error',
        error_description: 'Authorization failed on Instagram side',
        debug_info: metaError,
      },
      { status: 200 },
    );
  }

  if (!code || !state) {
    const errorMsg = 'Missing authorization code or state';
    return jsonResponse(
      {
        success: false,
        error: 'invalid_request',
        error_description: errorMsg,
      },
      { status: 400 },
    );
  }

  try {
    // Require that caller is authenticated (the admin or user who initiated the flow)
    const authHeader = req.headers.get('Authorization') || '';
    const token = authHeader.startsWith('Bearer ')
      ? authHeader.replace('Bearer ', '')
      : null;

    if (!token) {
      return jsonResponse(
        {
          success: false,
          error: 'unauthorized',
          error_description: 'Missing auth token',
        },
        { status: 401 },
      );
    }

    const {
      data: { user: authUser },
    } = await supabaseClient.auth.getUser(token);

    if (!authUser) {
      return jsonResponse(
        {
          success: false,
          error: 'unauthorized',
          error_description: 'Invalid auth token',
        },
        { status: 401 },
      );
    }

    // Look up state in DB
    const { data: stateData, error: stateError } = await supabaseClient
      .from('oauth_states')
      .select('*')
      .eq('state', state)
      .single();

    if (stateError || !stateData) {
      const errorMsg = 'Invalid or expired authorization state';
      return jsonResponse(
        {
          success: false,
          error: 'invalid_state',
          error_description: errorMsg,
        },
        { status: 400 },
      );
    }

    // Decode JSON payload stored in state text
    type StatePayload = {
      type: 'ambassador' | 'organization';
      ambassador_id?: string;
      organization_id?: string;
      auth_user_id: string;
      redirect_base?: string;
      nonce: string;
    };

    let decoded: StatePayload;
    try {
      decoded = JSON.parse(atob(state)) as StatePayload;
    } catch (e) {
      console.error('Failed to decode state payload:', e);
      return jsonResponse(
        {
          success: false,
          error: 'invalid_state',
          error_description: 'Malformed state payload',
        },
        { status: 400 },
      );
    }

    if (decoded.auth_user_id !== authUser.id) {
      return jsonResponse(
        {
          success: false,
          error: 'forbidden',
          error_description: 'State does not belong to this user',
        },
        { status: 403 },
      );
    }

    console.log('=== CALLBACK PROCESSING ===');
    console.log('DB state row:', {
      db_type: stateData.type,
      db_user_id: stateData.user_id,
      db_ambassador_id: stateData.ambassador_id,
      db_organization_id: stateData.organization_id,
    });
    console.log('Decoded state payload:', decoded);
    console.log('Starting token exchange...');

    const tokenData = await exchangeCodeForToken(
      code
    );

    console.log('Token exchange successful, updating database...');

    if (stateData.type === 'ambassador') {
      const ambassadorId =
        stateData.ambassador_id ?? decoded.ambassador_id ?? null;

      if (!ambassadorId) {
        return jsonResponse(
          {
            success: false,
            error: 'invalid_state',
            error_description:
              'Missing ambassador_id in state for ambassador connection',
          },
          { status: 400 },
        );
      }

      // Link the Instagram token & profile to the ambassador
      await updateAmbassadorInstagramData(
        supabaseClient,
        ambassadorId,
        tokenData,
      );

      // Clean up state
      await supabaseClient.from('oauth_states').delete().eq('state', state);

      return jsonResponse(
        {
          success: true,
          message: 'Instagram connected successfully',
          type: 'ambassador',
          timestamp: new Date().toISOString(),
        },
        { status: 200 },
      );
    }

    if (stateData.type === 'organization') {
      const organizationId =
        stateData.organization_id ?? decoded.organization_id ?? null;

      if (!organizationId) {
        return jsonResponse(
          {
            success: false,
            error: 'invalid_state',
            error_description:
              'Missing organization_id in state for organization connection',
          },
          { status: 400 },
        );
      }

      // Verify organization membership (same RPC you used before)
      const { data: isMember, error: memberError } = await supabaseClient.rpc(
        'is_organization_member',
        {
          user_auth_id: authUser.id,
          org_id: organizationId,
        },
      );

      if (memberError || !isMember) {
        return jsonResponse(
          {
            success: false,
            error: 'forbidden',
            error_description: 'No access to this organization',
          },
          { status: 403 },
        );
      }

      // Link the Instagram Business account to the organization
      await updateOrganizationInstagramData(
        supabaseClient,
        organizationId,
        tokenData,
      );

      // Clean up state
      await supabaseClient.from('oauth_states').delete().eq('state', state);

      return jsonResponse(
        {
          success: true,
          message: 'Instagram connected successfully',
          type: 'organization',
          timestamp: new Date().toISOString(),
        },
        { status: 200 },
      );
    }

    // Should not happen because of CHECK(type) in DB
    return jsonResponse(
      {
        success: false,
        error: 'unknown_type',
        error_description: `Unsupported connection type: ${stateData.type}`,
      },
      { status: 400 },
    );
  } catch (error) {
    console.error('=== CALLBACK ERROR ===');
    const err = error as ErrorWithMessage;
    console.error('Error details:', {
      name: err?.name,
      message: err?.message,
      stack: err?.stack,
    });

    // Similar error shape as your old code
    let errorType = 'token_exchange_failed';
    let errorMsg = 'Failed to process Instagram authorization';
    let debugInfo = err?.message ?? String(error);

    if (err?.message?.includes('Short-lived token exchange failed')) {
      errorType = 'meta_api_error';
      errorMsg =
        'Instagram API rejected the authorization code. This could be due to expired state, mismatched redirect URI, or invalid App configuration.';
      debugInfo = `Instagram API Error: ${err.message}`;
    } else if (err?.message?.includes('Invalid time value')) {
      errorType = 'token_processing_error';
      errorMsg = 'Error processing token expiration data from Instagram API.';
      debugInfo =
        'Token expiry calculation failed - Instagram API may have returned invalid data';
    } else if (err?.message?.includes('Failed to store')) {
      errorType = 'database_error';
      errorMsg = 'Error saving Instagram connection data.';
      debugInfo = `Database Error: ${err.message}`;
    }

    return jsonResponse(
      {
        success: false,
        error: errorType,
        error_description: errorMsg,
        debug_info: debugInfo,
        timestamp: new Date().toISOString(),
      },
      { status: 200 },
    );
  }
}

async function exchangeCodeForToken(code: string) {
  const appId = Deno.env.get('INSTAGRAM_APP_ID');
  const appSecret = Deno.env.get('INSTAGRAM_APP_SECRET');
  const REDIRECT_URI = 'https://app.evasystem.cl/meta-oauth';

  // Step 1: code -> short-lived user access token
  const shortRes = await fetch(INSTAGRAM_OAUTH_TOKEN, {
    method: 'POST',
    body: new URLSearchParams({
      client_id: appId!,
      client_secret: appSecret!,
      grant_type: 'authorization_code',
      redirect_uri: REDIRECT_URI,
      code: code
    })
  });

  const shortData = await shortRes.json();

  if (!shortRes.ok || shortData.error) {
    throw new Error(
      `Short-lived token exchange failed: ${shortData.error?.message || shortData.error_description || 'Unknown error'}`
    );
  }

  // Step 2: short-lived -> long-lived token
  const longUrl =
    `${INSTAGRAM_TOKEN_EXCHANGE}` +
    `?grant_type=ig_exchange_token` +
    `&client_secret=${encodeURIComponent(appSecret!)}` +
    `&access_token=${encodeURIComponent(shortData.access_token)}`;

  const longRes = await fetch(longUrl);
  const longData = await longRes.json();

  if (!longRes.ok || longData.error) {
    throw new Error(
      `Long-lived token exchange failed: ${longData.error?.message || longData.error_description || 'Unknown error'}`
    );
  }

  // Compute expiry
  const expiresAt = new Date();
  expiresAt.setSeconds(expiresAt.getSeconds() + (longData.expires_in ?? 60 * 24 * 60 * 60));

  return {
    access_token: longData.access_token,
    token_type: longData.token_type || 'bearer',
    expires_in: longData.expires_in,
    expires_at: expiresAt.toISOString(),
  };
}

// Update ambassador data in Supabase using secure token storage
async function updateAmbassadorInstagramData(
  supabaseClient: SupabaseClient,
  ambassadorId: string,
  tokenData: TokenData,
) {
  try {
    console.log('Updating ambassador Instagram data for ambassador:', ambassadorId);

    if (!tokenData.access_token) {
      throw new Error('No access token provided');
    }

    // 1) Get "user" info from Instagram
    // Includes fields to populate our database
    const userResponse = await fetch(
      `${INSTAGRAM_API_BASE}/me?fields=user_id,username,name,profile_picture_url,followers_count&access_token=${encodeURIComponent(
        tokenData.access_token,
      )}`,
    );
    const userData = await userResponse.json();

    if (!userResponse.ok || userData.error) {
      console.error('Error fetching /me:', userData.error || userData);
      throw new Error(
        userData.error?.message || 'Failed to fetch Instagram user profile data',
      );
    }

    const instagramData: InstagramData = {
      instagram_user_id: userData.user_id || userData.id,
      instagram_user: userData.username,
      follower_count: userData.followers_count || 0,
      profile_picture_url: userData.profile_picture_url,
    };

    // 3) Compute expiry date (Meta sometimes omits expires_in)
    const expiryDate = tokenData.expires_in
      ? new Date(Date.now() + tokenData.expires_in * 1000)
      : new Date(Date.now() + 60 * 24 * 60 * 60 * 1000); // default ~60 days

    // 4) Encrypt and store token in ambassador_tokens    
    const encryptedToken = await encryptToken(tokenData.access_token);

    const { error: tokenError } = await supabaseClient
      .from('ambassador_tokens')
      .upsert(
        {
          embassador_id: ambassadorId,
          access_token: encryptedToken,
          token_expiry: expiryDate.toISOString(),
          updated_at: new Date().toISOString(),
        },
        {
          onConflict: 'embassador_id',  
        }
      );


    if (tokenError) {
      console.error('Failed to store ambassador token:', tokenError);
      throw new Error('Failed to store ambassador token');
    }

    // 5) Update embassadors row with public IG info only
    const { error: updateError } = await supabaseClient
      .from('embassadors')
      .update({
        last_instagram_sync: new Date().toISOString(),
        instagram_user: instagramData.instagram_user,
        instagram_user_id: instagramData.instagram_user_id,
        follower_count: instagramData.follower_count ?? 0,
        profile_picture_url: instagramData.profile_picture_url ?? null,
      })
      .eq('id', ambassadorId);

    if (updateError) {
      console.error('Failed to update ambassador:', updateError);
      throw new Error('Failed to update ambassador data');
    }

    console.log('Ambassador Instagram data updated successfully');
  } catch (error) {
    console.error('Error updating ambassador Instagram data:', error);
    throw error;
  }
}

// Update organization data in Supabase using secure token storage
async function updateOrganizationInstagramData(
  supabaseClient: SupabaseClient,
  organizationId: string,
  tokenData: TokenData,
) {
  try {
    console.log('Updating organization Instagram data for:', organizationId);

    if (!tokenData.access_token) {
      throw new Error('No access token provided');
    }

    // 1) Get Instagram user info directly
    const userResponse = await fetch(
      `${INSTAGRAM_API_BASE}/me?fields=user_id,username,name,profile_picture_url,followers_count&access_token=${encodeURIComponent(
        tokenData.access_token,
      )}`,
    );
    const userData = await userResponse.json();

    if (!userResponse.ok || userData.error) {
      console.error('Error fetching /me:', userData.error || userData);
      throw new Error(
        userData.error?.message || 'Failed to fetch Instagram user profile data',
      );
    }

    const instagramData: OrganizationInstagramData = {
      // No Facebook Page ID needed with Instagram Login
      facebook_page_id: '', // Optional or remove if schema allows null
      instagram_business_account_id: userData.user_id || userData.id, // Same ID
      instagram_username: userData.username,
      instagram_user_id: userData.user_id || userData.id,
    };
    
    console.log(`Instagram Business Account connected: @${instagramData.instagram_username} (${instagramData.instagram_user_id})`);

    // 4) Compute expiry date
    const expiryDate = tokenData.expires_in
      ? new Date(Date.now() + tokenData.expires_in * 1000)
      : new Date(Date.now() + 60 * 24 * 60 * 60 * 1000); // default ~60 days

    // 5) Encrypt and store token
    const encryptedToken = await encryptToken(tokenData.access_token);
    const { error: tokenError } = await supabaseClient
      .from('organization_instagram_tokens')
      .upsert(
        {
          organization_id: organizationId,
          access_token: encryptedToken,
          token_expiry: expiryDate.toISOString(),
          updated_at: new Date().toISOString(),
        },
        {
          onConflict: 'organization_id',
        }
      );

    if (tokenError) {
      console.error('Failed to store organization token:', tokenError);
      throw new Error('Failed to store organization token');
    }

    // 6) Update organizations row with public IG info
    const { error: updateError } = await supabaseClient
      .from('organizations')
      .update({
        last_instagram_sync: new Date().toISOString(),
        facebook_page_id: null, // Clear FB page ID as it's no longer relevant/available
        instagram_business_account_id: instagramData.instagram_business_account_id,
        instagram_username: instagramData.instagram_username,
        instagram_user_id: instagramData.instagram_user_id,
      })
      .eq('id', organizationId);

    if (updateError) {
      console.error('Failed to update organization:', updateError);
      throw new Error('Failed to update organization data');
    }

    // 7) Subscribe to webhooks (using User Access Token)
    // Note: With Instagram Login, we use the User Access Token directly
    try {
      if (instagramData.instagram_business_account_id) {
        console.log('Subscribing Instagram Business Account to webhooks...');
        const igWebhookResponse = await fetch(
          `${INSTAGRAM_API_BASE}/${instagramData.instagram_business_account_id}/subscribed_apps`,
          {
            method: 'POST',
            body: new URLSearchParams({
              subscribed_fields: 'mentions,comments,story_insights',
              access_token: tokenData.access_token,
            }),
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
            },
          },
        );

        const igWebhookData = await igWebhookResponse.json();

        if (igWebhookResponse.ok) {
          console.log('Instagram webhook subscription successful:', igWebhookData);
        } else {
          console.warn('Instagram webhook subscription failed:', igWebhookData);
        }
      }
    } catch (webhookError) {
      console.warn('Webhook subscription failed:', webhookError);
      // not fatal ‚Äì token stored and org updated
    }

    console.log('Organization Instagram data updated successfully');
  } catch (error) {
    console.error('Error updating organization Instagram data:', error);
    throw error;
  }
}

// Handle token refresh using secure token storage
async function handleTokenRefresh(req: Request, supabaseClient: SupabaseClient) {
  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('No authorization header');
    }

    const { data: { user }, error: authError } = await supabaseClient.auth.getUser(
      authHeader.replace('Bearer ', ''),
    );

    if (authError || !user) {
      throw new Error('Unauthorized');
    }

    const { organization_id, ambassador_id } = await req.json();

    // --- ORGANIZATION TOKEN REFRESH ---
    if (organization_id) {
      // Verify logged-in user belongs to this organization
      const { data: userData, error: userError } = await supabaseClient
        .from('users')
        .select('organization_id')
        .eq('auth_user_id', user.id)
        .single();

      if (userError || !userData || userData.organization_id !== organization_id) {
        throw new Error('Unauthorized to refresh this organization token');
      }

      // Get current token
      const { data: tokenData, error: tokenError } = await supabaseClient
        .from('organization_instagram_tokens')
        .select('access_token')
        .eq('organization_id', organization_id)
        .single();

      if (tokenError || !tokenData?.access_token) {
        throw new Error('No token found for organization');
      }

      const decryptedToken = await safeDecryptToken(tokenData.access_token);

      // Refresh IG long-lived token
      const newTokenData = await exchangeTokenForLongLived(decryptedToken);

      // Update token
      const encryptedNewToken = await encryptToken(newTokenData.access_token);
      const expiresAt = new Date(
        Date.now() + (newTokenData.expires_in ?? 60 * 24 * 60 * 60) * 1000,
      ).toISOString();

      const { error: updateError } = await supabaseClient
        .from('organization_instagram_tokens')
        .update({
          access_token: encryptedNewToken,
          token_expiry: expiresAt,
          updated_at: new Date().toISOString(),
        })
        .eq('organization_id', organization_id);

      if (updateError) {
        throw new Error('Failed to update organization token');
      }

      return new Response(
        JSON.stringify({ success: true, message: 'Organization token refreshed successfully' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 200,
        },
      );
    }

    // --- AMBASSADOR TOKEN REFRESH ---
    if (ambassador_id) {
      // Find ambassador org
      const { data: ambassadorData, error: ambassadorError } = await supabaseClient
        .from('embassadors')
        .select('organization_id')
        .eq('id', ambassador_id)
        .single();

      if (ambassadorError || !ambassadorData) {
        throw new Error('Ambassador not found');
      }

      // Verify logged-in user belongs to same org
      const { data: userData, error: userError } = await supabaseClient
        .from('users')
        .select('organization_id')
        .eq('auth_user_id', user.id)
        .single();

      if (userError || !userData || userData.organization_id !== ambassadorData.organization_id) {
        throw new Error('Unauthorized to refresh this ambassador token');
      }

      // Get current token
      const { data: tokenData, error: tokenError } = await supabaseClient
        .from('ambassador_tokens')
        .select('access_token')
        .eq('embassador_id', ambassador_id)
        .single();

      if (tokenError || !tokenData?.access_token) {
        throw new Error('No token found for ambassador');
      }

      const decryptedToken = await safeDecryptToken(tokenData.access_token);

      // Refresh IG long-lived token
      const newTokenData = await exchangeTokenForLongLived(decryptedToken);

      // Update token
      const encryptedNewToken = await encryptToken(newTokenData.access_token);
      const expiresAt = new Date(
        Date.now() + (newTokenData.expires_in ?? 60 * 24 * 60 * 60) * 1000,
      ).toISOString();

      const { error: updateError } = await supabaseClient
        .from('ambassador_tokens')
        .update({
          access_token: encryptedNewToken,
          token_expiry: expiresAt,
          updated_at: new Date().toISOString(),
        })
        .eq('embassador_id', ambassador_id);

      if (updateError) {
        throw new Error('Failed to update ambassador token');
      }

      return new Response(
        JSON.stringify({ success: true, message: 'Ambassador token refreshed successfully' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 200,
        },
      );
    }

    throw new Error('Missing organization_id or ambassador_id');
  } catch (err) {
    const error = err as Error;
    console.error('Token refresh error:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      },
    );
  }
}


// Helper function to exchange a token for a long-lived token
// Refresh an Instagram long-lived access token
async function exchangeTokenForLongLived(accessToken: string): Promise<{
  access_token: string;
  token_type?: string;
  expires_in?: number;
}> {
  const url =
    `${INSTAGRAM_TOKEN_REFRESH}?` +
    `grant_type=ig_refresh_token&access_token=${encodeURIComponent(accessToken)}`;

  const response = await fetch(url);
  const data = await response.json();

  if (!response.ok || data.error) {
    console.error('Token exchange error:', data.error || data);
    throw new Error(
      data.error?.message || data.error_message || 'Failed to refresh Instagram token',
    );
  }

  console.log('Instagram token refreshed successfully');
  return data;
}


async function subscribeToPageWebhooks(pageId: string, accessToken: string) {
  // This function is less relevant now with Instagram Login which uses the User ID
  // But kept for compatibility if needed, though Instagram Login doesn't use Page tokens.
  // This was mainly for Facebook Page subscription.
  console.log("Skipping Page Webhook subscription (not applicable for Instagram Login flow)");
}

// Diagnose endpoint - lists all Facebook Pages and their Instagram accounts
async function handleDiagnose(req: Request, supabaseClient: SupabaseClient) {
  try {
    const authHeader = req.headers.get('Authorization') || '';
    const token = authHeader.startsWith('Bearer ') ? authHeader.replace('Bearer ', '') : null;

    if (!token) {
      return jsonResponse(
        { success: false, error: 'unauthorized', error_description: 'Missing auth token' },
        { status: 401 }
      );
    }

    const { data: { user: authUser } } = await supabaseClient.auth.getUser(token);
    if (!authUser) {
      return jsonResponse(
        { success: false, error: 'unauthorized', error_description: 'Invalid auth token' },
        { status: 401 }
      );
    }

    // Get user's organization
    const { data: userOrgs } = await supabaseClient
      .rpc('get_user_organizations', { user_auth_id: authUser.id });

    if (!userOrgs || userOrgs.length === 0) {
      return jsonResponse({
        success: false,
        error: 'no_organization',
        error_description: 'User has no organization',
      });
    }

    const organizationId = userOrgs[0].organization_id;

    // Get the stored token with updated_at timestamp
    const { data: tokenData, error: tokenError } = await supabaseClient
      .from('organization_instagram_tokens')
      .select('access_token, updated_at')
      .eq('organization_id', organizationId)
      .single();

    if (tokenError || !tokenData?.access_token) {
      return jsonResponse({
        success: false,
        error: 'no_token',
        error_description: 'No Instagram token found. Please connect Instagram first.',
      });
    }

    console.log('Token last updated at:', tokenData.updated_at);

    // Decrypt the token
    const accessToken = await safeDecryptToken(tokenData.access_token);
    console.log('Token decrypted, length:', accessToken?.length || 0);

    // New diagnostic: Check /me endpoint directly
    const meResponse = await fetch(
      `${INSTAGRAM_API_BASE}/me?fields=id,username,account_type&access_token=${encodeURIComponent(accessToken)}`,
    );
    const meData = await meResponse.json();

    console.log('Instagram API /me returned:', meData);

    if (!meResponse.ok || meData.error) {
      return jsonResponse({
        success: false,
        error: 'instagram_api_error',
        error_description: meData.error?.message || 'Failed to fetch Instagram user',
        token_updated_at: tokenData.updated_at,
      });
    }

    return jsonResponse({
      success: true,
      data: {
        instagram_account: {
          id: meData.id,
          username: meData.username,
          account_type: meData.account_type
        },
        token_updated_at: tokenData.updated_at,
        message: 'Instagram connection is active and valid.'
      }
    });

  } catch (error) {
    console.error('Diagnose error:', error);
    return jsonResponse({
      success: false,
      error: 'diagnose_error',
      error_description: error instanceof Error ? error.message : 'Unknown error',
    });
  }
}
</file>

</files>
